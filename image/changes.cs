RBProgramNodeVisitor subclass: #ASTChecker	instanceVariableNames: 'scope varsChangedInSend'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!RBProgramNodeVisitor subclass: #ASTTranslator	instanceVariableNames: 'methodBuilder receiverForCascade'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #Application	instanceVariableNames: 'arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!AssembleInstruction subclass: #AssembleCMov	instanceVariableNames: ''	classVariableNames: 'Condition'	poolDictionaries: ''	category: 'Exupery'!Object subclass: #AssemblerExupery	instanceVariableNames: 'stream blockAddresses jumpOffsets bytecodes instructionEncoders plugin relocator picEntries debugCollector source'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #BlockClosure	instanceVariableNames: 'method environment'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Contexts'!PluggableGtkSimpleApplication subclass: #ClassFinder	instanceVariableNames: 'classTrait'	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!Object subclass: #ColouringRegisterAllocator	instanceVariableNames: 'source result machine interferenceGraph registerStack registerFile registerTable spiltRegisters hasSpilt coloursUsed simplifyWorklist spillWorklist moveWorklist coalescedMoves isValidating deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #DebugInfo	instanceVariableNames: 'codeSourceReferences argVarsReferences tempVarsReferences capturedVarsReferences'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!Object subclass: #EventManager	instanceVariableNames: 'actionMap'	classVariableNames: 'ActionMaps'	poolDictionaries: ''	category: 'System-Object'!Error subclass: #ExternalFunctionError	instanceVariableNames: 'functionName '	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!Object subclass: #ExternalObject	instanceVariableNames: 'handle '	classVariableNames: 'Registry '	poolDictionaries: ''	category: 'FFI-Types'!ExternalObject subclass: #DynamicLibrary	instanceVariableNames: 'name symbolCache'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!DynamicLibrary subclass: #Executable	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!ExternalObject subclass: #ExternalBuffer	instanceVariableNames: 'size'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalBuffer subclass: #AsciiZ	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!DynamicLibrary class	instanceVariableNames: 'default'!ExternalObject subclass: #ExternalObjectProxy	instanceVariableNames: 'object'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalObjectProxy subclass: #ExternalArrayProxy	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalObject subclass: #ExternalSymbol	instanceVariableNames: 'name library'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!ExternalSymbol subclass: #ExecutableFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!ExecutableFunction subclass: #CDeclFunction	instanceVariableNames: 'returnType argTypes'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Error subclass: #ExternalSymbolError	instanceVariableNames: 'symbolName'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!ExternalObject subclass: #FileDescriptor	instanceVariableNames: ''	classVariableNames: 'StandardDescriptors'	poolDictionaries: ''	category: 'FFI-Types'!Error subclass: #FileStreamException	instanceVariableNames: 'fileName'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #CannotDeleteFileException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #FileDoesNotExistException	instanceVariableNames: 'readOnly'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #FileExistsException	instanceVariableNames: 'fileClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!AssemblyCopier subclass: #FinalCopier	instanceVariableNames: 'deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!LexicalScope subclass: #FunctionScope	instanceVariableNames: 'thisContextVar thisEnvVar tempVars capturedVars isHome hasInnerFreeVars hideTemps argVars uninitializedTemps capturedParentEnv'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #GIRBuilder	instanceVariableNames: 'ir currentBlock machine relocationInfo primitiveNode literals thisEnvVar cacheMap literalTemp source start stop debugInfo'	classVariableNames: 'InlinedSelectors SpecialConstants SpecialSelectors'	poolDictionaries: ''	category: 'Compiler-IR'!LexicalScope subclass: #InstanceScope	instanceVariableNames: 'vars'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!DynamicLibrary subclass: #LibC6	instanceVariableNames: ''	classVariableNames: 'LSeekDirectives OpenFlags'	poolDictionaries: ''	category: 'FFI-Libraries'!Object subclass: #LibExample	instanceVariableNames: ''	classVariableNames: 'GETPID'	poolDictionaries: ''	category: 'Guille-Test'!DynamicLibrary subclass: #LibReadLine	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!ExternalSymbol subclass: #LibraryData	instanceVariableNames: 'type'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Object subclass: #LivenessAnalyser	instanceVariableNames: 'source hasUpdated isValidating deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #MedLanguage	instanceVariableNames: 'in out start stop'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedCMov	instanceVariableNames: 'type from to'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedEnter	instanceVariableNames: 'argument'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedLeave	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedLiteral	instanceVariableNames: 'literal'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLiteral subclass: #MedFunction	instanceVariableNames: 'block byteCodeAddress'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!ExecutableFunction subclass: #NativeFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Object subclass: #PrimitiveType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!PrimitiveType subclass: #IntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!RBProgramNode subclass: #RBReturnNode	instanceVariableNames: 'return value homeBinding frameBinding'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Nodes'!ExternalObject subclass: #ReadOnlyAsciiZ	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SemanticWarning subclass: #RedeclaredVariableWarning	instanceVariableNames: 'variableNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #RelocationInfo	instanceVariableNames: 'offset'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #ExecutableFunctionRelocation	instanceVariableNames: 'functionName'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #FunctionRelocation	instanceVariableNames: 'function'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #LiteralRelocation	instanceVariableNames: 'literals'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!ExecutableFunctionRelocation subclass: #NativeFunctionRelocation	instanceVariableNames: 'libraryName'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!NativeFunctionRelocation subclass: #ExternalFunctionRelocation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #PrimitiveRelocation	instanceVariableNames: 'number'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!Object subclass: #ScopeVar	instanceVariableNames: 'scope usage'	classVariableNames: 'UsageAutomaton'	poolDictionaries: ''	category: 'Compiler-Semantics'!ScopeVar subclass: #GlobalVar	instanceVariableNames: 'assoc'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!ScopeVar subclass: #LocalVar	instanceVariableNames: 'name index'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!LocalVar subclass: #ArgVar	instanceVariableNames: 'isArg'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!LocalVar subclass: #CapturedVar	instanceVariableNames: 'sourceTemp'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!ByteArray variableByteSubclass: #ExternalValue	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!Object subclass: #SharedPool	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Pools'!Application subclass: #Shell	instanceVariableNames: 'bindings '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!IntegerType subclass: #SignedIntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedByte	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedShortInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!Object subclass: #SourceReference	instanceVariableNames: 'sourceStart sourceStop codeStop'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!RelocationInfo subclass: #SpecialSelectorRelocation	instanceVariableNames: 'specialSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!Model subclass: #StringHolder	instanceVariableNames: 'contents'	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Kernel-Remnants'!Object subclass: #SystemTracer	instanceVariableNames: 'byteStream traceQueue oopMap nextChunk nilOop count'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Tracer'!LocalVar subclass: #TempVar	instanceVariableNames: 'isArg'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Error subclass: #TraitException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Kernel'!TraitException subclass: #TraitCompositionException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Composition'!Error subclass: #TypeConvertionError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!FileStream subclass: #UnbufferedFileStream	instanceVariableNames: 'name fileID'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!Smalltalk renameClassNamed: #BufferedFileStream2 as: #BufferedFileStream!UnbufferedFileStream subclass: #BufferedFileStream	instanceVariableNames: ''	classVariableNames: 'DefaultBufferSize'	poolDictionaries: ''	category: 'Files-Kernel'!BufferedFileStream subclass: #BinaryFileStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!BufferedFileStream subclass: #TextFileStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!IntegerType subclass: #UnsignedIntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedByte	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedShortInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SemanticWarning subclass: #UnusedVariableWarning	instanceVariableNames: 'variableNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #VarReference	instanceVariableNames: 'name'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!RelocationInfo subclass: #VariableRelocation	instanceVariableNames: 'variable'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!PluggableGtkSimpleApplication subclass: #Workspace	instanceVariableNames: 'workspaceView'	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!Workspace subclass: #TranscriptCodeEditor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!!Object methodsFor: 'as yet unclassified'!errorSubscriptBounds: index 	"Create an error notification that an improper integer was used as an index."	self error: 'subscript is out of bounds: ' , index printString! !!Object methodsFor: 'as yet unclassified'!executeMethod: compiledMethod withArgs: argArray	"Execute compiledMethod against the receiver and args in argArray"	| selector |	<primitive: 188>	selector _ Symbol new.	self class addSelectorSilently: selector withMethod: compiledMethod.	^ [self perform: selector withArguments: argArray]		ensure: [self class basicRemoveSelector: selector]! !!Object methodsFor: 'as yet unclassified'!withArgs: argArray executeMethod: compiledMethod	"For compatibility with Aqueak"	self executeMethod: compiledMethod withArgs: argArray! !!Application methodsFor: 'as yet unclassified'!arguments	^ arguments.! !!Application methodsFor: 'as yet unclassified'!arguments: anArray	arguments := anArray.! !!Application methodsFor: 'as yet unclassified'!main	self subclassResponsibility.! !!Application methodsFor: 'as yet unclassified'!startUp	Smalltalk startUp.	^ self main.! !!Behavior methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return true if it is safe to zap the method dictionary on #obsolete"	^true! !!Behavior methodsFor: 'as yet unclassified'!isWeak	^ (format bitAnd: 4) = 1.! !!Behavior methodsFor: 'as yet unclassified'!obsolete	"Invalidate and recycle local methods,	e.g., zap the method dictionary if can be done safely."	self canZapMethodDictionary		ifTrue: [self methodDict: self emptyMethodDictionary].! !!Behavior methodsFor: 'as yet unclassified'!removeSelector: selector	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method."	| oldMethod |		oldMethod _ self methodDict at: selector ifAbsent: [^ self].	self methodDict removeKey: selector.	"Now flush Squeak's method cache, either by selector or by method"	oldMethod flushCache.	selector flushCache! !!Behavior methodsFor: 'as yet unclassified'!selectorsAndMethodsDo: aBlock	"Evaluate selectorBlock for all the message selectors in my method dictionary."	^ self methodDict keysAndValuesDo: aBlock! !!Behavior methodsFor: 'as yet unclassified'!setTraitComposition: aTraitComposition	| oldComposition |	(self hasTraitComposition not and: [aTraitComposition isEmpty]) ifTrue: [^self].	aTraitComposition assertValidUser: self.	oldComposition _ self traitComposition.	self traitComposition: aTraitComposition."	self applyChangesOfNewTraitCompositionReplacing: oldComposition."		oldComposition traits do: [:each | each removeUser: self].	aTraitComposition traits do: [:each | each addUser: self]! !!Behavior methodsFor: 'as yet unclassified'!traitCompositionString	^self hasTraitComposition		ifTrue: [self traitComposition asString]		ifFalse: ['{}']! !!Behavior methodsFor: 'as yet unclassified'!typeOfClass	"Answer a symbol uniquely describing the type of the receiver"	self isWeak ifTrue: [ ^ #weak ].	^ (format bitAnd: 3) caseOf: {		[ 0 ] -> [ #normal ].		[ 1 ] -> [ #variable ].		[ 2 ] -> [ #bytes ].		[ 3 ] -> [ #words ]	}! !!Behavior methodsFor: 'as yet unclassified'!whichSelectorsReferTo: literal	"Answer a set of selectors whose methods access the argument as a literal."	| who |	who _ IdentitySet new.	self selectorsAndMethodsDo: 		[:sel :method |		(method hasLiteral: literal)			ifTrue:				[((literal isVariableBinding) not					or: [method literals allButLast includes: literal])						ifTrue: [who add: sel]]].	^ who! !!BehaviorTest methodsFor: 'as yet unclassified'!testBehaviorSubclasses	"self run: #testBehaviorSubclasses"		| b b2 |"	b := Behavior new.	b superclass: OrderedCollection.	b methodDictionary: Dictionary new.	self shouldnt: [b subclasses ] raise: Error.	self shouldnt: [b withAllSubclasses] raise: Error.	self shouldnt: [b allSubclasses] raise: Error.	b2 := Behavior new.	b2 superclass: b.	b2 methodDictionary: Dictionary new.	self assert: (b subclasses includes: b2).	self assert: (b withAllSubclasses includes: b)."! !!BlockClosure methodsFor: 'as yet unclassified'!valueWithArguments: anArray 	"Evaluate the block with given args. Fail if the block expects other than the given number of arguments."	^ environment executeMethod: method withArgs: anArray ! !!ClassBrowser methodsFor: 'as yet unclassified'!buildClassCategoriesView	| model tree col cell |	tree := nil->nil.	SystemOrganization categories do: [ :each |		| category |		category := tree.		(each subStrings: '-') do: [ :cat |			category value ifNil: [ category value: Dictionary new].			category := category value associationAt: cat ifAbsent: [ category value at: cat put: nil. category value associationAt: cat ]		]	].	model := GtkTreeStore new: {String. String}.	[ self addSubcategoriesFrom: tree fromIter: nil inModel: model ] fork.	classCategoriesTree := GtkTreeView model: model.	col := GtkTreeViewColumn title: 'Class categories'.	cell := GtkCellRendererPixbuf new.	col		packStart: cell expand: false;		addAttribute: #stockId column: 1 on: cell.	cell := GtkCellRendererText new.	col		packStart: cell;		addAttribute: #text column: 0 on: cell.		classCategoriesTree appendColumn: col.	classCategoriesTree selection when: #changed send: #onClassCategoryChanged to: self.	classCategoriesTree enableTreeLines: true.	^ GtkScrolledWindow withChild: classCategoriesTree! !!ClassBrowser methodsFor: 'as yet unclassified'!loadClassMethodsOf: aClassClass	| iter |	classMethodsTree model clear.	aClassClass organization categories do: [ :cat |		iter := classMethodsTree model append: nil->{cat asString. true. 'grey'. 'gtk-info'}.		(aClassClass organization listAtCategoryNamed: cat) asSortedCollection do: [ :sel |			classMethodsTree model append: iter->{sel asString. false. 'grey'. 'gtk-execute'}		]	].	classMethodsTree expandAll.! !!ClassBrowser methodsFor: 'as yet unclassified'!loadInstanceMethodsOf: aClass	| iter |	instanceMethodsTree model clear.	aClass organization categories do: [ :cat |		iter := instanceMethodsTree model append: nil->{cat asString. true. 'grey'. 'gtk-info'}.		(aClass organization listAtCategoryNamed: cat) asSortedCollection do: [ :sel |			instanceMethodsTree model append: iter->{sel asString. false. 'grey'. 'gtk-execute'}		]	].	instanceMethodsTree expandAll.! !!ClassBrowser methodsFor: 'as yet unclassified'!onClassHierarchyChanged	| class iter path newIter aCategory classHierarchySelectedRow classesTreeSelectedRow |	classHierarchySelectedRow := classHierarchyTree selectedRow.	classHierarchySelectedRow ifNotNil: [		class := Smalltalk at: (classHierarchySelectedRow first asSymbol).							aCategory := class category.		( aCategory isNotNil and: [ aCategory ~= selectedClassCategory ] ) ifTrue: [			selectedClassCategory := aCategory.			iter := classCategoriesTree model firstIter.			newIter := nil.			(aCategory subStrings: '-') do: [ :cat |				newIter ifNotNil: [ iter := newIter ].				iter := self classCategoryFor: cat firstIter: iter.				newIter := classCategoriesTree model firstChildAt: iter.			].			path := classCategoriesTree model pathFromIter: iter.			classCategoriesTree expandRowsUpTo: path.			classCategoriesTree moveCursorAt: path.					classesTree model clear.			(SystemOrganization listAtCategoryNamed: aCategory) sort do: [ :ea |				classesTree model append: {ea asString. 'gtk-execute'}			]		].							self selectClass: class.	]! !!ClassBuilder methodsFor: 'as yet unclassified'!formatForType: type	^ type caseOf: {		[ #normal ] -> [ 0 ].		[ #variable ] -> [ 1 ].		[ #bytes ] -> [ 2 ].		[ #words ] -> [ 3 ].		[ #weak ] -> [ 5 "binary: 4 + 0 + 0 + 1" ]	} otherwise: [ self error: 'Unknown class type' ].! !!ClassBuilder methodsFor: 'as yet unclassified'!needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Answer whether we need a new subclass to conform to the requested changes"	"Check if we really need a new subclass"	oldClass ifNil:[^true]. "yes, it's a new class"	newSuper == oldClass superclass ifFalse:[^true]. "yes, it's a superclass change"	type = oldClass typeOfClass ifFalse:[^true]. "yes, it's a format change"	instVars = oldClass instVarNames ifFalse:[^true]. "yes, it's an iVar change"	^false! !!ClassBuilder methodsFor: 'as yet unclassified'!newSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Create a new subclass of the given superclass with the given specification."	| newClass |	(oldClass == nil or:[oldClass isMeta not]) 		ifTrue:[newClass := self privateNewSubclassOf: newSuper from: oldClass]		ifFalse:[newClass := oldClass clone].	newClass 		superclass: newSuper		methodDictionary: "Method"Dictionary new		instanceSize: (newSuper instSize + instVars size)		format: (self formatForType: type);		setInstVarNames: instVars.	oldClass ifNotNil:[		newClass organization: oldClass organization.		"Recompile the new class"		oldClass hasMethods 			ifTrue:[newClass compileAllFrom: oldClass].		oldClass hasTraitComposition ifTrue: [			newClass setTraitComposition: oldClass traitComposition copyTraitExpression ].		oldClass class hasTraitComposition ifTrue: [			newClass class setTraitComposition: oldClass class traitComposition copyTraitExpression ].				self recordClass: oldClass replacedBy: newClass.	].	(oldClass == nil or:[oldClass isObsolete not]) 		ifTrue:[newSuper addSubclass: newClass]		ifFalse:[newSuper addObsoleteSubclass: newClass].	^newClass! !!ClassBuilder methodsFor: 'as yet unclassified'!privateNewSubclassOf: newSuper from: oldClass	"Create a new meta and non-meta subclass of newSuper using oldClass as template"	"WARNING: This method does not preserve the superclass/subclass invariant!!"	| newSuperMeta oldMeta newMeta |	oldClass ifNil:[^self privateNewSubclassOf: newSuper].	newSuperMeta _ newSuper ifNil:[Class] ifNotNil:[newSuper class].	oldMeta _ oldClass class.	newMeta _ oldMeta clone.	newMeta 		superclass: newSuperMeta		methodDictionary: "Method"Dictionary new		instanceSize: oldMeta instSize		format: oldMeta format;		setInstVarNames: oldMeta instVarNames;		organization: oldMeta organization.	"Recompile the meta class"	oldMeta hasMethods 		ifTrue:[newMeta compileAllFrom: oldMeta].	"Record the meta class change"	self recordClass: oldMeta replacedBy: newMeta.	"And create a new instance"	^newMeta adoptInstance: oldClass from: oldMeta! !!ClassBuilder methodsFor: 'as yet unclassified'!reshapeClass: oldClass toSuper: newSuper	"Reshape the given class to the new super class. Recompile all the methods in the newly created class. Answer the new class."	| instVars |	instVars _ instVarMap at: oldClass name ifAbsent:[oldClass instVarNames].	^self newSubclassOf: newSuper 			type: oldClass typeOfClass 			instanceVariables: instVars 			from: oldClass! !!ClassDescription methodsFor: 'as yet unclassified'!classVersion	"Default.  Any class may return a later version to inform readers that use ReferenceStream.  8/17/96 tk"	"This method allows you to distinguish between class versions when the shape of the class 	hasn't changed (when there's no change in the instVar names).	In the conversion methods you usually can tell by the inst var names 	what old version you have. In a few cases, though, the same inst var 	names were kept but their interpretation changed (like in the layoutFrame).	By changing the class version when you keep the same instVars you can 	warn older and newer images that they have to convert."	^ 0! !!ClassDescription methodsFor: 'as yet unclassified'!obsolete	"Make the receiver obsolete."	superclass removeSubclass: self.	self organization: nil.	super obsolete.! !!ClassDescription methodsFor: 'as yet unclassified'!removeSelector: selector 	"Remove the message whose selector is given from the method 	dictionary of the receiver, if it is there. Answer nil otherwise."		| priorMethod priorProtocol | 	priorMethod _ self compiledMethodAt: selector ifAbsent: [^ nil].	priorProtocol _ self whichCategoryIncludesSelector: selector.	SystemChangeNotifier uniqueInstance		doSilently: [self organization removeElement: selector ].	super removeSelector: selector.	SystemChangeNotifier uniqueInstance 			methodRemoved: priorMethod selector: selector inProtocol: priorProtocol class: self.! !!ClassDescription methodsFor: 'as yet unclassified'!updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil	| currentCategory effectiveCategory sel changedCategories composition |	changedCategories _ IdentitySet new.	composition := self hasTraitComposition		ifTrue: [self traitComposition]		ifFalse: [TraitComposition new].	(composition methodDescriptionsForSelector: aSymbol) do: [:each |		sel _ each selector.		(self includesLocalSelector: sel) ifFalse: [			currentCategory _ self organization categoryOfElement: sel.			effectiveCategory _ each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.			effectiveCategory isNil ifTrue: [				currentCategory ifNotNil: [changedCategories add: currentCategory].				self organization removeElement: sel.			] ifFalse: [				((currentCategory isNil or: [currentCategory == ClassOrganizer ambiguous or: [currentCategory == oldCategoryOrNil]]) and: [currentCategory ~~ effectiveCategory]) ifTrue: [					currentCategory ifNotNil: [changedCategories add: currentCategory].					self organization 						classify: sel 						under: effectiveCategory						suppressIfDefault: false]]]].	^ changedCategories! !!ClassDescription methodsFor: 'as yet unclassified'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	(self includesSelector: aSelector)		ifTrue: [^ self organization categoryOfElement: aSelector]		ifFalse: [^nil]! !!Class methodsFor: 'as yet unclassified'!classPool: aDictionary	classPool _ aDictionary! !!Class methodsFor: 'as yet unclassified'!copy 	| newClass |	newClass _ self class copy new		superclass: superclass		methodDict: self methodDict copy		instanceSize: self instSize		format: format		name: name		organization: self organization copy		instVarNames: instanceVariables copy		classPool: classPool copy		sharedPools: sharedPools.	Class instSize+1 to: self class instSize do:		[:offset | newClass instVarAt: offset put: (self instVarAt: offset)].	^ newClass! !!Class methodsFor: 'as yet unclassified'!deactivate	"A remnant from the 3.3a modules work, retained . Does nothing, but may be overridden in Metaclasses."! !!Class methodsFor: 'as yet unclassified'!isSystemDefined	"Answer true if the receiver is a system-defined class, and not a UniClass (an instance-specific lightweight class)"	^ self == self officialClass! !!Class methodsFor: 'as yet unclassified'!obsolete	"Change the receiver and all of its subclasses to an obsolete class."	self == Object 		ifTrue: [^self error: 'Object is NOT obsolete'].	self setName: 'AnObsolete' , self name.	Object class instSize + 1 to: self class instSize do:		[:i | self instVarAt: i put: nil]. "Store nil over class instVars."	self classPool: nil.	self sharedPools: nil.	self class obsolete.	super obsolete.! !!Class methodsFor: 'as yet unclassified'!officialClass	"I am not a UniClass.  (See Player officialClass).  Return the class you use to make new subclasses."	^ self! !!Class methodsFor: 'as yet unclassified'!removeFromSystem	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."	self removeFromSystem: true.! !!Class methodsFor: 'as yet unclassified'!removeFromSystem: logged	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."		"keep the class name and category for triggering the system change message. If we wait to long, then we get obsolete information which is not what we want."	"tell class to deactivate and unload itself-- two separate events in the module system"	self deactivate; unload.	self superclass ifNotNil:		["If we have no superclass there's nothing to be remembered"		self superclass addObsoleteSubclass: self].	self environment forgetClass: self logged: logged.	self obsolete.! !!Class methodsFor: 'as yet unclassified'!sharedPools: aCollection	sharedPools _ aCollection! !!Class methodsFor: 'as yet unclassified'!superclass: sup methodDict: md instanceSize: is format: ft name: nm organization: org instVarNames: nilOrArray classPool: pool sharedPools: poolSet 	"Answer an instance of me, a new class, using the arguments of the 	message as the needed information.	Must only be sent to a new instance; else we would need Object flushCache."	superclass := sup.	methodDict := md.	instanceSize := is.	format := ft.	name := nm.	instanceVariables := nilOrArray.	classPool := pool.	sharedPools := poolSet.	self organization: org.! !!Class methodsFor: 'as yet unclassified'!unload	"Sent when a the class is removed.  Does nothing, but may be overridden by (class-side) subclasses."! !!Class methodsFor: 'as yet unclassified'!variableByteSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable byte-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableByteSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!variableSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable pointer variables."	^(ClassBuilder new)		superclass: self		variableSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!variableWordSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable word-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableWordSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!weakSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have weak indexable pointer variables."	^(ClassBuilder new)		superclass: self		weakSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!AppLauncher class methodsFor: 'as yet unclassified'!openAboutHuemul	| dlg logo |	logo := GdkPixbuf fromFile: 'Huemul.jpg'.	dlg := GtkAboutDialog new.	dlg		aboutDialogName: 'Huemul Smalltalk';		version: '0.8';		license: (StandardFileStream readOnlyFileNamed: 'LICENSE') upToEnd;		website: 'http://www.guillermomolina.com.ar/huemul';		comments: 'This is Huemul Smalltalk';		authors: {'Guillermo Adrian Molina'};		logo: logo.	dlg runAndDestroy! !!AppLauncher class methodsFor: 'as yet unclassified'!openWorkspace	^ Workspace open! !!Application class methodsFor: 'as yet unclassified'!startUp	^ self new startUp.! !!Application class methodsFor: 'as yet unclassified'!startUpWithArguments: arguments	| application |	application := self new.	application arguments: arguments.	^ application startUp.! !!Behavior class methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return false since zapping the method dictionary of Behavior class or its subclasses will cause the system to fail."	^false! !!ClassBrowser class methodsFor: 'as yet unclassified'!defaultSize	^ 640@480.! !!ClassBrowser class methodsFor: 'as yet unclassified'!title	^'Class browser'! !!ClassFinder class methodsFor: 'as yet unclassified'!defaultSize	^ 200@300.! !!ClassFinder class methodsFor: 'as yet unclassified'!title	^'Class finder'! !!CompiledMethod methodsFor: 'as yet unclassified'!hasLiteral: literal	"Answer whether the receiver references the argument, literal."	literals ifNil: [ ^false ].	^ literals hasLiteral: literal.! !!CompiledMethod methodsFor: 'as yet unclassified'!sourcePointer	"Answer the integer which can be used to find the source file and position for this method.	Not sources yet"	^ 0! !!CompiledMethodWithNode class methodsFor: 'as yet unclassified'!method: aCompiledMethod node: aMethodNode	^ self new method: aCompiledMethod; node: aMethodNode.! !!Compiler methodsFor: 'as yet unclassified'!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into a method. In other words, if receiver is not nil, then the text can refer to instance variables of that receiver (the Inspector uses this). If aContext is not nil, the text can refer to temporaries in that context (the Debugger uses this). If aRequestor is not nil, then it will receive a notify:at: message before the attempt to evaluate is aborted. Finally, the compiled method is directly invoked without modifying the receiving-class."	"| methodNode method value |	  	(Preferences compileUseNewCompiler or: 			[aContext ifNotNil: [aContext method isClosureCompiled] ifNil: [false]]) ifTrue: 				[^ self evaluate2: textOrStream 					    in: aContext 					    to: receiver 					    notifying: aRequestor 					    ifFail: failBlock 					    logged: logFlag].		class := (aContext isNil 		ifTrue: [ receiver ] 		ifFalse: [ aContext receiver ])			class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode := self 		translate: sourceStream		noPattern: true 		ifFail: [ ^ failBlock value ].	method := methodNode generate.	self interactive		ifTrue: [ method := method copyWithTempNames: methodNode tempNames ].	value := receiver		executeMethod: method 		withArgs: (context isNil			ifTrue: [ #() ]			ifFalse: [ Array with: aContext ]).	logFlag 		ifTrue: [ SystemChangeNotifier uniqueInstance evaluated: sourceStream contents context: aContext ].	^ value."	| string block |	string _ textOrStream readStream upToEnd.	block := self compileDoIt: string in: aContext to: receiver notifying: aRequestor ifFail: [^ failBlock value] log: logFlag.	^ block value! !!Exception methodsFor: 'as yet unclassified'!messageText	messageText ifNil: [ ^ self class name asString ].	^messageText! !!Exception methodsFor: 'as yet unclassified'!receiver	^ self signalerContext receiver! !!ExternalFunctionError methodsFor: 'as yet unclassified'!functionName	"Answer the function name that was beiing used."	^functionName! !!ExternalFunctionError methodsFor: 'as yet unclassified'!functionName: argument	"Specify the function name that was beiing used."	functionName := argument! !!ExternalFunctionError class methodsFor: 'as yet unclassified'!functionName: argument	^self new functionName: argument; yourself! !!ExternalObject methodsFor: 'as yet unclassified'!= anObject 	(anObject isKindOf: self class)		ifTrue: [^ anObject handle = self handle]		ifFalse: [^ false]! !!ExternalObject methodsFor: 'as yet unclassified'!beNull	^ handle beNull.! !!ExternalObject methodsFor: 'as yet unclassified'!finalize		self free.	self unregister.! !!ExternalObject methodsFor: 'as yet unclassified'!free	"Should override this"! !!ExternalObject methodsFor: 'as yet unclassified'!initialize	handle := self class defaultHandlerClass new.	self register.! !!ExternalObject methodsFor: 'as yet unclassified'!isNull	^ self handle isNull.! !!ExternalObject methodsFor: 'as yet unclassified'!register	Registry add: self.! !!ExternalObject methodsFor: 'as yet unclassified'!unregister		Registry remove: self ifAbsent:[  ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!addSymbol: anExternalSymbol	^ symbolCache at: anExternalSymbol name put: anExternalSymbol.! !!DynamicLibrary methodsFor: 'as yet unclassified'!bindSymbol: anExternalSymbol	^ self primitiveBindSymbol: anExternalSymbol.! !!DynamicLibrary methodsFor: 'as yet unclassified'!cDeclFunctionNamed: functionName	^ symbolCache at: functionName ifAbsent: [ self error: 'You must initialize the function before using it' ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!close		handle isNull ifFalse: [ 		self primitiveClose		handle beNull.	].! !!DynamicLibrary methodsFor: 'as yet unclassified'!initialize	super initialize.	symbolCache := Dictionary new.! !!DynamicLibrary methodsFor: 'as yet unclassified'!initializeCDeclFunctionNamed: functionName returnType: retType argTypes: argTypesArray	^ symbolCache at: functionName put: 			(CDeclFunction name: functionName library: self  returnType: retType argTypes: argTypesArray)! !!DynamicLibrary methodsFor: 'as yet unclassified'!initializeLibraryDataNamed: symbolName type: type	^ symbolCache at: symbolName put: (LibraryData name: symbolName library: self  type: type)! !!DynamicLibrary methodsFor: 'as yet unclassified'!libraryDataNamed: symbolName	^ symbolCache at: symbolName ifAbsent: [ self error: 'You must initialize the symbol before using it' ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!name	^name! !!DynamicLibrary methodsFor: 'as yet unclassified'!name: aName	name := aName.! !!DynamicLibrary methodsFor: 'as yet unclassified'!nativeFunctionNamed: functionName	^ symbolCache at: functionName ifAbsent: [ 		symbolCache at: functionName put: (NativeFunction name: functionName library: self)	].! !!DynamicLibrary methodsFor: 'as yet unclassified'!open		handle isNull ifTrue: [ self primitiveOpen ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveBindSymbol: anExternalSymbol	"Primitive. Find the given symbol in the library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 203>	^ anExternalSymbol throwNotKnownError.! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveClose	"Primitive. Close the given library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 202>! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveOpen	"Primitive. Open the given library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 198>	self primitiveFailed.! !!DynamicLibrary methodsFor: 'as yet unclassified'!printOn: aStream	aStream nextPutAll: self name.! !!DynamicLibrary methodsFor: 'as yet unclassified'!symbolNamed: symbolName	^ symbolCache at: symbolName ifAbsent: [ self error: 'You must initialize the symbol before using it' ]! !!Executable methodsFor: 'as yet unclassified'!name	^ Utilities executableName ! !!Executable methodsFor: 'as yet unclassified'!primitiveSmallIntegerAdd: receiver with: argument	^ (self nativeFunctionNamed: #primitiveSmallIntegerAdd) invokeReceiver: receiver with: argument.! !!ExternalBuffer methodsFor: 'as yet unclassified'!asByteArray	| array |	size ifNil: [ ^ self class throwTypeConvertionError ].	array := ByteArray new: self basicSize.	self storeInto: array.	^ array	! !!ExternalBuffer methodsFor: 'as yet unclassified'!atAllPut: constant	^ LibC6 default memSet: self constant: constant count: self size.! !!ExternalBuffer methodsFor: 'as yet unclassified'!atAllPutZero	^ self atAllPut: 0.! !!ExternalBuffer methodsFor: 'as yet unclassified'!basicSize	^ size.! !!ExternalBuffer methodsFor: 'as yet unclassified'!byteAt: index	<primitive: 190>	index isNumber		ifTrue: [self errorSubscriptBounds: index]		ifFalse: [self errorNonIntegerIndex].! !!ExternalBuffer methodsFor: 'as yet unclassified'!byteAt: index put: value	<primitive: 191>	index isNumber		ifTrue: [self errorSubscriptBounds: index]		ifFalse: [self errorNonIntegerIndex].! !!ExternalBuffer methodsFor: 'as yet unclassified'!free		handle isNull ifFalse: [ 		LibC6 default free: self.		self beNull.	]! !!ExternalBuffer methodsFor: 'as yet unclassified'!loadFrom: aByteArray	<primitive: 199>	self primitiveFailed.! !!ExternalBuffer methodsFor: 'as yet unclassified'!size	^ self basicSize.! !!ExternalBuffer methodsFor: 'as yet unclassified'!size: anInteger	size := anInteger.! !!ExternalBuffer methodsFor: 'as yet unclassified'!storeInto: aByteArray	<primitive: 218>	^ self class throwTypeConvertionError.! !!AsciiZ methodsFor: 'as yet unclassified'!asString	^ handle toString.! !!AsciiZ methodsFor: 'as yet unclassified'!asString2	| calcSize string |	size ifNil: [ ^ self class throwTypeConvertionError ].	calcSize := self strlen.	calcSize >= self size ifTrue: [ ^ self class throwTypeConvertionError ].	string := String new: calcSize.	self storeInto: string.	^ string! !!AsciiZ methodsFor: 'as yet unclassified'!loadFrom: aString		super loadFrom: aString.	self byteAt: (aString size + 1) put: 0.! !!AsciiZ methodsFor: 'as yet unclassified'!strlen	^ LibC6 default strLen: self.! !!ExternalFunction methodsFor: 'as yet unclassified'!library	^ library! !!ExternalFunction methodsFor: 'as yet unclassified'!library: aLibrary	library := aLibrary! !!ExternalFunction methodsFor: 'as yet unclassified'!name	^name! !!ExternalFunction methodsFor: 'as yet unclassified'!name: aName	name := aName! !!ExternalFunction methodsFor: 'as yet unclassified'!name: aName library: aLibrary	self name: aName.	self library: aLibrary! !!ExternalFunction methodsFor: 'as yet unclassified'!reload	library ifNil: [ ^ self throwNotKnownError ].	self handle: (library findFunction: self)! !!ExternalLibrary methodsFor: 'as yet unclassified'!bindFunction: function	| answer |	answer := self primitiveBindFunction: function.	answer ifNotNil: [ ^ answer ].	self open. "Library may be closed, open it and retry"	answer := self primitiveBindFunction: answer.	answer ifNotNil: [ ^ answer ].	^ function throwNotKnownError.		! !!ExternalLibrary methodsFor: 'as yet unclassified'!closeLibrary		(handle isNotNil and: [ handle isNull not ]) ifTrue: [ self primitiveClose ].	self handle: nil.	functionCache := nil.! !!ExternalLibrary methodsFor: 'as yet unclassified'!openLibrary		self primitiveOpen.	self initializeFunctionCache.! !!ExternalLibrary methodsFor: 'as yet unclassified'!primitiveBindFunction: function	"Primitive. Find the given symbol in the library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 203>	^ nil.! !!ExternalObject class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: self! !!ExternalObject class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalAddress! !!ExternalObject class methodsFor: 'as yet unclassified'!handleFromObject: anObject	^ self handleFromObject: anObject ifError: [ self throwTypeConvertionError ]! !!ExternalObject class methodsFor: 'as yet unclassified'!handleFromObject: anObject ifError: aBlock		(anObject isKindOf: ExternalObject) ifFalse: [ ^ aBlock value ].	^ anObject handle.	! !!ExternalObject class methodsFor: 'as yet unclassified'!initialize	Registry := WeakRegistry new.	Smalltalk addToShutDownList: self.! !!ExternalObject class methodsFor: 'as yet unclassified'!objectFromHandle: handle	^self objectFromHandle: handle ifError: [ self throwTypeConvertionError ]! !!ExternalObject class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; yourself! !!ExternalObject class methodsFor: 'as yet unclassified'!quit	Registry do: [ :each | each free ].	self allSubclassesDo: [ :ea | ea quit ]! !!ExternalObject class methodsFor: 'as yet unclassified'!shutDown: quitting	quitting ifTrue: [ self quit ].! !!ExternalObject class methodsFor: 'as yet unclassified'!throwTypeConvertionError	^ TypeConvertionError new signal! !!DynamicLibrary class methodsFor: 'as yet unclassified'!default	self = DynamicLibrary ifTrue: [ self error: 'Create a class to create its singleton' ].	default ifNil: [	"Represents the executable itself"		default := self new.		default name: self moduleName.		default open.	].	^ default.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!initialize	self = DynamicLibrary ifFalse: [ 		Smalltalk addToShutDownList: self	].! !!DynamicLibrary class methodsFor: 'as yet unclassified'!moduleName	self subClassResponsibility.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!resetLibrary	default := nil.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!shutDown: aBool	default ifNotNil: [ default close ].! !!Executable class methodsFor: 'as yet unclassified'!huemul	^ self default! !!Executable class methodsFor: 'as yet unclassified'!moduleName	^nil.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: ByteArray! !!ExternalBuffer class methodsFor: 'as yet unclassified'!fromByteArray: aByteArray	| anExternalBuffer |		anExternalBuffer := ExternalBuffer new: aByteArray size.	anExternalBuffer setFrom: aByteArray.	^ anExternalBuffer.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!handleFromObject: aByteArray ifError: aBlock		(aByteArray isKindOf: ByteArray) ifFalse: [ 		^ super handleFromObject: aByteArray ifError: aBlock	].	^ ( self fromByteArray: aByteArray ) handle.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!new: size	| anExternalBuffer |	"This space is allocated from the system not 	from Object Memory, you will have to give it back, 	as it is not garbage collected"	anExternalBuffer := LibC6 default malloc: (size +  10).	anExternalBuffer size: size.	^ anExternalBuffer! !!AsciiZ class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: String! !!AsciiZ class methodsFor: 'as yet unclassified'!fromString: aString	| anAsciiZ |		anAsciiZ := AsciiZ new: aString size + 1.	anAsciiZ loadFrom: aString.	^ anAsciiZ.! !!AsciiZ class methodsFor: 'as yet unclassified'!handleFromObject: aString ifError: aBlock		(aString isKindOf: String) ifFalse: [ 		^ super handleFromObject: aString ifError: aBlock	].	^ ( self fromString: aString ) handle.! !!AsciiZ class methodsFor: 'as yet unclassified'!new: size	| buffer asciiZ |	buffer := super new: size.	asciiZ := AsciiZ new handle: buffer handle.	asciiZ size: size.	asciiZ atAllPutZero.	buffer handle: ExternalAddress nullPointer.	^ asciiZ! !!AsciiZ class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; asString! !!ExternalFunction class methodsFor: 'as yet unclassified'!name: aName library: aLibrary	^self new name: aName library: aLibrary! !!ExternalLibrary class methodsFor: 'as yet unclassified'!huemul	Huemul ifNil: [	"Represents the executable itself"		Huemul := self new.		Huemul open.	].	^ Huemul.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!handle	self object ifNil: [ handle beNull ].	^ handle.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!initialize	super initialize.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!initializePointer	self handle forObject: self object.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!object	^ self objectPointer at: 1! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!object: anObject	self objectPointer at: 1 put: anObject.	self initializePointer.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!objectPointer	object ifNil: [ object := WeakArray new: 1 ].	^ object! !!ExternalArrayProxy methodsFor: 'as yet unclassified'!initializePointer	self handle forArray: self object.! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!fromObject: anObject		^ self new object: anObject; yourself! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!handleFromObject: anObject ifError: aBlock		^ ( self fromObject: anObject ) handle.! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		^ aBlock value! !!ExternalSymbol methodsFor: 'as yet unclassified'!address	handle isNull ifTrue: [ self bind ].	^ handle.! !!ExternalSymbol methodsFor: 'as yet unclassified'!bind	^ library bindSymbol: self.! !!ExternalSymbol methodsFor: 'as yet unclassified'!classFromType: aType	^ Smalltalk at: aType ifAbsent: [ self throwExternalSymbolError ].! !!ExternalSymbol methodsFor: 'as yet unclassified'!library	^ library! !!ExternalSymbol methodsFor: 'as yet unclassified'!library: aLibrary	library := aLibrary! !!ExternalSymbol methodsFor: 'as yet unclassified'!libraryName	^ library name.! !!ExternalSymbol methodsFor: 'as yet unclassified'!name	^name! !!ExternalSymbol methodsFor: 'as yet unclassified'!name: aName	name := aName! !!ExternalSymbol methodsFor: 'as yet unclassified'!name: aName library: aLibrary	self name: aName.	self library: aLibrary! !!ExternalSymbol methodsFor: 'as yet unclassified'!throwExternalSymbolError	^(ExternalSymbolError symbolName: name) signal.! !!ExternalSymbol methodsFor: 'as yet unclassified'!throwNotKnownError	^(ExternalSymbolError symbolName: name) signal.! !!ExecutableFunction methodsFor: 'as yet unclassified'!callingConventionString	self subclassResponsibility.! !!CDeclFunction methodsFor: 'as yet unclassified'!argTypes: anArrayOfTypes	argTypes := anArrayOfTypes.! !!CDeclFunction methodsFor: 'as yet unclassified'!callingConventionString	^ 'cdecl'! !!CDeclFunction methodsFor: 'as yet unclassified'!invoke	^self invokeWithArguments: #()! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1	^self invokeWithArguments: (Array with: arg1)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2	^self invokeWithArguments: (Array with: arg1 with: arg2)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4 with: arg5	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWithArguments: argArray	| argSize argHandleArray returnClass returnHandle |	argSize := argArray size.	argSize = argTypes size ifFalse: [ self throwExternalFunctionError ].	argHandleArray := Array new: argSize.	1 to: argSize do: [ :i |		| argType argClass argHandle arg |		argType := argTypes at: i.		argClass := self classFromType: argType.		arg := argArray at: i.		argHandle := argClass handleFromObject: arg.		argHandleArray at: i put: argHandle.	].	returnHandle := nil.	returnType = #Void ifFalse: [		returnClass := self classFromType: returnType.		returnHandle := returnClass defaultHandlerClass new.	].	handle isNull ifTrue: [ self bind ].	self primInvokeAnswering: returnHandle withArguments: argHandleArray.	returnType = #Void ifTrue: [ ^ nil ].	^ returnClass objectFromHandle: returnHandle.! !!CDeclFunction methodsFor: 'as yet unclassified'!primInvokeAnswering: aReturnValue withArguments: argArray	"Manually invoke the receiver, representing an external function."	<primitive: 204>	^self primitiveFailed! !!CDeclFunction methodsFor: 'as yet unclassified'!returnType: aType	returnType := aType.! !!CDeclFunction methodsFor: 'as yet unclassified'!returnType: aType argTypes: anArrayOfTypes	self returnType: aType.	self argTypes: anArrayOfTypes.! !!ExternalSymbol class methodsFor: 'as yet unclassified'!name: aName library: aLibrary	^self new name: aName library: aLibrary; bind! !!CDeclFunction class methodsFor: 'as yet unclassified'!name: aName library: aLibrary returnType: retType argTypes: argTypesArray	^self new name: aName library: aLibrary;		 returnType: retType argTypes: argTypesArray;		bind! !!ExternalSymbolError methodsFor: 'as yet unclassified'!isResumable	"Determine whether an exception is resumable."	^true! !!ExternalSymbolError methodsFor: 'as yet unclassified'!symbolName	^ symbolName! !!ExternalSymbolError methodsFor: 'as yet unclassified'!symbolName: argument	"Specify the function name that was beiing used."	symbolName := argument! !!ExternalSymbolError class methodsFor: 'as yet unclassified'!symbolName: argument	^self new symbolName: argument; yourself! !!FileDescriptor methodsFor: 'as yet unclassified'!close		self fileDescriptor > 2 ifTrue: [ 		LibC6 default close: self.		self fileDescriptor: -1.	]! !!FileDescriptor methodsFor: 'as yet unclassified'!fileDescriptor	^ SignedInteger objectFromHandle: handle. ! !!FileDescriptor methodsFor: 'as yet unclassified'!fileDescriptor: anInteger	handle := SignedInteger handleFromObject: anInteger. ! !!FileDescriptor methodsFor: 'as yet unclassified'!free		self close.! !!FileDescriptor methodsFor: 'as yet unclassified'!movePosition: offset"relative to actual position"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_CUR' ).	! !!FileDescriptor methodsFor: 'as yet unclassified'!position	^ self movePosition: 0.	! !!FileDescriptor methodsFor: 'as yet unclassified'!position: offset"absolute position"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_SET' ).! !!FileDescriptor methodsFor: 'as yet unclassified'!positionFromEnd: offset"relative to end of file"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_END' ).	! !!FileDescriptor methodsFor: 'as yet unclassified'!read: size	| retValue buffer |	buffer := ExternalBuffer new: size.	retValue := self readBuffer: buffer size: size.	! !!FileDescriptor methodsFor: 'as yet unclassified'!readBuffer: buffer size: size	^ LibC6 default read: self buffer: buffer size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!readString: aString	^ LibC6 default read: self string: aString size: aString size! !!FileDescriptor methodsFor: 'as yet unclassified'!readString: aString size: size	| internalSize |	internalSize := size.	aString size < size ifTrue: [ internalSize := aString size ].	^ LibC6 default read: self string: aString size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!size	| position size |	position := self position.	size := self positionFromEnd: 0.	self position: position.	^ size	! !!FileDescriptor methodsFor: 'as yet unclassified'!writeBuffer: buffer size: size	^ LibC6 default write: self buffer: buffer size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!writeString: aString	^ LibC6 default write: self string: aString size: aString size! !!FileDescriptor methodsFor: 'as yet unclassified'!writeString: aString size: size	| internalSize |	internalSize := size.	aString size < size ifTrue: [ internalSize := aString size ].	^ LibC6 default write: self string: aString size: size! !!FileDescriptor class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalValue! !!FileDescriptor class methodsFor: 'as yet unclassified'!initialize	self initializeStandardDescriptors! !!FileDescriptor class methodsFor: 'as yet unclassified'!initializeStandardDescriptors	StandardDescriptors := Dictionary new.	StandardDescriptors at: #stdout put: (self newFileDescriptor: 0).	StandardDescriptors at: #stdin put: (self newFileDescriptor: 1).	StandardDescriptors at: #stderr put: (self newFileDescriptor: 2).! !!FileDescriptor class methodsFor: 'as yet unclassified'!newFileDescriptor: anInteger	^ self new fileDescriptor: anInteger; yourself.! !!FileDescriptor class methodsFor: 'as yet unclassified'!standardDescriptors	^ StandardDescriptors! !!FileDescriptor class methodsFor: 'as yet unclassified'!stderr	^ StandardDescriptors at: #stderr.! !!FileDescriptor class methodsFor: 'as yet unclassified'!stdin	^ StandardDescriptors at: #stdin.! !!FileDescriptor class methodsFor: 'as yet unclassified'!stdout	^ StandardDescriptors at: #stdout.! !!FileStream methodsFor: 'as yet unclassified'!atEnd	"Answer true if the current position is >= the end of file position.	 1/31/96 sw: subclassResponsibility"	self subclassResponsibility! !!FileStream class methodsFor: 'as yet unclassified'!fileDoesNotExistUserHandling: fullFileName	(GtkMessageDialog question: fullFileName, ' does not exist, create it?') = #yes		ifTrue: [ ^ self new open: fullFileName forWrite: true ].! !!FileStream class methodsFor: 'as yet unclassified'!fileExistsUserHandling: fullFileName	(GtkMessageDialog question: fullFileName, ' exist, overwrite it?') = #yes		ifTrue: [ ^ self new openForOverwrite: fullFileName ].! !!FileStream class methodsFor: 'as yet unclassified'!readOnlyFileDoesNotExistUserHandling: fullFileName	GtkMessageDialog error: fullFileName, ' does not exist'! !!FileDoesNotExistException methodsFor: 'as yet unclassified'!defaultAction	"The default action taken if the exception is signaled."	^self readOnly		ifTrue: [FileStream readOnlyFileDoesNotExistUserHandling: self fileName]		ifFalse: [FileStream fileDoesNotExistUserHandling: self fileName]! !!GIRBuilder methodsFor: 'as yet unclassified'!compiledMethod	| bytecodes |	bytecodes := self bytecodes.	bytecodes ifNil: [ ^ nil ].	^ CompiledMethod new		primitive: 0;		numArgs: self numArgs;		numTemps: self numTemps;		literals: self literals;		relocationInfo: self relocationInfo;		bytecodes: bytecodes;		debugInfo: debugInfo;		source: source;		relocate.! !!GPointer methodsFor: 'as yet unclassified'!initialize	handle := self class defaultHandlerClass new.! !!GPointer class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalAddress! !!GPointer class methodsFor: 'as yet unclassified'!handle: aByteArray	^self basicNew handle: aByteArray; yourself! !!GObject class methodsFor: 'as yet unclassified'!handleFromObject: object	^ object handle.	! !!Gtk methodsFor: 'as yet unclassified'!initialize	self initializeGtkLibrary.	self startMainLoop.! !!Gtk class methodsFor: 'as yet unclassified'!shutDown: quiting	"Quits the Gtk main loop"	Default ifNotNil: [		Default quitMainLoop.		Default close.		Default := nil.	].! !!GtkDemoStockIds methodsFor: 'as yet unclassified'!initialize	| model tree |	model := GtkListStore new: {String. String. String. String}.	GtkStockItem allStocks do: [ :ea |		ea ifNotNil: [			model append: {				ea stockId asGtkStockId.				ea stockId.				ea label.				Gtk acceleratorName: ea keyval asCharacter modifier: ea modifier}]].	tree := GtkTreeView model: model.	self createFirstColumn: tree.	tree appendColumns: {		GtkTreeViewColumn title: 'Label' text: 2.		GtkTreeViewColumn title: 'Accel' text: 3.		GtkTreeViewColumn title: 'ID' text: 0}.	tree selection when: #changed send: #onItemChanged: to: self withArgumentsFirst: {tree}.			self container: (GtkHBox spacing: 5).	self container		packStart: (GtkScrolledWindow withChild: tree);		packEnd: self createInfoFrame expand: false fill: false! !!GtkDemoStockIds methodsFor: 'as yet unclassified'!onItemChanged: aTreeView	aTreeView selectedRow in: [:row |		idLabel label: row first.		nameLabel label: '#', row second.		accelLabel label: row third.		iconImage stock: row second iconSize: #dialog]! !!InMidstOfFileinNotification methodsFor: 'as yet unclassified'!defaultAction	^ self resume: false! !!LibC methodsFor: 'as yet unclassified'!closeLibrary	cLibrary closeLibrary.	cLibrary := nil.! !!LibC methodsFor: 'as yet unclassified'!initializeCLibrary	cLibrary := ExternalLibrary new.	cLibrary name: 'libc.so.6'.	cLibrary openLibrary.! !!LibC class methodsFor: 'as yet unclassified'!shutDown: quiting	"Quits the Gtk main loop"	self default closeLibrary.	Default := nil.! !!LibC6 methodsFor: 'as yet unclassified'!close: fd	| retValue |	retValue := ( self cDeclFunctionNamed: #close ) invokeWith: fd.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #close ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!errno	^ (self libraryDataNamed: #errno) value.	! !!LibC6 methodsFor: 'as yet unclassified'!errno: errno	(self libraryDataNamed: #errno) value: errno.	! !!LibC6 methodsFor: 'as yet unclassified'!free: anExternalBuffer	( self cDeclFunctionNamed: #free ) invokeWith: anExternalBuffer.	! !!LibC6 methodsFor: 'as yet unclassified'!getCurrentDirName	| retValue |	[ retValue := ( self cDeclFunctionNamed: 'get_current_dir_name' asSymbol ) invoke ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: 'get_current_dir_name' asSymbol ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!getEnv: envVariable	^ ( self cDeclFunctionNamed: #getenv ) invokeWith: envVariable.! !!LibC6 methodsFor: 'as yet unclassified'!getpid	^ (self cDeclFunctionNamed: #getpid) invoke.	! !!LibC6 methodsFor: 'as yet unclassified'!initialize	super initialize.	self initializeUniStd.	self initializeStdLib.	self initializeString.	self initializeFCntl.	self initializeStdIO.	self initializeErrNO.! !!LibC6 methodsFor: 'as yet unclassified'!initializeErrNO	self initializeLibraryDataNamed: #errno type: #SignedInteger.! !!LibC6 methodsFor: 'as yet unclassified'!initializeFCntl	self initializeCDeclFunctionNamed: #open returnType: #FileDescriptor argTypes: #( AsciiZ SignedInteger UnsignedInteger ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeStdIO	self initializeCDeclFunctionNamed: #printf  returnType: #SignedInteger argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: #perror  returnType: #Void argTypes: #( AsciiZ  ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeStdLib	self initializeCDeclFunctionNamed: #malloc  returnType: #ExternalBuffer argTypes: #( UnsignedInteger  ).	self initializeCDeclFunctionNamed: #free  returnType: #Void argTypes: #( ExternalBuffer  ).	self initializeCDeclFunctionNamed: #getenv  returnType: #AsciiZ argTypes: #( AsciiZ ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeString	self initializeCDeclFunctionNamed: #strlen returnType: #UnsignedInteger argTypes: #( AsciiZ ).	self initializeCDeclFunctionNamed: #strcat returnType: #AsciiZ argTypes: #( AsciiZ AsciiZ ).	self initializeCDeclFunctionNamed: #strcpy returnType: #AsciiZ argTypes: #( AsciiZ AsciiZ ).	self initializeCDeclFunctionNamed: #strerror returnType: #ReadOnlyAsciiZ argTypes: #( SignedInteger ).	self initializeCDeclFunctionNamed: #memset returnType: #ExternalBuffer argTypes: #( ExternalBuffer SignedInteger  UnsignedInteger ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeUniStd	self initializeCDeclFunctionNamed: #getpid  returnType: #UnsignedInteger argTypes: #().	self initializeCDeclFunctionNamed: 'get_current_dir_name' asSymbol  returnType: #AsciiZ argTypes: #().	self initializeCDeclFunctionNamed: #close  returnType: #SignedInteger argTypes: #( FileDescriptor ).	self initializeCDeclFunctionNamed: #lseek  returnType: #UnsignedInteger argTypes: #( FileDescriptor UnsignedInteger SignedInteger ).	self initializeCDeclFunctionNamed: #read  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalBuffer UnsignedInteger ).	self initializeCDeclFunctionNamed: #write  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalBuffer UnsignedInteger )."Redefinition of read for Strings"	symbolCache at: #readString put: (CDeclFunction name: #read library: self  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalArrayProxy UnsignedInteger ) )."Redefinition of write for Strings"	symbolCache at: #writeString put: (CDeclFunction name: #write library: self  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalArrayProxy UnsignedInteger ) ).! !!LibC6 methodsFor: 'as yet unclassified'!lseek: fileDescriptor offset: offset whence: whence	| returnValue |	returnValue := (self cDeclFunctionNamed: #lseek) invokeWith: fileDescriptor with: offset with: whence.	returnValue < 0 ifTrue: [		self throwErrorForExternalFunctionNamed: #lseek.		^ nil.	].	^ returnValue.	! !!LibC6 methodsFor: 'as yet unclassified'!malloc: size	| retValue |	[ retValue := ( self cDeclFunctionNamed: #malloc ) invokeWith: size ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: #malloc withMessage: 'can not allocate memory' ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!memSet: buffer constant: c count: n	^ (self cDeclFunctionNamed: #memset) invokeWith: buffer with: c with: n.	! !!LibC6 methodsFor: 'as yet unclassified'!open: path flags: flags	^ self open: path flags: flags mode: 8r644	! !!LibC6 methodsFor: 'as yet unclassified'!open: path flags: flags mode: mode	| fileDescriptor |	fileDescriptor := (self cDeclFunctionNamed: #open) invokeWith: path with: flags with: mode.	fileDescriptor fileDescriptor < 0 ifTrue: [		self throwErrorForExternalFunctionNamed: #open.		^ nil.	].	^ fileDescriptor.	! !!LibC6 methodsFor: 'as yet unclassified'!perror: aString	( self cDeclFunctionNamed: #perror ) invokeWith: aString.	! !!LibC6 methodsFor: 'as yet unclassified'!printf: aString	^ ( self cDeclFunctionNamed: #printf ) invokeWith: aString.	! !!LibC6 methodsFor: 'as yet unclassified'!read: fd buffer: buffer size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #read ) invokeWith: fd with: buffer with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #read ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!read: fd string: aString size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #readString ) invokeWith: fd with: aString with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #readString ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!strCat: destString with: sourceString	^ ( self cDeclFunctionNamed: #strcat ) invokeWith: destString with: sourceString.	! !!LibC6 methodsFor: 'as yet unclassified'!strCpy: destString with: sourceString	^ ( self cDeclFunctionNamed: #strcpy ) invokeWith: destString with: sourceString.	! !!LibC6 methodsFor: 'as yet unclassified'!strError: errno	| retValue |	[ retValue := ( self cDeclFunctionNamed: #strerror ) invokeWith: errno ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: #strerror ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!strLen: string	^ ( self cDeclFunctionNamed: #strlen ) invokeWith: string	! !!LibC6 methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName	^ self throwErrorForExternalFunctionNamed: functionName withMessage: (self strError: self errno).	! !!LibC6 methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName withMessage: aString	| error |	error := ExternalFunctionError functionName: functionName.	error messageText: aString.	^ error signal.	! !!LibC6 methodsFor: 'as yet unclassified'!valueForLSeekDirectiveNamed: aString	^ LSeekDirectives at: aString asSymbol.	! !!LibC6 methodsFor: 'as yet unclassified'!valueForOpenFlagNamed: aString	^ OpenFlags at: aString asSymbol.	! !!LibC6 methodsFor: 'as yet unclassified'!write: fd buffer: buffer size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #write ) invokeWith: fd with: buffer with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #write ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!write: fd string: aString size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #writeString ) invokeWith: fd with: aString with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #writeString ].	^ retValue.	! !!LibC6 class methodsFor: 'as yet unclassified'!initialize	self initializeOpenFlags.	self initializeLSeekDirectives.! !!LibC6 class methodsFor: 'as yet unclassified'!initializeLSeekDirectives	| lSeekDirectives |		lSeekDirectives := Dictionary new.	lSeekDirectives at: 'SEEK_SET' put: 0.	lSeekDirectives at: 'SEEK_CUR' put: 1.	lSeekDirectives at: 'SEEK_END' put: 2.	LSeekDirectives := lSeekDirectives! !!LibC6 class methodsFor: 'as yet unclassified'!initializeOpenFlags	| flagArray openFlags |		flagArray := #( 		('O_RDONLY'		0)		('O_WRONLY'		8r1)		('O_RDWR'		8r2)		('O_CREAT'		8r100)			('O_EXCL'			8r200)			('O_NOCTTY'		8r400)			('O_TRUNC'		8r1000)			('O_APPEND'		8r2000)		('O_NONBLOCK'	8r4000)		('O_SYNC'		8r10000)		('O_ASYNC'		8r20000)	).	openFlags := Dictionary new.	flagArray do: [ :i |		openFlags at: i first asSymbol put: i second	].	OpenFlags := openFlags! !!LibC6 class methodsFor: 'as yet unclassified'!moduleName	^ 'libc.so.6'.! !!LibExample methodsFor: 'as yet unclassified'!getpid	^ GETPID invoke! !!LibExample class methodsFor: 'as yet unclassified'!getpid	^ GETPID! !!LibExample class methodsFor: 'as yet unclassified'!initialize	GETPID := CDeclFunction name: 'getpid' libraryNamed: 'libc.so.6' returnType: #UnsignedInteger argTypes: #().! !!LibReadLine methodsFor: 'as yet unclassified'!addHistory: aString	( self cDeclFunctionNamed: 'add_history' asSymbol ) invokeWith: aString.! !!LibReadLine methodsFor: 'as yet unclassified'!initialize	super initialize.	self initializeCDeclFunctionNamed: #readline  returnType: #AsciiZ argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'add_history' asSymbol returnType: #Void argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'read_history' asSymbol returnType: #SignedInteger argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'write_history' asSymbol returnType: #SignedInteger argTypes: #( AsciiZ  ).! !!LibReadLine methodsFor: 'as yet unclassified'!readHistory: aFileName	| errno |	errno := ( self cDeclFunctionNamed: 'read_history' asSymbol ) invokeWith: aFileName.	errno = 0 ifFalse: [ self throwErrorForExternalFunctionNamed: 'read_history' asSymbol errno: errno ].	^ errno.! !!LibReadLine methodsFor: 'as yet unclassified'!readline: prompt	^ ( self cDeclFunctionNamed: #readline ) invokeWith: prompt.! !!LibReadLine methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName errno: errno	| error |	error := ExternalFunctionError functionName: functionName.	error messageText: (LibC6 default strError: errno).	^ error signal.! !!LibReadLine methodsFor: 'as yet unclassified'!writeHistory: aFileName	| errno |	errno := ( self cDeclFunctionNamed: 'write_history' asSymbol ) invokeWith: aFileName.	errno = 0 ifFalse: [ self throwErrorForExternalFunctionNamed: 'write_history' asSymbol errno: errno ].	^ errno.! !!LibReadLine class methodsFor: 'as yet unclassified'!moduleName	^ 'libreadline.so.5'.! !!LibraryData methodsFor: 'as yet unclassified'!primitiveGetValue: valueHandle	<primitive: 216>	^self primitiveFailed! !!LibraryData methodsFor: 'as yet unclassified'!primitiveSetValue: valueHandle	<primitive: 217>	^self primitiveFailed! !!LibraryData methodsFor: 'as yet unclassified'!type	^ type.! !!LibraryData methodsFor: 'as yet unclassified'!type: aType	type := aType.! !!LibraryData methodsFor: 'as yet unclassified'!value	| valueClass valueHandle |	valueClass := self classFromType: type.	valueHandle := valueClass defaultHandlerClass new.	handle isNull ifTrue: [ self bind ].	self primitiveGetValue: valueHandle.	^ valueClass objectFromHandle: valueHandle.! !!LibraryData methodsFor: 'as yet unclassified'!value: aValue	| argHandle argClass |	argClass := self classFromType: type.	argHandle := argClass handleFromObject: aValue.	handle isNull ifTrue: [ self bind ].	self primitiveSetValue: argHandle! !!LibraryData class methodsFor: 'as yet unclassified'!name: aName library: aLibrary type: type	^self new name: aName library: aLibrary;		type: type;		bind! !!Metaclass methodsFor: 'as yet unclassified'!addObsoleteSubclass: aClass	"Do nothing."! !!Metaclass methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return true if it is safe to zap the method dictionary on #obsolete"	thisClass == nil		ifTrue:[^true]		ifFalse:[^thisClass canZapMethodDictionary]! !!Metaclass methodsFor: 'as yet unclassified'!isSystemDefined	"Answer false if I am a UniClass (an instance-specific lightweight class)"	^ true! !!NativeFunction methodsFor: 'as yet unclassified'!callingConventionString	^ 'native'! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver	^self invokeReceiver: receiver withArguments: #()! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1	^self invokeReceiver: receiver withArguments: (Array with: arg1)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4 with: arg5	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver withArguments: argArray	handle isNull ifTrue: [ self bind ].	^ self primInvokeReceiver: receiver withArguments: argArray.! !!NativeFunction methodsFor: 'as yet unclassified'!primInvokeReceiver: receiver withArguments: argArray	"Manually invoke the receiver, representing an native function."	<primitive: 197>	^self primitiveFailed! !!ObjectTest methodsFor: 'as yet unclassified'!testBecome	"self debug: #testBecome"	"this test should that all the variables pointing to an object are pointing now to another one, and all      object pointing to the other are pointing to the object"	| pt1 pt2 pt3 |	pt1 := 0@0.	pt2 := pt1.	pt3 := 100@100.	pt1 become: pt3.	self assert: pt2 = (100@100).	self assert: pt3 = (0@0).	self assert: pt1 = (100@100).! !!ObjectTest methodsFor: 'as yet unclassified'!testBecomeForward	"self debug: #testBecomeForward"	"this test should that all the variables pointing to an object are pointing now to another one.	Not that this inverse is not true. This kind of become is called oneWayBecome in VW"	| pt1 pt2 pt3 |	pt1 := 0@0.	pt2 := pt1.	pt3 := 100@100.	pt1 becomeForward: pt3.	self assert: pt2 = (100@100).	self assert: pt3 == pt2.	self assert: pt1 = (100@100)! !!PrimitiveType class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalValue! !!PrimitiveType class methodsFor: 'as yet unclassified'!handleFromObject: anObject	^ self handleFromObject: anObject ifError: [ self throwTypeConvertionError ]! !!PrimitiveType class methodsFor: 'as yet unclassified'!handleFromObject: object ifError: aBlock	self subclassResponsibility.! !!PrimitiveType class methodsFor: 'as yet unclassified'!objectFromHandle: handle	^ self objectFromHandle: handle ifError: [  self throwTypeConvertionError ]! !!PrimitiveType class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock	self subclassResponsibility.! !!PrimitiveType class methodsFor: 'as yet unclassified'!throwTypeConvertionError	^ TypeConvertionError new signal! !!IntegerType class methodsFor: 'as yet unclassified'!handleFromObject: anInteger ifError: aBlock	| handle |		(self checkType: anInteger) ifFalse: [ ^ aBlock value ].	handle := ExternalValue new.	self store: anInteger in: handle.	^ handle.	! !!IntegerType class methodsFor: 'as yet unclassified'!isBigEndian	^  false! !!IntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	self subclassResponsibility.! !!IntegerType class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: errorBlock	| value |		value := self loadFrom: handle.	(value > self max ) ifTrue: [ ^ errorBlock value ].	^ value.! !!Process methodsFor: 'as yet unclassified'!primitiveBeInitialProcess	<primitive: 196>	self primitiveFailed! !!ProcessorScheduler methodsFor: 'as yet unclassified'!activeProcess	^ self primActiveProcess! !!ProcessorScheduler methodsFor: 'as yet unclassified'!primActiveProcess	<primitive: 195>	self primitiveFail.! !!ProcessorScheduler methodsFor: 'as yet unclassified'!startUp	| firstProcess |"	(processList isNil or: [ processList isEmpty not ]) ifTrue: [ self initialize ]."	self initialize.	firstProcess := Process new.	firstProcess name: 'Init'.	firstProcess priority: self userSchedulingPriority.	firstProcess state: #running."	firstProcess threadData: self activeThreadData."	firstProcess primitiveBeInitialProcess.! !!ReadOnlyAsciiZ methodsFor: 'as yet unclassified'!asString	^ handle toString.! !!ReadOnlyAsciiZ class methodsFor: 'as yet unclassified'!handleFromObject: aByteArray ifError: aBlock	"Can not be used as arguments"	aBlock value.! !!ReadOnlyAsciiZ class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; asString! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!addressRelativeTo: bytecodes	| functionAddress bytecodesAddress |	functionAddress := self function address asInteger.	bytecodesAddress := (ExternalAddress forArray: bytecodes ) asInteger.	^ functionAddress - bytecodesAddress - offset - 4! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!function	^ self library functionNamed: functionName.! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!functionName	^ functionName! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!functionName: aSymbol	^ functionName := aSymbol! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!library	^ Executable default! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!patch: bytecodes	self patch: bytecodes with: (self addressRelativeTo: bytecodes).! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!patch: bytecodes with: value	bytecodes longAt: (offset + 1) put: value bigEndian: false.! !!FunctionRelocation methodsFor: 'as yet unclassified'!addressRelativeTo: bytecodes	^ self primAddressRelativeTo: bytecodes! !!FunctionRelocation methodsFor: 'as yet unclassified'!primAddressRelativeTo: bytecodes	<primitive: 155>	self primitiveFail.! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!defaultLibraryClass	^ NativeLibrary! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!library 		^ self defaultLibraryClass named: libraryName! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!libraryName	^ libraryName! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!libraryName: aSymbol	^ libraryName := aSymbol! !!ExternalFunctionRelocation methodsFor: 'as yet unclassified'!defaultLibraryClass	^ ExternalLibrary2! !!SequenceableCollection methodsFor: 'as yet unclassified'!asTraitComposition	"For convenience the composition {T1. T2 ...} is the same as T1 + T2 + ..."	^self isEmpty		ifFalse: [			self size = 1				ifTrue: [self first asTraitComposition]				ifFalse: [					self copyWithoutFirst 						inject: self first						into: [:left :right | left + right]]]		ifTrue: [			TraitComposition new]! !!Array methodsFor: 'as yet unclassified'!elementsExchangeIdentityWith: otherArray	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsExchangeIdentityWith: otherArray.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!elementsForwardIdentityTo: otherArray	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsForwardIdentityTo: otherArray.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!elementsForwardIdentityTo: otherArray copyHash: copyHash	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsForwardIdentityTo: otherArray copyHash: copyHash.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!primElementsExchangeIdentityWith: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  At the same time, all pointers to the elements of otherArray are replaced by pointers to the corresponding elements of this array.  The identityHashes remain with the pointers rather than with the objects so that objects in hashed structures should still be properly indexed after the mutation."	<primitive: 128>	otherArray class == Array ifFalse: [^ self error: 'arg must be array'].	self size = otherArray size ifFalse: [^ self error: 'arrays must be same size'].	(self anySatisfy: [:obj | obj class == SmallInteger]) ifTrue: [^ self error: 'can''t become SmallIntegers'].	(otherArray anySatisfy: [:obj | obj class == SmallInteger]) ifTrue: [^ self error: 'can''t become SmallIntegers'].	"Must have failed because not enough space in forwarding table (see ObjectMemory-prepareForwardingTableForBecoming:with:twoWay:).  Do GC and try again only once"	(Smalltalk bytesLeft: true) = Smalltalk primitiveGarbageCollect		ifTrue: [^ self primitiveFailed].	^ self elementsExchangeIdentityWith: otherArray! !!Array methodsFor: 'as yet unclassified'!primElementsForwardIdentityTo: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  The identityHashes remain with the pointers rather than with the objects so that the objects in this array should still be properly indexed in any existing hashed structures after the mutation."	<primitive: 72>	self primitiveFailed! !!Array methodsFor: 'as yet unclassified'!primElementsForwardIdentityTo: otherArray copyHash: copyHash	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  The identityHashes remain with the pointers rather than with the objects so that the objects in this array should still be properly indexed in any existing hashed structures after the mutation."	<primitive: 249>	self primitiveFailed! !!ExternalValue methodsFor: 'as yet unclassified'!beNull	"Make the receiver a NULL pointer"	self atAllPut: 0.! !!ExternalValue methodsFor: 'as yet unclassified'!isNull	^(self basicAt: 1) = 0	and: (self basicAt: 2) = 0	and: (self basicAt: 3) = 0	and: (self basicAt: 4) = 0	! !!ExternalValue class methodsFor: 'as yet unclassified'!initialize	Smalltalk addToStartUpList: self.! !!ExternalValue class methodsFor: 'as yet unclassified'!new	"External addresses are always 4 bytes long"	^super new: 4! !!ExternalValue class methodsFor: 'as yet unclassified'!new: n	"You better don't try this..."	^self shouldNotImplement! !!ExternalValue class methodsFor: 'as yet unclassified'!startUp: resuming	resuming ifTrue: [		self allInstancesDo: [ :addr |			addr beNull		]	].! !!SharedPool class methodsFor: 'as yet unclassified'!bindingOf: varName	"Answer the binding of some variable resolved in the scope of the receiver"	| aSymbol binding |	aSymbol := varName asSymbol.	"First look in classVar dictionary."	binding := self classPool bindingOf: aSymbol.	binding ifNotNil:[^binding].	"Next look in shared pools."	self sharedPools do:[:pool | 		binding := pool bindingOf: aSymbol.		binding ifNotNil:[^binding].	].	"subclassing and environment are not preserved"	^nil! !!SharedPool class methodsFor: 'as yet unclassified'!bindingsDo: aBlock	^self classPool bindingsDo: aBlock! !!SharedPool class methodsFor: 'as yet unclassified'!classBindingOf: varName	"For initialization messages grant the regular scope"	^super bindingOf: varName! !!SharedPool class methodsFor: 'as yet unclassified'!hasBindingThatBeginsWith: aString	"Answer true if the receiver has a binding that begins with aString, false otherwise"	"First look in classVar dictionary."	(self classPool hasBindingThatBeginsWith: aString) ifTrue:[^true].	"Next look in shared pools."	self sharedPools do:[:pool | 		(pool hasBindingThatBeginsWith: aString) ifTrue: [^true]].	^false! !!SharedPool class methodsFor: 'as yet unclassified'!includesKey: aName	"does this pool include aName"	^(self bindingOf: aName) notNil! !!SharedPool class methodsFor: 'as yet unclassified'!keysDo: aBlock"A hopefully temporary fix for an issue arising from miss-spelled variable names in code being compiled. The correction code (see Class>possibleVariablesFor:continuedFrom: assumes that sharedPools are Dictionaries. The proper fix would involve making sure all pools are actually subclasses of SharedPool, which they are not currently."	self bindingsDo:[:b|		aBlock value: b key]! !!Shell methodsFor: 'as yet unclassified'!display: string	| buffer |		buffer := AsciiZ fromString: string.	^ FileDescriptor stdout writeBuffer: buffer size: buffer size.! !!Shell methodsFor: 'as yet unclassified'!input: prompt	^ LibReadLine default readline: prompt! !!Shell methodsFor: 'as yet unclassified'!main	| line value failed anotherLine buffer |	LibReadLine default readHistory: self historyFileName.	[		anotherLine := false.		buffer := ''.		[ 	| prompt |			prompt := anotherLine ifTrue: [ '' ] ifFalse: [ '> ' ].			line _ self input: prompt.			line isEmpty				ifTrue: [ true ] 				ifFalse: [					(line last = $\)						ifTrue: [							anotherLine := true.							line at: line size put: Character lf.						]						ifFalse: [ anotherLine := false ].					buffer := buffer, line.					anotherLine				]		] whileTrue. 		buffer = 'quit' or: [ buffer = 'save' ]	] whileFalse: [		self addToHistory: buffer.		failed _ false.		value _ Compiler new evaluate: buffer in: nil to: nil notifying: self ifFail: [ failed _ true].		failed ifFalse: [ self display: (value printString); lf ]	].	LibReadLine default writeHistory: self historyFileName.	buffer = 'save' ifTrue: [ Smalltalk snapshotAndQuit ].	^value.! !!SignedIntegerType class methodsFor: 'as yet unclassified'!checkType: value	^ value isInteger and: [ value >= self min and: [ value <= self max ] ]! !!SignedIntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	^ handle longAt: 1 bigEndian: self isBigEndian.! !!SignedIntegerType class methodsFor: 'as yet unclassified'!store: anInteger in: handle	handle longAt: 1 put: anInteger bigEndian: self isBigEndian.! !!SignedByte class methodsFor: 'as yet unclassified'!max			^ 127! !!SignedByte class methodsFor: 'as yet unclassified'!min			^ -128! !!SignedInteger class methodsFor: 'as yet unclassified'!max			^ 2147483647! !!SignedInteger class methodsFor: 'as yet unclassified'!min			^ -2147483648! !!SignedShortInteger class methodsFor: 'as yet unclassified'!max			^ 32767! !!SignedShortInteger class methodsFor: 'as yet unclassified'!min			^ -32768! !!SourceReference methodsFor: 'as yet unclassified'!sourceFrom: aString	self hasEmptySourceReference ifTrue: [ ^ '' ].	^ aString copyFrom: sourceStart to: sourceStop! !!StandardFileStream class methodsFor: 'as yet unclassified'!retryWithGC: execBlock until: testBlock forFileNamed: fullName	"Re-implemented to only force GC if a file with the given name exists"	| blockValue foundIt |	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	"See if we have a file with the given name"	foundIt := self registry keys "hold on strongly for now" 		anySatisfy:[:file| file name sameAs: fullName].	foundIt ifFalse:[^blockValue].	Smalltalk garbageCollectMost.	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollect.	^execBlock value.! !!SystemDictionary methodsFor: 'as yet unclassified'!forgetClass: aClass logged: aBool 	"Delete the class, aClass, from the system.	Note that this doesn't do everything required to dispose of a class - to do that use Class>>removeFromSystem."	aBool ifTrue: [SystemChangeNotifier uniqueInstance classRemoved: aClass fromCategory: aClass category].			SystemOrganization removeElement: aClass name.	self removeFromStartUpList: aClass.	self removeFromShutDownList: aClass.	self removeKey: aClass name ifAbsent: [].	self flushClassNameCache! !!SystemDictionary methodsFor: 'as yet unclassified'!removeClassNamed: aName	"Invoked from fileouts:  if there is currently a class in the system named aName, then remove it.  If anything untoward happens, report it in the Transcript.  "	| oldClass |	(oldClass _ self at: aName asSymbol ifAbsent: [nil]) == nil		ifTrue:			[Transcript cr; show: 'Removal of class named ', aName, ' ignored because ', aName, ' does not exist.'.			^ self].	oldClass removeFromSystem! !!SystemDictionary methodsFor: 'as yet unclassified'!startUp	Processor startUp.	ProcessorScheduler startUp.	self processStartUpList: true.	self installLowSpaceWatcher.! !!SystemTracer methodsFor: 'as yet unclassified'!getAligned: size	^ (( size + 3 ) bitShift: -2) bitShift: 2.! !!TraitBehavior methodsFor: 'as yet unclassified'!addUser: aClassOrTrait	users add: aClassOrTrait! !!TraitBehavior methodsFor: 'as yet unclassified'!classesComposedWithMe	^users gather: [:u | u classesComposedWithMe]! !!TraitBehavior methodsFor: 'as yet unclassified'!initialize	self methodDict: Dictionary new.	self traitComposition: nil.	users _ IdentitySet new.! !!TraitBehavior methodsFor: 'as yet unclassified'!removeUser: aClassOrTrait	users remove: aClassOrTrait ifAbsent: []! !!TraitBehavior methodsFor: 'as yet unclassified'!users	^users! !!TraitComposition methodsFor: 'as yet unclassified'!assertValidUser: aBehavior	"Assert that this trait composition set for aBehavior	does not introduce a cycle."		(self allTraits includes: aBehavior) ifTrue: [		TraitCompositionException signal: 'Cycle in compositions:  The composition (in)directly includes this trait!!']! !!TraitComposition methodsFor: 'as yet unclassified'!methodDescriptionsForSelector: aSymbol	"Return a collection of TraitMethodDescriptions for aSymbol and all the 	aliases of aSymbol."	| selectors collection |	selectors _ IdentitySet with: aSymbol.	self transformations do: [:each |		selectors addAll: (each aliasesForSelector: aSymbol)].	collection _ OrderedCollection new: selectors size.	selectors do: [:each |		collection add: (self methodDescriptionForSelector: each)].	^collection! !!TraitDescription methodsFor: 'as yet unclassified'!trait	"for compatibility with TraitTransformations"	^ self! !!TraitDescription methodsFor: 'as yet unclassified'!updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil	| currentCategory effectiveCategory sel changedCategories composition |	changedCategories _ IdentitySet new.	composition := self hasTraitComposition		ifTrue: [self traitComposition]		ifFalse: [TraitComposition new].	(composition methodDescriptionsForSelector: aSymbol) do: [:each |		sel _ each selector.		(self includesLocalSelector: sel) ifFalse: [			currentCategory _ self organization categoryOfElement: sel.			effectiveCategory _ each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.			effectiveCategory isNil ifTrue: [				currentCategory ifNotNil: [changedCategories add: currentCategory].				self organization removeElement: sel.			] ifFalse: [				((currentCategory isNil or: [currentCategory == ClassOrganizer ambiguous or: [currentCategory == oldCategoryOrNil]]) and: [currentCategory ~~ effectiveCategory]) ifTrue: [					currentCategory ifNotNil: [changedCategories add: currentCategory].					self organization 						classify: sel 						under: effectiveCategory						suppressIfDefault: false]]]].	^ changedCategories! !!TraitDescription methodsFor: 'as yet unclassified'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	(self includesSelector: aSelector)		ifTrue: [^ self organization categoryOfElement: aSelector]		ifFalse: [^nil]! !!Trait methodsFor: 'as yet unclassified'!initialize	super initialize.	classTrait _ ClassTrait for: self! !!TranscriptCodeView class methodsFor: 'as yet unclassified'!initialize	Smalltalk addToStartUpList: self.! !!TranscriptCodeView class methodsFor: 'as yet unclassified'!startUp: resuming	resuming ifTrue: [		TranscriptCodeBuffer := nil.	].! !!TranscriptStream methodsFor: 'as yet unclassified'!open	TranscriptCodeEditor open.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!atEnd	position ifNil: [ ^ nil ].	^ position >= readLimit! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!close	"Close this file."	fileID ifNotNil: [		fileID close.		fileID := nil.		position := nil.	].! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!open: fileName flags: flags	[ fileID := LibC6 default open: fileName flags: flags ]		on: ExternalFunctionError		do: [ ^ nil ].	name := fileName.	readLimit := fileID size.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!open: fileName forWrite: writeMode 	| flags |	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	flags := writeMode 		ifTrue: [ LibC6 default valueForOpenFlagNamed: 'O_RDWR' ]		ifFalse: [ LibC6 default valueForOpenFlagNamed: 'O_RDONLY' ].	rwmode := writeMode.	^ self open: fileName flags: flags.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!openForOverwrite: fileName	| flags |	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	flags := ((LibC6 default valueForOpenFlagNamed: 'O_RDWR') 			bitOr: ( LibC6 default valueForOpenFlagNamed: 'O_TRUNC' )) 			bitOr: ( LibC6 default valueForOpenFlagNamed: 'O_CREAT' ).	rwmode := true.	^ self open: fileName flags: flags.! !!BufferedFileStream methodsFor: 'as yet unclassified'!close	"Close this file."	self flush.	^ super close.! !!BufferedFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	self subclassResponsibility! !!BufferedFileStream methodsFor: 'as yet unclassified'!defaultBufferSize	^ DefaultBufferSize.! !!BufferedFileStream methodsFor: 'as yet unclassified'!flush	| bufferPosition bufferSize |	fileID ifNil: [ ^ nil ].	rwmode ifFalse: [ ^ nil ].	bufferPosition := position truncateTo: (collection size).	bufferSize := collection size min: ( readLimit - bufferPosition).	fileID position: bufferPosition.	bufferSize > 0 ifTrue: [ fileID writeString: collection size: bufferSize ].	 ! !!BufferedFileStream methodsFor: 'as yet unclassified'!initializeBuffer	| bufferSize |	position := 0.	collection := self defaultBufferClass new: self defaultBufferSize.	bufferSize := collection size min: readLimit.	bufferSize > 0 ifTrue: [ fileID readString: collection size: bufferSize ]. ! !!BufferedFileStream methodsFor: 'as yet unclassified'!next	| byte |	byte := self peek.	self position: position + 1.	^ byte! !!BufferedFileStream methodsFor: 'as yet unclassified'!nextPut: char	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	position ifNil: [ self position: 0 ].	collection at: (position \\ (collection size)) + 1put: char.	self position: position + 1.	^ char! !!BufferedFileStream methodsFor: 'as yet unclassified'!open: fileName flags: flags	(super open: fileName flags: flags) ifNotNil: [ self initializeBuffer ].! !!BufferedFileStream methodsFor: 'as yet unclassified'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	position ifNil: [ self position: 0 ].	self atEnd ifTrue: [^ nil ].	^ collection at: (position \\ (collection size)) + 1.! !!BufferedFileStream methodsFor: 'as yet unclassified'!position: newPosition	| oldBufferPosition newBufferPosition bufferSize |	fileID ifNil: [ ^nil ].	newPosition < 0 ifTrue: [ ^nil ]."	((newPosition > readLimit) and: [ rwmode not ])  ifTrue: [ ^nil ]."	newPosition > readLimit ifTrue: [		rwmode ifTrue: [ readLimit := newPosition ] ifFalse: [ ^nil ]	].	oldBufferPosition := position truncateTo: (collection size).	newBufferPosition := newPosition truncateTo: (collection size).	newBufferPosition = oldBufferPosition ifFalse: [ 		self flush.		fileID position: newBufferPosition.		bufferSize := collection size min: ( readLimit - newBufferPosition).		collection := self defaultBufferClass new: self defaultBufferSize.		bufferSize > 0 ifTrue: [ fileID readString: collection size: bufferSize ].	].	position := newPosition."	rwmode ifTrue: [ readLimit := newPosition ]."	^ position.! !!BinaryFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	^ ByteArray! !!TextFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	^ String! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!concreteStream	"Who should we really direct class queries to?  "	^ UnbufferedFileStream.! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!fileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new open: fileName forWrite: true! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!forceNewFileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new openForOverwrite: fileName! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!readOnlyFileNamed: fileName 	"Open an existing file with the given name for reading."	| f |	f := self new open: fileName forWrite: false.	^ f isNil		ifFalse: [f]		ifTrue: ["File does not exist..."			((FileDoesNotExistException fileName: fileName) readOnly: true) signal].	"StandardFileStream readOnlyFileNamed: 'kjsd.txt' "! !!BufferedFileStream class methodsFor: 'as yet unclassified'!initialize	self initializeDefaultBufferSize.! !!BufferedFileStream class methodsFor: 'as yet unclassified'!initializeDefaultBufferSize	DefaultBufferSize := 4096.! !!UnhandledError methodsFor: 'as yet unclassified'!devDefaultAction	"The current computation is terminated. The cause of the error should be logged or reported to the user. If the program is operating in an interactive debugging environment the computation should be suspended and the debugger activated."	(GtkMessageDialog question: exception messageText, ', debug it?' ) = #yes		ifTrue: [ ^Processor activeProcess debugError: exception ]."	^ Processor activeProcess terminate."! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!checkType: value	^ value isInteger and: [ value >= 0 and: [ value <= self max ] ]! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	^ handle unsignedLongAt: 1 bigEndian: self isBigEndian.! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!min	^ 0! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!store: anInteger in: handle	handle unsignedLongAt: 1 put: anInteger bigEndian: self isBigEndian.! !!UnsignedByte class methodsFor: 'as yet unclassified'!max			^ 255! !!UnsignedInteger class methodsFor: 'as yet unclassified'!max			^ 4294967295! !!UnsignedShortInteger class methodsFor: 'as yet unclassified'!max			^ 65535! !!Workspace methodsFor: 'as yet unclassified'!buildMenuBar	| menu  edit  |	menu := GtkMenuBar new.	edit := GtkMenu new.	menu		append: AppLauncher fileMenu;		append: (edit createMenuItem: '_Edit');		append: workspaceView menu;		append: AppLauncher toolsMenu;		append: AppLauncher helpMenu.					^ menu.! !!Workspace methodsFor: 'as yet unclassified'!buildToolBar	| toolBar |	^ GtkToolbar new		appendItems: workspaceView toolBar;		yourself! !!Workspace methodsFor: 'as yet unclassified'!defaultCodeViewClass	^ WorkspaceView! !!Workspace methodsFor: 'as yet unclassified'!initialize	workspaceView := self defaultCodeViewClass new.	self container: (GtkVBox new		packStart: (self buildMenuBar) expand: false;		packStart: (self buildToolBar) expand: false;		packStart: (workspaceView view);		packStart: (GtkStatusbar new) expand: false	).! !!Workspace methodsFor: 'as yet unclassified'!inspectedVar: anObject	workspaceView inspectedVar: anObject.! !!TranscriptCodeEditor methodsFor: 'as yet unclassified'!defaultCodeViewClass	^ TranscriptCodeView! !!Workspace class methodsFor: 'as yet unclassified'!defaultSize	^ 640@480.! !!Workspace class methodsFor: 'as yet unclassified'!title	^'Workspace'! !!TranscriptCodeEditor class methodsFor: 'as yet unclassified'!title	^'Transcript'! !BufferedFileStream initialize!BufferedFileStream class removeSelector: #new!TranscriptCodeView initialize!TraitBehavior removeSelector: #initializeUsers!Application subclass: #Shell	instanceVariableNames: 'bindings'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!ExternalValue initialize!NativeFunctionRelocation removeSelector: #addressRelativeTo:!NativeFunctionRelocation removeSelector: #function!NativeFunctionRelocation removeSelector: #functionName!NativeFunctionRelocation removeSelector: #functionName:!NativeFunctionRelocation removeSelector: #patch:!NativeFunctionRelocation removeSelector: #patch:with:!ReadOnlyAsciiZ class removeSelector: #objectFromHandle:!ProcessorScheduler removeSelector: #activeProcess2!ProcessorScheduler removeSelector: #activeThreadData!ProcessorScheduler removeSelector: #primActiveThreadData!Process removeSelector: #threadData:!PrimitiveType class removeSelector: #defaultHandlerType!PrimitiveType class removeSelector: #instantiateHandler!NativeFunction removeSelector: #address!NativeFunction removeSelector: #bind!NativeFunction removeSelector: #invoke!NativeFunction removeSelector: #invokeAnswering:!NativeFunction removeSelector: #invokeAnswering:with:!NativeFunction removeSelector: #invokeAnswering:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:withArguments:!NativeFunction removeSelector: #invokeWith:!NativeFunction removeSelector: #invokeWith:with:!NativeFunction removeSelector: #invokeWith:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:with:with:!NativeFunction removeSelector: #invokeWithArguments:!NativeFunction removeSelector: #name!NativeFunction removeSelector: #name:!NativeFunction removeSelector: #throwNotKnownError!LibraryData removeSelector: #primitiveGetValue!LibExample initialize!LibC6 initialize!LibC6 removeSelector: #initializeUnistd!LibC6 removeSelector: #openPath:flags:!LibC6 removeSelector: #write2:buffer:size:!LibC removeSelector: #close!GPointer class removeSelector: #instantiateHandler!FileStream removeSelector: #position!FileDescriptor initialize!FileDescriptor removeSelector: #movePositionTo:!FileDescriptor removeSelector: #name!FileDescriptor removeSelector: #name:!FileDescriptor removeSelector: #positionFromEns:!FileDescriptor removeSelector: #setPositionAt:!FileDescriptor removeSelector: #setPositionFromEndAt:!CDeclFunction class removeSelector: #name:libraryNamed:returnType:argTypes:!ExecutableFunction class removeSelector: #name:library:!ExecutableFunction class removeSelector: #name:libraryNamed:!CDeclFunction removeSelector: #classFromType:!CDeclFunction removeSelector: #throwExternalFunctionError!ExecutableFunction removeSelector: #address!ExecutableFunction removeSelector: #bind!ExecutableFunction removeSelector: #invoke!ExecutableFunction removeSelector: #invokeWith:!ExecutableFunction removeSelector: #invokeWith:with:!ExecutableFunction removeSelector: #invokeWith:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithArguments:!ExecutableFunction removeSelector: #invokeWithReceiver:!ExecutableFunction removeSelector: #invokeWithReceiver:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:withArguments:!ExecutableFunction removeSelector: #library!ExecutableFunction removeSelector: #library:!ExecutableFunction removeSelector: #libraryName!ExecutableFunction removeSelector: #libraryNamed:!ExecutableFunction removeSelector: #name!ExecutableFunction removeSelector: #name:!ExecutableFunction removeSelector: #name:library:!ExecutableFunction removeSelector: #name:libraryNamed:!ExecutableFunction removeSelector: #primInvokeReceiver:withArguments:!ExecutableFunction removeSelector: #primInvokeWithArguments:!ExecutableFunction removeSelector: #primInvokeWithReceiver:withArguments:!ExecutableFunction removeSelector: #throwNotKnownError!ExternalSymbol removeSelector: #callingConventionString!ExternalObjectProxy removeSelector: #register!ExternalObjectProxy removeSelector: #unregister!AsciiZ class removeSelector: #objectFromHandle:!Executable class removeSelector: #huenul!DynamicLibrary class removeSelector: #addLibrary:named:!DynamicLibrary class removeSelector: #huemul!DynamicLibrary initialize!DynamicLibrary class removeSelector: #name:!DynamicLibrary class removeSelector: #named:!ExternalObject class removeSelector: #handle:!ExternalObject initialize!ExternalObject class removeSelector: #registry!ExternalObject class removeSelector: #registry:!AsciiZ removeSelector: #setFrom:!ExternalBuffer removeSelector: #finalize!ExternalBuffer removeSelector: #selfCheck!ExternalBuffer removeSelector: #setFrom:!ExternalBuffer removeSelector: #storeInto:size:!Executable removeSelector: #initialize!Executable removeSelector: #instantiateFunctionClass:!Executable removeSelector: #name:!Executable removeSelector: #nativeFunctionNamed:!Executable removeSelector: #primitiveOpen!DynamicLibrary removeSelector: #addExternal:!DynamicLibrary removeSelector: #basicName!DynamicLibrary removeSelector: #bind:!DynamicLibrary removeSelector: #bindFunction:!DynamicLibrary removeSelector: #cDeclFunctionNamed:returnType:argTypes:!DynamicLibrary removeSelector: #primitiveBind:!DynamicLibrary removeSelector: #primitiveBindFunction:!ExternalObject removeSelector: #isNullPointer!Object subclass: #ExternalObject	instanceVariableNames: 'handle'	classVariableNames: 'Registry'	poolDictionaries: ''	category: 'FFI-Types'!ExternalFunctionError class removeSelector: #function:!ExternalFunctionError removeSelector: #function!ExternalFunctionError removeSelector: #function:!ExternalFunctionError removeSelector: #isResumable!Error subclass: #ExternalFunctionError	instanceVariableNames: 'functionName'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!Application class removeSelector: #start!Application class removeSelector: #startWithArguments:!Class removeSelector: #superclass:methodDict:format:name:organization:instVarNames:classPool:sharedPools:!ClassBuilder removeSelector: #computeFormat:instSize:forSuper:ccIndex:!ClassBuilder removeSelector: #format:variable:words:pointers:weak:!Smalltalk removeClassNamed: #SystemChangeNotifierTest!RBProgramNodeVisitor subclass: #ASTChecker	instanceVariableNames: 'scope varsChangedInSend'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!RBProgramNodeVisitor subclass: #ASTTranslator	instanceVariableNames: 'methodBuilder receiverForCascade'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #Application	instanceVariableNames: 'arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!AssembleInstruction subclass: #AssembleCMov	instanceVariableNames: ''	classVariableNames: 'Condition'	poolDictionaries: ''	category: 'Exupery'!Object subclass: #AssemblerExupery	instanceVariableNames: 'stream blockAddresses jumpOffsets bytecodes instructionEncoders plugin relocator picEntries debugCollector source'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #BlockClosure	instanceVariableNames: 'method environment'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Contexts'!PluggableGtkSimpleApplication subclass: #ClassFinder	instanceVariableNames: 'classTrait'	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!Object subclass: #ColouringRegisterAllocator	instanceVariableNames: 'source result machine interferenceGraph registerStack registerFile registerTable spiltRegisters hasSpilt coloursUsed simplifyWorklist spillWorklist moveWorklist coalescedMoves isValidating deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #DebugInfo	instanceVariableNames: 'codeSourceReferences argVarsReferences tempVarsReferences capturedVarsReferences'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!Object subclass: #EventManager	instanceVariableNames: 'actionMap'	classVariableNames: 'ActionMaps'	poolDictionaries: ''	category: 'System-Object'!Error subclass: #ExternalFunctionError	instanceVariableNames: 'functionName '	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!Object subclass: #ExternalObject	instanceVariableNames: 'handle '	classVariableNames: 'Registry '	poolDictionaries: ''	category: 'FFI-Types'!ExternalObject subclass: #DynamicLibrary	instanceVariableNames: 'name symbolCache'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!DynamicLibrary subclass: #Executable	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!ExternalObject subclass: #ExternalBuffer	instanceVariableNames: 'size'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalBuffer subclass: #AsciiZ	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!DynamicLibrary class	instanceVariableNames: 'default'!ExternalObject subclass: #ExternalObjectProxy	instanceVariableNames: 'object'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalObjectProxy subclass: #ExternalArrayProxy	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalObject subclass: #ExternalSymbol	instanceVariableNames: 'name library'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!ExternalSymbol subclass: #ExecutableFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!ExecutableFunction subclass: #CDeclFunction	instanceVariableNames: 'returnType argTypes'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Error subclass: #ExternalSymbolError	instanceVariableNames: 'symbolName'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!ExternalObject subclass: #FileDescriptor	instanceVariableNames: ''	classVariableNames: 'StandardDescriptors'	poolDictionaries: ''	category: 'FFI-Types'!Error subclass: #FileStreamException	instanceVariableNames: 'fileName'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #CannotDeleteFileException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #FileDoesNotExistException	instanceVariableNames: 'readOnly'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #FileExistsException	instanceVariableNames: 'fileClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!AssemblyCopier subclass: #FinalCopier	instanceVariableNames: 'deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!LexicalScope subclass: #FunctionScope	instanceVariableNames: 'thisContextVar thisEnvVar tempVars capturedVars isHome hasInnerFreeVars hideTemps argVars uninitializedTemps capturedParentEnv'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #GIRBuilder	instanceVariableNames: 'ir currentBlock machine relocationInfo primitiveNode literals thisEnvVar cacheMap literalTemp source start stop debugInfo'	classVariableNames: 'InlinedSelectors SpecialConstants SpecialSelectors'	poolDictionaries: ''	category: 'Compiler-IR'!LexicalScope subclass: #InstanceScope	instanceVariableNames: 'vars'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!DynamicLibrary subclass: #LibC6	instanceVariableNames: ''	classVariableNames: 'LSeekDirectives OpenFlags'	poolDictionaries: ''	category: 'FFI-Libraries'!Object subclass: #LibExample	instanceVariableNames: ''	classVariableNames: 'GETPID'	poolDictionaries: ''	category: 'Guille-Test'!DynamicLibrary subclass: #LibReadLine	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!ExternalSymbol subclass: #LibraryData	instanceVariableNames: 'type'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Object subclass: #LivenessAnalyser	instanceVariableNames: 'source hasUpdated isValidating deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #MedLanguage	instanceVariableNames: 'in out start stop'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedCMov	instanceVariableNames: 'type from to'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedEnter	instanceVariableNames: 'argument'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedLeave	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedLiteral	instanceVariableNames: 'literal'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLiteral subclass: #MedFunction	instanceVariableNames: 'block byteCodeAddress'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!ExecutableFunction subclass: #NativeFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Object subclass: #PrimitiveType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!PrimitiveType subclass: #IntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!RBProgramNode subclass: #RBReturnNode	instanceVariableNames: 'return value homeBinding frameBinding'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Nodes'!ExternalObject subclass: #ReadOnlyAsciiZ	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SemanticWarning subclass: #RedeclaredVariableWarning	instanceVariableNames: 'variableNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #RelocationInfo	instanceVariableNames: 'offset'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #ExecutableFunctionRelocation	instanceVariableNames: 'functionName'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #FunctionRelocation	instanceVariableNames: 'function'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #LiteralRelocation	instanceVariableNames: 'literals'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!ExecutableFunctionRelocation subclass: #NativeFunctionRelocation	instanceVariableNames: 'libraryName'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!NativeFunctionRelocation subclass: #ExternalFunctionRelocation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #PrimitiveRelocation	instanceVariableNames: 'number'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!Object subclass: #ScopeVar	instanceVariableNames: 'scope usage'	classVariableNames: 'UsageAutomaton'	poolDictionaries: ''	category: 'Compiler-Semantics'!ScopeVar subclass: #GlobalVar	instanceVariableNames: 'assoc'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!ScopeVar subclass: #LocalVar	instanceVariableNames: 'name index'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!LocalVar subclass: #ArgVar	instanceVariableNames: 'isArg'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!LocalVar subclass: #CapturedVar	instanceVariableNames: 'sourceTemp'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!ByteArray variableByteSubclass: #ExternalValue	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!Object subclass: #SharedPool	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Pools'!Application subclass: #Shell	instanceVariableNames: 'bindings '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!IntegerType subclass: #SignedIntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedByte	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedShortInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!Object subclass: #SourceReference	instanceVariableNames: 'sourceStart sourceStop codeStop'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!RelocationInfo subclass: #SpecialSelectorRelocation	instanceVariableNames: 'specialSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!Model subclass: #StringHolder	instanceVariableNames: 'contents'	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Kernel-Remnants'!Object subclass: #SystemTracer	instanceVariableNames: 'byteStream traceQueue oopMap nextChunk nilOop count'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Tracer'!LocalVar subclass: #TempVar	instanceVariableNames: 'isArg'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Error subclass: #TraitException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Kernel'!TraitException subclass: #TraitCompositionException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Composition'!Error subclass: #TypeConvertionError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!FileStream subclass: #UnbufferedFileStream	instanceVariableNames: 'name fileID'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!Smalltalk renameClassNamed: #BufferedFileStream2 as: #BufferedFileStream!UnbufferedFileStream subclass: #BufferedFileStream	instanceVariableNames: ''	classVariableNames: 'DefaultBufferSize'	poolDictionaries: ''	category: 'Files-Kernel'!BufferedFileStream subclass: #BinaryFileStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!BufferedFileStream subclass: #TextFileStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!IntegerType subclass: #UnsignedIntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedByte	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedShortInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SemanticWarning subclass: #UnusedVariableWarning	instanceVariableNames: 'variableNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #VarReference	instanceVariableNames: 'name'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!RelocationInfo subclass: #VariableRelocation	instanceVariableNames: 'variable'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!PluggableGtkSimpleApplication subclass: #Workspace	instanceVariableNames: 'workspaceView'	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!Workspace subclass: #TranscriptCodeEditor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!!Object methodsFor: 'as yet unclassified'!errorSubscriptBounds: index 	"Create an error notification that an improper integer was used as an index."	self error: 'subscript is out of bounds: ' , index printString! !!Object methodsFor: 'as yet unclassified'!executeMethod: compiledMethod withArgs: argArray	"Execute compiledMethod against the receiver and args in argArray"	| selector |	<primitive: 188>	selector _ Symbol new.	self class addSelectorSilently: selector withMethod: compiledMethod.	^ [self perform: selector withArguments: argArray]		ensure: [self class basicRemoveSelector: selector]! !!Object methodsFor: 'as yet unclassified'!withArgs: argArray executeMethod: compiledMethod	"For compatibility with Aqueak"	self executeMethod: compiledMethod withArgs: argArray! !!Application methodsFor: 'as yet unclassified'!arguments	^ arguments.! !!Application methodsFor: 'as yet unclassified'!arguments: anArray	arguments := anArray.! !!Application methodsFor: 'as yet unclassified'!main	self subclassResponsibility.! !!Application methodsFor: 'as yet unclassified'!startUp	Smalltalk startUp.	^ self main.! !!Behavior methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return true if it is safe to zap the method dictionary on #obsolete"	^true! !!Behavior methodsFor: 'as yet unclassified'!isWeak	^ (format bitAnd: 4) = 1.! !!Behavior methodsFor: 'as yet unclassified'!obsolete	"Invalidate and recycle local methods,	e.g., zap the method dictionary if can be done safely."	self canZapMethodDictionary		ifTrue: [self methodDict: self emptyMethodDictionary].! !!Behavior methodsFor: 'as yet unclassified'!removeSelector: selector	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method."	| oldMethod |		oldMethod _ self methodDict at: selector ifAbsent: [^ self].	self methodDict removeKey: selector.	"Now flush Squeak's method cache, either by selector or by method"	oldMethod flushCache.	selector flushCache! !!Behavior methodsFor: 'as yet unclassified'!selectorsAndMethodsDo: aBlock	"Evaluate selectorBlock for all the message selectors in my method dictionary."	^ self methodDict keysAndValuesDo: aBlock! !!Behavior methodsFor: 'as yet unclassified'!setTraitComposition: aTraitComposition	| oldComposition |	(self hasTraitComposition not and: [aTraitComposition isEmpty]) ifTrue: [^self].	aTraitComposition assertValidUser: self.	oldComposition _ self traitComposition.	self traitComposition: aTraitComposition."	self applyChangesOfNewTraitCompositionReplacing: oldComposition."		oldComposition traits do: [:each | each removeUser: self].	aTraitComposition traits do: [:each | each addUser: self]! !!Behavior methodsFor: 'as yet unclassified'!traitCompositionString	^self hasTraitComposition		ifTrue: [self traitComposition asString]		ifFalse: ['{}']! !!Behavior methodsFor: 'as yet unclassified'!typeOfClass	"Answer a symbol uniquely describing the type of the receiver"	self isWeak ifTrue: [ ^ #weak ].	^ (format bitAnd: 3) caseOf: {		[ 0 ] -> [ #normal ].		[ 1 ] -> [ #variable ].		[ 2 ] -> [ #bytes ].		[ 3 ] -> [ #words ]	}! !!Behavior methodsFor: 'as yet unclassified'!whichSelectorsReferTo: literal	"Answer a set of selectors whose methods access the argument as a literal."	| who |	who _ IdentitySet new.	self selectorsAndMethodsDo: 		[:sel :method |		(method hasLiteral: literal)			ifTrue:				[((literal isVariableBinding) not					or: [method literals allButLast includes: literal])						ifTrue: [who add: sel]]].	^ who! !!BehaviorTest methodsFor: 'as yet unclassified'!testBehaviorSubclasses	"self run: #testBehaviorSubclasses"		| b b2 |"	b := Behavior new.	b superclass: OrderedCollection.	b methodDictionary: Dictionary new.	self shouldnt: [b subclasses ] raise: Error.	self shouldnt: [b withAllSubclasses] raise: Error.	self shouldnt: [b allSubclasses] raise: Error.	b2 := Behavior new.	b2 superclass: b.	b2 methodDictionary: Dictionary new.	self assert: (b subclasses includes: b2).	self assert: (b withAllSubclasses includes: b)."! !!BlockClosure methodsFor: 'as yet unclassified'!valueWithArguments: anArray 	"Evaluate the block with given args. Fail if the block expects other than the given number of arguments."	^ environment executeMethod: method withArgs: anArray ! !!ClassBrowser methodsFor: 'as yet unclassified'!buildClassCategoriesView	| model tree col cell |	tree := nil->nil.	SystemOrganization categories do: [ :each |		| category |		category := tree.		(each subStrings: '-') do: [ :cat |			category value ifNil: [ category value: Dictionary new].			category := category value associationAt: cat ifAbsent: [ category value at: cat put: nil. category value associationAt: cat ]		]	].	model := GtkTreeStore new: {String. String}.	[ self addSubcategoriesFrom: tree fromIter: nil inModel: model ] fork.	classCategoriesTree := GtkTreeView model: model.	col := GtkTreeViewColumn title: 'Class categories'.	cell := GtkCellRendererPixbuf new.	col		packStart: cell expand: false;		addAttribute: #stockId column: 1 on: cell.	cell := GtkCellRendererText new.	col		packStart: cell;		addAttribute: #text column: 0 on: cell.		classCategoriesTree appendColumn: col.	classCategoriesTree selection when: #changed send: #onClassCategoryChanged to: self.	classCategoriesTree enableTreeLines: true.	^ GtkScrolledWindow withChild: classCategoriesTree! !!ClassBrowser methodsFor: 'as yet unclassified'!loadClassMethodsOf: aClassClass	| iter |	classMethodsTree model clear.	aClassClass organization categories do: [ :cat |		iter := classMethodsTree model append: nil->{cat asString. true. 'grey'. 'gtk-info'}.		(aClassClass organization listAtCategoryNamed: cat) asSortedCollection do: [ :sel |			classMethodsTree model append: iter->{sel asString. false. 'grey'. 'gtk-execute'}		]	].	classMethodsTree expandAll.! !!ClassBrowser methodsFor: 'as yet unclassified'!loadInstanceMethodsOf: aClass	| iter |	instanceMethodsTree model clear.	aClass organization categories do: [ :cat |		iter := instanceMethodsTree model append: nil->{cat asString. true. 'grey'. 'gtk-info'}.		(aClass organization listAtCategoryNamed: cat) asSortedCollection do: [ :sel |			instanceMethodsTree model append: iter->{sel asString. false. 'grey'. 'gtk-execute'}		]	].	instanceMethodsTree expandAll.! !!ClassBrowser methodsFor: 'as yet unclassified'!onClassHierarchyChanged	| class iter path newIter aCategory classHierarchySelectedRow classesTreeSelectedRow |	classHierarchySelectedRow := classHierarchyTree selectedRow.	classHierarchySelectedRow ifNotNil: [		class := Smalltalk at: (classHierarchySelectedRow first asSymbol).							aCategory := class category.		( aCategory isNotNil and: [ aCategory ~= selectedClassCategory ] ) ifTrue: [			selectedClassCategory := aCategory.			iter := classCategoriesTree model firstIter.			newIter := nil.			(aCategory subStrings: '-') do: [ :cat |				newIter ifNotNil: [ iter := newIter ].				iter := self classCategoryFor: cat firstIter: iter.				newIter := classCategoriesTree model firstChildAt: iter.			].			path := classCategoriesTree model pathFromIter: iter.			classCategoriesTree expandRowsUpTo: path.			classCategoriesTree moveCursorAt: path.					classesTree model clear.			(SystemOrganization listAtCategoryNamed: aCategory) sort do: [ :ea |				classesTree model append: {ea asString. 'gtk-execute'}			]		].							self selectClass: class.	]! !!ClassBuilder methodsFor: 'as yet unclassified'!formatForType: type	^ type caseOf: {		[ #normal ] -> [ 0 ].		[ #variable ] -> [ 1 ].		[ #bytes ] -> [ 2 ].		[ #words ] -> [ 3 ].		[ #weak ] -> [ 5 "binary: 4 + 0 + 0 + 1" ]	} otherwise: [ self error: 'Unknown class type' ].! !!ClassBuilder methodsFor: 'as yet unclassified'!needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Answer whether we need a new subclass to conform to the requested changes"	"Check if we really need a new subclass"	oldClass ifNil:[^true]. "yes, it's a new class"	newSuper == oldClass superclass ifFalse:[^true]. "yes, it's a superclass change"	type = oldClass typeOfClass ifFalse:[^true]. "yes, it's a format change"	instVars = oldClass instVarNames ifFalse:[^true]. "yes, it's an iVar change"	^false! !!ClassBuilder methodsFor: 'as yet unclassified'!newSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Create a new subclass of the given superclass with the given specification."	| newClass |	(oldClass == nil or:[oldClass isMeta not]) 		ifTrue:[newClass := self privateNewSubclassOf: newSuper from: oldClass]		ifFalse:[newClass := oldClass clone].	newClass 		superclass: newSuper		methodDictionary: "Method"Dictionary new		instanceSize: (newSuper instSize + instVars size)		format: (self formatForType: type);		setInstVarNames: instVars.	oldClass ifNotNil:[		newClass organization: oldClass organization.		"Recompile the new class"		oldClass hasMethods 			ifTrue:[newClass compileAllFrom: oldClass].		oldClass hasTraitComposition ifTrue: [			newClass setTraitComposition: oldClass traitComposition copyTraitExpression ].		oldClass class hasTraitComposition ifTrue: [			newClass class setTraitComposition: oldClass class traitComposition copyTraitExpression ].				self recordClass: oldClass replacedBy: newClass.	].	(oldClass == nil or:[oldClass isObsolete not]) 		ifTrue:[newSuper addSubclass: newClass]		ifFalse:[newSuper addObsoleteSubclass: newClass].	^newClass! !!ClassBuilder methodsFor: 'as yet unclassified'!privateNewSubclassOf: newSuper from: oldClass	"Create a new meta and non-meta subclass of newSuper using oldClass as template"	"WARNING: This method does not preserve the superclass/subclass invariant!!"	| newSuperMeta oldMeta newMeta |	oldClass ifNil:[^self privateNewSubclassOf: newSuper].	newSuperMeta _ newSuper ifNil:[Class] ifNotNil:[newSuper class].	oldMeta _ oldClass class.	newMeta _ oldMeta clone.	newMeta 		superclass: newSuperMeta		methodDictionary: "Method"Dictionary new		instanceSize: oldMeta instSize		format: oldMeta format;		setInstVarNames: oldMeta instVarNames;		organization: oldMeta organization.	"Recompile the meta class"	oldMeta hasMethods 		ifTrue:[newMeta compileAllFrom: oldMeta].	"Record the meta class change"	self recordClass: oldMeta replacedBy: newMeta.	"And create a new instance"	^newMeta adoptInstance: oldClass from: oldMeta! !!ClassBuilder methodsFor: 'as yet unclassified'!reshapeClass: oldClass toSuper: newSuper	"Reshape the given class to the new super class. Recompile all the methods in the newly created class. Answer the new class."	| instVars |	instVars _ instVarMap at: oldClass name ifAbsent:[oldClass instVarNames].	^self newSubclassOf: newSuper 			type: oldClass typeOfClass 			instanceVariables: instVars 			from: oldClass! !!ClassDescription methodsFor: 'as yet unclassified'!classVersion	"Default.  Any class may return a later version to inform readers that use ReferenceStream.  8/17/96 tk"	"This method allows you to distinguish between class versions when the shape of the class 	hasn't changed (when there's no change in the instVar names).	In the conversion methods you usually can tell by the inst var names 	what old version you have. In a few cases, though, the same inst var 	names were kept but their interpretation changed (like in the layoutFrame).	By changing the class version when you keep the same instVars you can 	warn older and newer images that they have to convert."	^ 0! !!ClassDescription methodsFor: 'as yet unclassified'!obsolete	"Make the receiver obsolete."	superclass removeSubclass: self.	self organization: nil.	super obsolete.! !!ClassDescription methodsFor: 'as yet unclassified'!removeSelector: selector 	"Remove the message whose selector is given from the method 	dictionary of the receiver, if it is there. Answer nil otherwise."		| priorMethod priorProtocol | 	priorMethod _ self compiledMethodAt: selector ifAbsent: [^ nil].	priorProtocol _ self whichCategoryIncludesSelector: selector.	SystemChangeNotifier uniqueInstance		doSilently: [self organization removeElement: selector ].	super removeSelector: selector.	SystemChangeNotifier uniqueInstance 			methodRemoved: priorMethod selector: selector inProtocol: priorProtocol class: self.! !!ClassDescription methodsFor: 'as yet unclassified'!updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil	| currentCategory effectiveCategory sel changedCategories composition |	changedCategories _ IdentitySet new.	composition := self hasTraitComposition		ifTrue: [self traitComposition]		ifFalse: [TraitComposition new].	(composition methodDescriptionsForSelector: aSymbol) do: [:each |		sel _ each selector.		(self includesLocalSelector: sel) ifFalse: [			currentCategory _ self organization categoryOfElement: sel.			effectiveCategory _ each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.			effectiveCategory isNil ifTrue: [				currentCategory ifNotNil: [changedCategories add: currentCategory].				self organization removeElement: sel.			] ifFalse: [				((currentCategory isNil or: [currentCategory == ClassOrganizer ambiguous or: [currentCategory == oldCategoryOrNil]]) and: [currentCategory ~~ effectiveCategory]) ifTrue: [					currentCategory ifNotNil: [changedCategories add: currentCategory].					self organization 						classify: sel 						under: effectiveCategory						suppressIfDefault: false]]]].	^ changedCategories! !!ClassDescription methodsFor: 'as yet unclassified'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	(self includesSelector: aSelector)		ifTrue: [^ self organization categoryOfElement: aSelector]		ifFalse: [^nil]! !!Class methodsFor: 'as yet unclassified'!classPool: aDictionary	classPool _ aDictionary! !!Class methodsFor: 'as yet unclassified'!copy 	| newClass |	newClass _ self class copy new		superclass: superclass		methodDict: self methodDict copy		instanceSize: self instSize		format: format		name: name		organization: self organization copy		instVarNames: instanceVariables copy		classPool: classPool copy		sharedPools: sharedPools.	Class instSize+1 to: self class instSize do:		[:offset | newClass instVarAt: offset put: (self instVarAt: offset)].	^ newClass! !!Class methodsFor: 'as yet unclassified'!deactivate	"A remnant from the 3.3a modules work, retained . Does nothing, but may be overridden in Metaclasses."! !!Class methodsFor: 'as yet unclassified'!isSystemDefined	"Answer true if the receiver is a system-defined class, and not a UniClass (an instance-specific lightweight class)"	^ self == self officialClass! !!Class methodsFor: 'as yet unclassified'!obsolete	"Change the receiver and all of its subclasses to an obsolete class."	self == Object 		ifTrue: [^self error: 'Object is NOT obsolete'].	self setName: 'AnObsolete' , self name.	Object class instSize + 1 to: self class instSize do:		[:i | self instVarAt: i put: nil]. "Store nil over class instVars."	self classPool: nil.	self sharedPools: nil.	self class obsolete.	super obsolete.! !!Class methodsFor: 'as yet unclassified'!officialClass	"I am not a UniClass.  (See Player officialClass).  Return the class you use to make new subclasses."	^ self! !!Class methodsFor: 'as yet unclassified'!removeFromSystem	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."	self removeFromSystem: true.! !!Class methodsFor: 'as yet unclassified'!removeFromSystem: logged	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."		"keep the class name and category for triggering the system change message. If we wait to long, then we get obsolete information which is not what we want."	"tell class to deactivate and unload itself-- two separate events in the module system"	self deactivate; unload.	self superclass ifNotNil:		["If we have no superclass there's nothing to be remembered"		self superclass addObsoleteSubclass: self].	self environment forgetClass: self logged: logged.	self obsolete.! !!Class methodsFor: 'as yet unclassified'!sharedPools: aCollection	sharedPools _ aCollection! !!Class methodsFor: 'as yet unclassified'!superclass: sup methodDict: md instanceSize: is format: ft name: nm organization: org instVarNames: nilOrArray classPool: pool sharedPools: poolSet 	"Answer an instance of me, a new class, using the arguments of the 	message as the needed information.	Must only be sent to a new instance; else we would need Object flushCache."	superclass := sup.	methodDict := md.	instanceSize := is.	format := ft.	name := nm.	instanceVariables := nilOrArray.	classPool := pool.	sharedPools := poolSet.	self organization: org.! !!Class methodsFor: 'as yet unclassified'!unload	"Sent when a the class is removed.  Does nothing, but may be overridden by (class-side) subclasses."! !!Class methodsFor: 'as yet unclassified'!variableByteSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable byte-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableByteSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!variableSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable pointer variables."	^(ClassBuilder new)		superclass: self		variableSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!variableWordSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable word-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableWordSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!weakSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have weak indexable pointer variables."	^(ClassBuilder new)		superclass: self		weakSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!AppLauncher class methodsFor: 'as yet unclassified'!openAboutHuemul	| dlg logo |	logo := GdkPixbuf fromFile: 'Huemul.jpg'.	dlg := GtkAboutDialog new.	dlg		aboutDialogName: 'Huemul Smalltalk';		version: '0.8';		license: (StandardFileStream readOnlyFileNamed: 'LICENSE') upToEnd;		website: 'http://www.guillermomolina.com.ar/huemul';		comments: 'This is Huemul Smalltalk';		authors: {'Guillermo Adrian Molina'};		logo: logo.	dlg runAndDestroy! !!AppLauncher class methodsFor: 'as yet unclassified'!openWorkspace	^ Workspace open! !!Application class methodsFor: 'as yet unclassified'!startUp	^ self new startUp.! !!Application class methodsFor: 'as yet unclassified'!startUpWithArguments: arguments	| application |	application := self new.	application arguments: arguments.	^ application startUp.! !!Behavior class methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return false since zapping the method dictionary of Behavior class or its subclasses will cause the system to fail."	^false! !!ClassBrowser class methodsFor: 'as yet unclassified'!defaultSize	^ 640@480.! !!ClassBrowser class methodsFor: 'as yet unclassified'!title	^'Class browser'! !!ClassFinder class methodsFor: 'as yet unclassified'!defaultSize	^ 200@300.! !!ClassFinder class methodsFor: 'as yet unclassified'!title	^'Class finder'! !!CompiledMethod methodsFor: 'as yet unclassified'!hasLiteral: literal	"Answer whether the receiver references the argument, literal."	literals ifNil: [ ^false ].	^ literals hasLiteral: literal.! !!CompiledMethod methodsFor: 'as yet unclassified'!sourcePointer	"Answer the integer which can be used to find the source file and position for this method.	Not sources yet"	^ 0! !!CompiledMethodWithNode class methodsFor: 'as yet unclassified'!method: aCompiledMethod node: aMethodNode	^ self new method: aCompiledMethod; node: aMethodNode.! !!Compiler methodsFor: 'as yet unclassified'!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into a method. In other words, if receiver is not nil, then the text can refer to instance variables of that receiver (the Inspector uses this). If aContext is not nil, the text can refer to temporaries in that context (the Debugger uses this). If aRequestor is not nil, then it will receive a notify:at: message before the attempt to evaluate is aborted. Finally, the compiled method is directly invoked without modifying the receiving-class."	"| methodNode method value |	  	(Preferences compileUseNewCompiler or: 			[aContext ifNotNil: [aContext method isClosureCompiled] ifNil: [false]]) ifTrue: 				[^ self evaluate2: textOrStream 					    in: aContext 					    to: receiver 					    notifying: aRequestor 					    ifFail: failBlock 					    logged: logFlag].		class := (aContext isNil 		ifTrue: [ receiver ] 		ifFalse: [ aContext receiver ])			class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode := self 		translate: sourceStream		noPattern: true 		ifFail: [ ^ failBlock value ].	method := methodNode generate.	self interactive		ifTrue: [ method := method copyWithTempNames: methodNode tempNames ].	value := receiver		executeMethod: method 		withArgs: (context isNil			ifTrue: [ #() ]			ifFalse: [ Array with: aContext ]).	logFlag 		ifTrue: [ SystemChangeNotifier uniqueInstance evaluated: sourceStream contents context: aContext ].	^ value."	| string block |	string _ textOrStream readStream upToEnd.	block := self compileDoIt: string in: aContext to: receiver notifying: aRequestor ifFail: [^ failBlock value] log: logFlag.	^ block value! !!Exception methodsFor: 'as yet unclassified'!messageText	messageText ifNil: [ ^ self class name asString ].	^messageText! !!Exception methodsFor: 'as yet unclassified'!receiver	^ self signalerContext receiver! !!ExternalFunctionError methodsFor: 'as yet unclassified'!functionName	"Answer the function name that was beiing used."	^functionName! !!ExternalFunctionError methodsFor: 'as yet unclassified'!functionName: argument	"Specify the function name that was beiing used."	functionName := argument! !!ExternalFunctionError class methodsFor: 'as yet unclassified'!functionName: argument	^self new functionName: argument; yourself! !!ExternalObject methodsFor: 'as yet unclassified'!= anObject 	(anObject isKindOf: self class)		ifTrue: [^ anObject handle = self handle]		ifFalse: [^ false]! !!ExternalObject methodsFor: 'as yet unclassified'!beNull	^ handle beNull.! !!ExternalObject methodsFor: 'as yet unclassified'!finalize		self free.	self unregister.! !!ExternalObject methodsFor: 'as yet unclassified'!free	"Should override this"! !!ExternalObject methodsFor: 'as yet unclassified'!initialize	handle := self class defaultHandlerClass new.	self register.! !!ExternalObject methodsFor: 'as yet unclassified'!isNull	^ self handle isNull.! !!ExternalObject methodsFor: 'as yet unclassified'!register	Registry add: self.! !!ExternalObject methodsFor: 'as yet unclassified'!unregister		Registry remove: self ifAbsent:[  ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!addSymbol: anExternalSymbol	^ symbolCache at: anExternalSymbol name put: anExternalSymbol.! !!DynamicLibrary methodsFor: 'as yet unclassified'!bindSymbol: anExternalSymbol	^ self primitiveBindSymbol: anExternalSymbol.! !!DynamicLibrary methodsFor: 'as yet unclassified'!cDeclFunctionNamed: functionName	^ symbolCache at: functionName ifAbsent: [ self error: 'You must initialize the function before using it' ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!close		handle isNull ifFalse: [ 		self primitiveClose		handle beNull.	].! !!DynamicLibrary methodsFor: 'as yet unclassified'!initialize	super initialize.	symbolCache := Dictionary new.! !!DynamicLibrary methodsFor: 'as yet unclassified'!initializeCDeclFunctionNamed: functionName returnType: retType argTypes: argTypesArray	^ symbolCache at: functionName put: 			(CDeclFunction name: functionName library: self  returnType: retType argTypes: argTypesArray)! !!DynamicLibrary methodsFor: 'as yet unclassified'!initializeLibraryDataNamed: symbolName type: type	^ symbolCache at: symbolName put: (LibraryData name: symbolName library: self  type: type)! !!DynamicLibrary methodsFor: 'as yet unclassified'!libraryDataNamed: symbolName	^ symbolCache at: symbolName ifAbsent: [ self error: 'You must initialize the symbol before using it' ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!name	^name! !!DynamicLibrary methodsFor: 'as yet unclassified'!name: aName	name := aName.! !!DynamicLibrary methodsFor: 'as yet unclassified'!nativeFunctionNamed: functionName	^ symbolCache at: functionName ifAbsent: [ 		symbolCache at: functionName put: (NativeFunction name: functionName library: self)	].! !!DynamicLibrary methodsFor: 'as yet unclassified'!open		handle isNull ifTrue: [ self primitiveOpen ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveBindSymbol: anExternalSymbol	"Primitive. Find the given symbol in the library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 203>	^ anExternalSymbol throwNotKnownError.! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveClose	"Primitive. Close the given library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 202>! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveOpen	"Primitive. Open the given library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 198>	self primitiveFailed.! !!DynamicLibrary methodsFor: 'as yet unclassified'!printOn: aStream	aStream nextPutAll: self name.! !!DynamicLibrary methodsFor: 'as yet unclassified'!symbolNamed: symbolName	^ symbolCache at: symbolName ifAbsent: [ self error: 'You must initialize the symbol before using it' ]! !!Executable methodsFor: 'as yet unclassified'!name	^ Utilities executableName ! !!Executable methodsFor: 'as yet unclassified'!primitiveSmallIntegerAdd: receiver with: argument	^ (self nativeFunctionNamed: #primitiveSmallIntegerAdd) invokeReceiver: receiver with: argument.! !!ExternalBuffer methodsFor: 'as yet unclassified'!asByteArray	| array |	size ifNil: [ ^ self class throwTypeConvertionError ].	array := ByteArray new: self basicSize.	self storeInto: array.	^ array	! !!ExternalBuffer methodsFor: 'as yet unclassified'!atAllPut: constant	^ LibC6 default memSet: self constant: constant count: self size.! !!ExternalBuffer methodsFor: 'as yet unclassified'!atAllPutZero	^ self atAllPut: 0.! !!ExternalBuffer methodsFor: 'as yet unclassified'!basicSize	^ size.! !!ExternalBuffer methodsFor: 'as yet unclassified'!byteAt: index	<primitive: 190>	index isNumber		ifTrue: [self errorSubscriptBounds: index]		ifFalse: [self errorNonIntegerIndex].! !!ExternalBuffer methodsFor: 'as yet unclassified'!byteAt: index put: value	<primitive: 191>	index isNumber		ifTrue: [self errorSubscriptBounds: index]		ifFalse: [self errorNonIntegerIndex].! !!ExternalBuffer methodsFor: 'as yet unclassified'!free		handle isNull ifFalse: [ 		LibC6 default free: self.		self beNull.	]! !!ExternalBuffer methodsFor: 'as yet unclassified'!loadFrom: aByteArray	<primitive: 199>	self primitiveFailed.! !!ExternalBuffer methodsFor: 'as yet unclassified'!size	^ self basicSize.! !!ExternalBuffer methodsFor: 'as yet unclassified'!size: anInteger	size := anInteger.! !!ExternalBuffer methodsFor: 'as yet unclassified'!storeInto: aByteArray	<primitive: 218>	^ self class throwTypeConvertionError.! !!AsciiZ methodsFor: 'as yet unclassified'!asString	^ handle toString.! !!AsciiZ methodsFor: 'as yet unclassified'!asString2	| calcSize string |	size ifNil: [ ^ self class throwTypeConvertionError ].	calcSize := self strlen.	calcSize >= self size ifTrue: [ ^ self class throwTypeConvertionError ].	string := String new: calcSize.	self storeInto: string.	^ string! !!AsciiZ methodsFor: 'as yet unclassified'!loadFrom: aString		super loadFrom: aString.	self byteAt: (aString size + 1) put: 0.! !!AsciiZ methodsFor: 'as yet unclassified'!strlen	^ LibC6 default strLen: self.! !!ExternalFunction methodsFor: 'as yet unclassified'!library	^ library! !!ExternalFunction methodsFor: 'as yet unclassified'!library: aLibrary	library := aLibrary! !!ExternalFunction methodsFor: 'as yet unclassified'!name	^name! !!ExternalFunction methodsFor: 'as yet unclassified'!name: aName	name := aName! !!ExternalFunction methodsFor: 'as yet unclassified'!name: aName library: aLibrary	self name: aName.	self library: aLibrary! !!ExternalFunction methodsFor: 'as yet unclassified'!reload	library ifNil: [ ^ self throwNotKnownError ].	self handle: (library findFunction: self)! !!ExternalLibrary methodsFor: 'as yet unclassified'!bindFunction: function	| answer |	answer := self primitiveBindFunction: function.	answer ifNotNil: [ ^ answer ].	self open. "Library may be closed, open it and retry"	answer := self primitiveBindFunction: answer.	answer ifNotNil: [ ^ answer ].	^ function throwNotKnownError.		! !!ExternalLibrary methodsFor: 'as yet unclassified'!closeLibrary		(handle isNotNil and: [ handle isNull not ]) ifTrue: [ self primitiveClose ].	self handle: nil.	functionCache := nil.! !!ExternalLibrary methodsFor: 'as yet unclassified'!openLibrary		self primitiveOpen.	self initializeFunctionCache.! !!ExternalLibrary methodsFor: 'as yet unclassified'!primitiveBindFunction: function	"Primitive. Find the given symbol in the library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 203>	^ nil.! !!ExternalObject class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: self! !!ExternalObject class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalAddress! !!ExternalObject class methodsFor: 'as yet unclassified'!handleFromObject: anObject	^ self handleFromObject: anObject ifError: [ self throwTypeConvertionError ]! !!ExternalObject class methodsFor: 'as yet unclassified'!handleFromObject: anObject ifError: aBlock		(anObject isKindOf: ExternalObject) ifFalse: [ ^ aBlock value ].	^ anObject handle.	! !!ExternalObject class methodsFor: 'as yet unclassified'!initialize	Registry := WeakRegistry new.	Smalltalk addToShutDownList: self.! !!ExternalObject class methodsFor: 'as yet unclassified'!objectFromHandle: handle	^self objectFromHandle: handle ifError: [ self throwTypeConvertionError ]! !!ExternalObject class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; yourself! !!ExternalObject class methodsFor: 'as yet unclassified'!quit	Registry do: [ :each | each free ].	self allSubclassesDo: [ :ea | ea quit ]! !!ExternalObject class methodsFor: 'as yet unclassified'!shutDown: quitting	quitting ifTrue: [ self quit ].! !!ExternalObject class methodsFor: 'as yet unclassified'!throwTypeConvertionError	^ TypeConvertionError new signal! !!DynamicLibrary class methodsFor: 'as yet unclassified'!default	self = DynamicLibrary ifTrue: [ self error: 'Create a class to create its singleton' ].	default ifNil: [	"Represents the executable itself"		default := self new.		default name: self moduleName.		default open.	].	^ default.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!initialize	self = DynamicLibrary ifFalse: [ 		Smalltalk addToShutDownList: self	].! !!DynamicLibrary class methodsFor: 'as yet unclassified'!moduleName	self subClassResponsibility.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!resetLibrary	default := nil.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!shutDown: aBool	default ifNotNil: [ default close ].! !!Executable class methodsFor: 'as yet unclassified'!huemul	^ self default! !!Executable class methodsFor: 'as yet unclassified'!moduleName	^nil.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: ByteArray! !!ExternalBuffer class methodsFor: 'as yet unclassified'!fromByteArray: aByteArray	| anExternalBuffer |		anExternalBuffer := ExternalBuffer new: aByteArray size.	anExternalBuffer setFrom: aByteArray.	^ anExternalBuffer.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!handleFromObject: aByteArray ifError: aBlock		(aByteArray isKindOf: ByteArray) ifFalse: [ 		^ super handleFromObject: aByteArray ifError: aBlock	].	^ ( self fromByteArray: aByteArray ) handle.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!new: size	| anExternalBuffer |	"This space is allocated from the system not 	from Object Memory, you will have to give it back, 	as it is not garbage collected"	anExternalBuffer := LibC6 default malloc: (size +  10).	anExternalBuffer size: size.	^ anExternalBuffer! !!AsciiZ class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: String! !!AsciiZ class methodsFor: 'as yet unclassified'!fromString: aString	| anAsciiZ |		anAsciiZ := AsciiZ new: aString size + 1.	anAsciiZ loadFrom: aString.	^ anAsciiZ.! !!AsciiZ class methodsFor: 'as yet unclassified'!handleFromObject: aString ifError: aBlock		(aString isKindOf: String) ifFalse: [ 		^ super handleFromObject: aString ifError: aBlock	].	^ ( self fromString: aString ) handle.! !!AsciiZ class methodsFor: 'as yet unclassified'!new: size	| buffer asciiZ |	buffer := super new: size.	asciiZ := AsciiZ new handle: buffer handle.	asciiZ size: size.	asciiZ atAllPutZero.	buffer handle: ExternalAddress nullPointer.	^ asciiZ! !!AsciiZ class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; asString! !!ExternalFunction class methodsFor: 'as yet unclassified'!name: aName library: aLibrary	^self new name: aName library: aLibrary! !!ExternalLibrary class methodsFor: 'as yet unclassified'!huemul	Huemul ifNil: [	"Represents the executable itself"		Huemul := self new.		Huemul open.	].	^ Huemul.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!handle	self object ifNil: [ handle beNull ].	^ handle.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!initialize	super initialize.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!initializePointer	self handle forObject: self object.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!object	^ self objectPointer at: 1! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!object: anObject	self objectPointer at: 1 put: anObject.	self initializePointer.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!objectPointer	object ifNil: [ object := WeakArray new: 1 ].	^ object! !!ExternalArrayProxy methodsFor: 'as yet unclassified'!initializePointer	self handle forArray: self object.! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!fromObject: anObject		^ self new object: anObject; yourself! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!handleFromObject: anObject ifError: aBlock		^ ( self fromObject: anObject ) handle.! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		^ aBlock value! !!ExternalSymbol methodsFor: 'as yet unclassified'!address	handle isNull ifTrue: [ self bind ].	^ handle.! !!ExternalSymbol methodsFor: 'as yet unclassified'!bind	^ library bindSymbol: self.! !!ExternalSymbol methodsFor: 'as yet unclassified'!classFromType: aType	^ Smalltalk at: aType ifAbsent: [ self throwExternalSymbolError ].! !!ExternalSymbol methodsFor: 'as yet unclassified'!library	^ library! !!ExternalSymbol methodsFor: 'as yet unclassified'!library: aLibrary	library := aLibrary! !!ExternalSymbol methodsFor: 'as yet unclassified'!libraryName	^ library name.! !!ExternalSymbol methodsFor: 'as yet unclassified'!name	^name! !!ExternalSymbol methodsFor: 'as yet unclassified'!name: aName	name := aName! !!ExternalSymbol methodsFor: 'as yet unclassified'!name: aName library: aLibrary	self name: aName.	self library: aLibrary! !!ExternalSymbol methodsFor: 'as yet unclassified'!throwExternalSymbolError	^(ExternalSymbolError symbolName: name) signal.! !!ExternalSymbol methodsFor: 'as yet unclassified'!throwNotKnownError	^(ExternalSymbolError symbolName: name) signal.! !!ExecutableFunction methodsFor: 'as yet unclassified'!callingConventionString	self subclassResponsibility.! !!CDeclFunction methodsFor: 'as yet unclassified'!argTypes: anArrayOfTypes	argTypes := anArrayOfTypes.! !!CDeclFunction methodsFor: 'as yet unclassified'!callingConventionString	^ 'cdecl'! !!CDeclFunction methodsFor: 'as yet unclassified'!invoke	^self invokeWithArguments: #()! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1	^self invokeWithArguments: (Array with: arg1)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2	^self invokeWithArguments: (Array with: arg1 with: arg2)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4 with: arg5	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWithArguments: argArray	| argSize argHandleArray returnClass returnHandle |	argSize := argArray size.	argSize = argTypes size ifFalse: [ self throwExternalFunctionError ].	argHandleArray := Array new: argSize.	1 to: argSize do: [ :i |		| argType argClass argHandle arg |		argType := argTypes at: i.		argClass := self classFromType: argType.		arg := argArray at: i.		argHandle := argClass handleFromObject: arg.		argHandleArray at: i put: argHandle.	].	returnHandle := nil.	returnType = #Void ifFalse: [		returnClass := self classFromType: returnType.		returnHandle := returnClass defaultHandlerClass new.	].	handle isNull ifTrue: [ self bind ].	self primInvokeAnswering: returnHandle withArguments: argHandleArray.	returnType = #Void ifTrue: [ ^ nil ].	^ returnClass objectFromHandle: returnHandle.! !!CDeclFunction methodsFor: 'as yet unclassified'!primInvokeAnswering: aReturnValue withArguments: argArray	"Manually invoke the receiver, representing an external function."	<primitive: 204>	^self primitiveFailed! !!CDeclFunction methodsFor: 'as yet unclassified'!returnType: aType	returnType := aType.! !!CDeclFunction methodsFor: 'as yet unclassified'!returnType: aType argTypes: anArrayOfTypes	self returnType: aType.	self argTypes: anArrayOfTypes.! !!ExternalSymbol class methodsFor: 'as yet unclassified'!name: aName library: aLibrary	^self new name: aName library: aLibrary; bind! !!CDeclFunction class methodsFor: 'as yet unclassified'!name: aName library: aLibrary returnType: retType argTypes: argTypesArray	^self new name: aName library: aLibrary;		 returnType: retType argTypes: argTypesArray;		bind! !!ExternalSymbolError methodsFor: 'as yet unclassified'!isResumable	"Determine whether an exception is resumable."	^true! !!ExternalSymbolError methodsFor: 'as yet unclassified'!symbolName	^ symbolName! !!ExternalSymbolError methodsFor: 'as yet unclassified'!symbolName: argument	"Specify the function name that was beiing used."	symbolName := argument! !!ExternalSymbolError class methodsFor: 'as yet unclassified'!symbolName: argument	^self new symbolName: argument; yourself! !!FileDescriptor methodsFor: 'as yet unclassified'!close		self fileDescriptor > 2 ifTrue: [ 		LibC6 default close: self.		self fileDescriptor: -1.	]! !!FileDescriptor methodsFor: 'as yet unclassified'!fileDescriptor	^ SignedInteger objectFromHandle: handle. ! !!FileDescriptor methodsFor: 'as yet unclassified'!fileDescriptor: anInteger	handle := SignedInteger handleFromObject: anInteger. ! !!FileDescriptor methodsFor: 'as yet unclassified'!free		self close.! !!FileDescriptor methodsFor: 'as yet unclassified'!movePosition: offset"relative to actual position"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_CUR' ).	! !!FileDescriptor methodsFor: 'as yet unclassified'!position	^ self movePosition: 0.	! !!FileDescriptor methodsFor: 'as yet unclassified'!position: offset"absolute position"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_SET' ).! !!FileDescriptor methodsFor: 'as yet unclassified'!positionFromEnd: offset"relative to end of file"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_END' ).	! !!FileDescriptor methodsFor: 'as yet unclassified'!read: size	| retValue buffer |	buffer := ExternalBuffer new: size.	retValue := self readBuffer: buffer size: size.	! !!FileDescriptor methodsFor: 'as yet unclassified'!readBuffer: buffer size: size	^ LibC6 default read: self buffer: buffer size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!readString: aString	^ LibC6 default read: self string: aString size: aString size! !!FileDescriptor methodsFor: 'as yet unclassified'!readString: aString size: size	| internalSize |	internalSize := size.	aString size < size ifTrue: [ internalSize := aString size ].	^ LibC6 default read: self string: aString size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!size	| position size |	position := self position.	size := self positionFromEnd: 0.	self position: position.	^ size	! !!FileDescriptor methodsFor: 'as yet unclassified'!writeBuffer: buffer size: size	^ LibC6 default write: self buffer: buffer size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!writeString: aString	^ LibC6 default write: self string: aString size: aString size! !!FileDescriptor methodsFor: 'as yet unclassified'!writeString: aString size: size	| internalSize |	internalSize := size.	aString size < size ifTrue: [ internalSize := aString size ].	^ LibC6 default write: self string: aString size: size! !!FileDescriptor class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalValue! !!FileDescriptor class methodsFor: 'as yet unclassified'!initialize	self initializeStandardDescriptors! !!FileDescriptor class methodsFor: 'as yet unclassified'!initializeStandardDescriptors	StandardDescriptors := Dictionary new.	StandardDescriptors at: #stdout put: (self newFileDescriptor: 0).	StandardDescriptors at: #stdin put: (self newFileDescriptor: 1).	StandardDescriptors at: #stderr put: (self newFileDescriptor: 2).! !!FileDescriptor class methodsFor: 'as yet unclassified'!newFileDescriptor: anInteger	^ self new fileDescriptor: anInteger; yourself.! !!FileDescriptor class methodsFor: 'as yet unclassified'!standardDescriptors	^ StandardDescriptors! !!FileDescriptor class methodsFor: 'as yet unclassified'!stderr	^ StandardDescriptors at: #stderr.! !!FileDescriptor class methodsFor: 'as yet unclassified'!stdin	^ StandardDescriptors at: #stdin.! !!FileDescriptor class methodsFor: 'as yet unclassified'!stdout	^ StandardDescriptors at: #stdout.! !!FileStream methodsFor: 'as yet unclassified'!atEnd	"Answer true if the current position is >= the end of file position.	 1/31/96 sw: subclassResponsibility"	self subclassResponsibility! !!FileStream class methodsFor: 'as yet unclassified'!fileDoesNotExistUserHandling: fullFileName	(GtkMessageDialog question: fullFileName, ' does not exist, create it?') = #yes		ifTrue: [ ^ self new open: fullFileName forWrite: true ].! !!FileStream class methodsFor: 'as yet unclassified'!fileExistsUserHandling: fullFileName	(GtkMessageDialog question: fullFileName, ' exist, overwrite it?') = #yes		ifTrue: [ ^ self new openForOverwrite: fullFileName ].! !!FileStream class methodsFor: 'as yet unclassified'!readOnlyFileDoesNotExistUserHandling: fullFileName	GtkMessageDialog error: fullFileName, ' does not exist'! !!FileDoesNotExistException methodsFor: 'as yet unclassified'!defaultAction	"The default action taken if the exception is signaled."	^self readOnly		ifTrue: [FileStream readOnlyFileDoesNotExistUserHandling: self fileName]		ifFalse: [FileStream fileDoesNotExistUserHandling: self fileName]! !!GIRBuilder methodsFor: 'as yet unclassified'!compiledMethod	| bytecodes |	bytecodes := self bytecodes.	bytecodes ifNil: [ ^ nil ].	^ CompiledMethod new		primitive: 0;		numArgs: self numArgs;		numTemps: self numTemps;		literals: self literals;		relocationInfo: self relocationInfo;		bytecodes: bytecodes;		debugInfo: debugInfo;		source: source;		relocate.! !!GPointer methodsFor: 'as yet unclassified'!initialize	handle := self class defaultHandlerClass new.! !!GPointer class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalAddress! !!GPointer class methodsFor: 'as yet unclassified'!handle: aByteArray	^self basicNew handle: aByteArray; yourself! !!GObject class methodsFor: 'as yet unclassified'!handleFromObject: object	^ object handle.	! !!Gtk methodsFor: 'as yet unclassified'!initialize	self initializeGtkLibrary.	self startMainLoop.! !!Gtk class methodsFor: 'as yet unclassified'!shutDown: quiting	"Quits the Gtk main loop"	Default ifNotNil: [		Default quitMainLoop.		Default close.		Default := nil.	].! !!GtkDemoStockIds methodsFor: 'as yet unclassified'!initialize	| model tree |	model := GtkListStore new: {String. String. String. String}.	GtkStockItem allStocks do: [ :ea |		ea ifNotNil: [			model append: {				ea stockId asGtkStockId.				ea stockId.				ea label.				Gtk acceleratorName: ea keyval asCharacter modifier: ea modifier}]].	tree := GtkTreeView model: model.	self createFirstColumn: tree.	tree appendColumns: {		GtkTreeViewColumn title: 'Label' text: 2.		GtkTreeViewColumn title: 'Accel' text: 3.		GtkTreeViewColumn title: 'ID' text: 0}.	tree selection when: #changed send: #onItemChanged: to: self withArgumentsFirst: {tree}.			self container: (GtkHBox spacing: 5).	self container		packStart: (GtkScrolledWindow withChild: tree);		packEnd: self createInfoFrame expand: false fill: false! !!GtkDemoStockIds methodsFor: 'as yet unclassified'!onItemChanged: aTreeView	aTreeView selectedRow in: [:row |		idLabel label: row first.		nameLabel label: '#', row second.		accelLabel label: row third.		iconImage stock: row second iconSize: #dialog]! !!InMidstOfFileinNotification methodsFor: 'as yet unclassified'!defaultAction	^ self resume: false! !!LibC methodsFor: 'as yet unclassified'!closeLibrary	cLibrary closeLibrary.	cLibrary := nil.! !!LibC methodsFor: 'as yet unclassified'!initializeCLibrary	cLibrary := ExternalLibrary new.	cLibrary name: 'libc.so.6'.	cLibrary openLibrary.! !!LibC class methodsFor: 'as yet unclassified'!shutDown: quiting	"Quits the Gtk main loop"	self default closeLibrary.	Default := nil.! !!LibC6 methodsFor: 'as yet unclassified'!close: fd	| retValue |	retValue := ( self cDeclFunctionNamed: #close ) invokeWith: fd.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #close ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!errno	^ (self libraryDataNamed: #errno) value.	! !!LibC6 methodsFor: 'as yet unclassified'!errno: errno	(self libraryDataNamed: #errno) value: errno.	! !!LibC6 methodsFor: 'as yet unclassified'!free: anExternalBuffer	( self cDeclFunctionNamed: #free ) invokeWith: anExternalBuffer.	! !!LibC6 methodsFor: 'as yet unclassified'!getCurrentDirName	| retValue |	[ retValue := ( self cDeclFunctionNamed: 'get_current_dir_name' asSymbol ) invoke ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: 'get_current_dir_name' asSymbol ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!getEnv: envVariable	^ ( self cDeclFunctionNamed: #getenv ) invokeWith: envVariable.! !!LibC6 methodsFor: 'as yet unclassified'!getpid	^ (self cDeclFunctionNamed: #getpid) invoke.	! !!LibC6 methodsFor: 'as yet unclassified'!initialize	super initialize.	self initializeUniStd.	self initializeStdLib.	self initializeString.	self initializeFCntl.	self initializeStdIO.	self initializeErrNO.! !!LibC6 methodsFor: 'as yet unclassified'!initializeErrNO	self initializeLibraryDataNamed: #errno type: #SignedInteger.! !!LibC6 methodsFor: 'as yet unclassified'!initializeFCntl	self initializeCDeclFunctionNamed: #open returnType: #FileDescriptor argTypes: #( AsciiZ SignedInteger UnsignedInteger ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeStdIO	self initializeCDeclFunctionNamed: #printf  returnType: #SignedInteger argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: #perror  returnType: #Void argTypes: #( AsciiZ  ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeStdLib	self initializeCDeclFunctionNamed: #malloc  returnType: #ExternalBuffer argTypes: #( UnsignedInteger  ).	self initializeCDeclFunctionNamed: #free  returnType: #Void argTypes: #( ExternalBuffer  ).	self initializeCDeclFunctionNamed: #getenv  returnType: #AsciiZ argTypes: #( AsciiZ ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeString	self initializeCDeclFunctionNamed: #strlen returnType: #UnsignedInteger argTypes: #( AsciiZ ).	self initializeCDeclFunctionNamed: #strcat returnType: #AsciiZ argTypes: #( AsciiZ AsciiZ ).	self initializeCDeclFunctionNamed: #strcpy returnType: #AsciiZ argTypes: #( AsciiZ AsciiZ ).	self initializeCDeclFunctionNamed: #strerror returnType: #ReadOnlyAsciiZ argTypes: #( SignedInteger ).	self initializeCDeclFunctionNamed: #memset returnType: #ExternalBuffer argTypes: #( ExternalBuffer SignedInteger  UnsignedInteger ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeUniStd	self initializeCDeclFunctionNamed: #getpid  returnType: #UnsignedInteger argTypes: #().	self initializeCDeclFunctionNamed: 'get_current_dir_name' asSymbol  returnType: #AsciiZ argTypes: #().	self initializeCDeclFunctionNamed: #close  returnType: #SignedInteger argTypes: #( FileDescriptor ).	self initializeCDeclFunctionNamed: #lseek  returnType: #UnsignedInteger argTypes: #( FileDescriptor UnsignedInteger SignedInteger ).	self initializeCDeclFunctionNamed: #read  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalBuffer UnsignedInteger ).	self initializeCDeclFunctionNamed: #write  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalBuffer UnsignedInteger )."Redefinition of read for Strings"	symbolCache at: #readString put: (CDeclFunction name: #read library: self  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalArrayProxy UnsignedInteger ) )."Redefinition of write for Strings"	symbolCache at: #writeString put: (CDeclFunction name: #write library: self  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalArrayProxy UnsignedInteger ) ).! !!LibC6 methodsFor: 'as yet unclassified'!lseek: fileDescriptor offset: offset whence: whence	| returnValue |	returnValue := (self cDeclFunctionNamed: #lseek) invokeWith: fileDescriptor with: offset with: whence.	returnValue < 0 ifTrue: [		self throwErrorForExternalFunctionNamed: #lseek.		^ nil.	].	^ returnValue.	! !!LibC6 methodsFor: 'as yet unclassified'!malloc: size	| retValue |	[ retValue := ( self cDeclFunctionNamed: #malloc ) invokeWith: size ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: #malloc withMessage: 'can not allocate memory' ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!memSet: buffer constant: c count: n	^ (self cDeclFunctionNamed: #memset) invokeWith: buffer with: c with: n.	! !!LibC6 methodsFor: 'as yet unclassified'!open: path flags: flags	^ self open: path flags: flags mode: 8r644	! !!LibC6 methodsFor: 'as yet unclassified'!open: path flags: flags mode: mode	| fileDescriptor |	fileDescriptor := (self cDeclFunctionNamed: #open) invokeWith: path with: flags with: mode.	fileDescriptor fileDescriptor < 0 ifTrue: [		self throwErrorForExternalFunctionNamed: #open.		^ nil.	].	^ fileDescriptor.	! !!LibC6 methodsFor: 'as yet unclassified'!perror: aString	( self cDeclFunctionNamed: #perror ) invokeWith: aString.	! !!LibC6 methodsFor: 'as yet unclassified'!printf: aString	^ ( self cDeclFunctionNamed: #printf ) invokeWith: aString.	! !!LibC6 methodsFor: 'as yet unclassified'!read: fd buffer: buffer size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #read ) invokeWith: fd with: buffer with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #read ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!read: fd string: aString size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #readString ) invokeWith: fd with: aString with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #readString ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!strCat: destString with: sourceString	^ ( self cDeclFunctionNamed: #strcat ) invokeWith: destString with: sourceString.	! !!LibC6 methodsFor: 'as yet unclassified'!strCpy: destString with: sourceString	^ ( self cDeclFunctionNamed: #strcpy ) invokeWith: destString with: sourceString.	! !!LibC6 methodsFor: 'as yet unclassified'!strError: errno	| retValue |	[ retValue := ( self cDeclFunctionNamed: #strerror ) invokeWith: errno ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: #strerror ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!strLen: string	^ ( self cDeclFunctionNamed: #strlen ) invokeWith: string	! !!LibC6 methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName	^ self throwErrorForExternalFunctionNamed: functionName withMessage: (self strError: self errno).	! !!LibC6 methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName withMessage: aString	| error |	error := ExternalFunctionError functionName: functionName.	error messageText: aString.	^ error signal.	! !!LibC6 methodsFor: 'as yet unclassified'!valueForLSeekDirectiveNamed: aString	^ LSeekDirectives at: aString asSymbol.	! !!LibC6 methodsFor: 'as yet unclassified'!valueForOpenFlagNamed: aString	^ OpenFlags at: aString asSymbol.	! !!LibC6 methodsFor: 'as yet unclassified'!write: fd buffer: buffer size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #write ) invokeWith: fd with: buffer with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #write ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!write: fd string: aString size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #writeString ) invokeWith: fd with: aString with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #writeString ].	^ retValue.	! !!LibC6 class methodsFor: 'as yet unclassified'!initialize	self initializeOpenFlags.	self initializeLSeekDirectives.! !!LibC6 class methodsFor: 'as yet unclassified'!initializeLSeekDirectives	| lSeekDirectives |		lSeekDirectives := Dictionary new.	lSeekDirectives at: 'SEEK_SET' put: 0.	lSeekDirectives at: 'SEEK_CUR' put: 1.	lSeekDirectives at: 'SEEK_END' put: 2.	LSeekDirectives := lSeekDirectives! !!LibC6 class methodsFor: 'as yet unclassified'!initializeOpenFlags	| flagArray openFlags |		flagArray := #( 		('O_RDONLY'		0)		('O_WRONLY'		8r1)		('O_RDWR'		8r2)		('O_CREAT'		8r100)			('O_EXCL'			8r200)			('O_NOCTTY'		8r400)			('O_TRUNC'		8r1000)			('O_APPEND'		8r2000)		('O_NONBLOCK'	8r4000)		('O_SYNC'		8r10000)		('O_ASYNC'		8r20000)	).	openFlags := Dictionary new.	flagArray do: [ :i |		openFlags at: i first asSymbol put: i second	].	OpenFlags := openFlags! !!LibC6 class methodsFor: 'as yet unclassified'!moduleName	^ 'libc.so.6'.! !!LibExample methodsFor: 'as yet unclassified'!getpid	^ GETPID invoke! !!LibExample class methodsFor: 'as yet unclassified'!getpid	^ GETPID! !!LibExample class methodsFor: 'as yet unclassified'!initialize	GETPID := CDeclFunction name: 'getpid' libraryNamed: 'libc.so.6' returnType: #UnsignedInteger argTypes: #().! !!LibReadLine methodsFor: 'as yet unclassified'!addHistory: aString	( self cDeclFunctionNamed: 'add_history' asSymbol ) invokeWith: aString.! !!LibReadLine methodsFor: 'as yet unclassified'!initialize	super initialize.	self initializeCDeclFunctionNamed: #readline  returnType: #AsciiZ argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'add_history' asSymbol returnType: #Void argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'read_history' asSymbol returnType: #SignedInteger argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'write_history' asSymbol returnType: #SignedInteger argTypes: #( AsciiZ  ).! !!LibReadLine methodsFor: 'as yet unclassified'!readHistory: aFileName	| errno |	errno := ( self cDeclFunctionNamed: 'read_history' asSymbol ) invokeWith: aFileName.	errno = 0 ifFalse: [ self throwErrorForExternalFunctionNamed: 'read_history' asSymbol errno: errno ].	^ errno.! !!LibReadLine methodsFor: 'as yet unclassified'!readline: prompt	^ ( self cDeclFunctionNamed: #readline ) invokeWith: prompt.! !!LibReadLine methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName errno: errno	| error |	error := ExternalFunctionError functionName: functionName.	error messageText: (LibC6 default strError: errno).	^ error signal.! !!LibReadLine methodsFor: 'as yet unclassified'!writeHistory: aFileName	| errno |	errno := ( self cDeclFunctionNamed: 'write_history' asSymbol ) invokeWith: aFileName.	errno = 0 ifFalse: [ self throwErrorForExternalFunctionNamed: 'write_history' asSymbol errno: errno ].	^ errno.! !!LibReadLine class methodsFor: 'as yet unclassified'!moduleName	^ 'libreadline.so.5'.! !!LibraryData methodsFor: 'as yet unclassified'!primitiveGetValue: valueHandle	<primitive: 216>	^self primitiveFailed! !!LibraryData methodsFor: 'as yet unclassified'!primitiveSetValue: valueHandle	<primitive: 217>	^self primitiveFailed! !!LibraryData methodsFor: 'as yet unclassified'!type	^ type.! !!LibraryData methodsFor: 'as yet unclassified'!type: aType	type := aType.! !!LibraryData methodsFor: 'as yet unclassified'!value	| valueClass valueHandle |	valueClass := self classFromType: type.	valueHandle := valueClass defaultHandlerClass new.	handle isNull ifTrue: [ self bind ].	self primitiveGetValue: valueHandle.	^ valueClass objectFromHandle: valueHandle.! !!LibraryData methodsFor: 'as yet unclassified'!value: aValue	| argHandle argClass |	argClass := self classFromType: type.	argHandle := argClass handleFromObject: aValue.	handle isNull ifTrue: [ self bind ].	self primitiveSetValue: argHandle! !!LibraryData class methodsFor: 'as yet unclassified'!name: aName library: aLibrary type: type	^self new name: aName library: aLibrary;		type: type;		bind! !!Metaclass methodsFor: 'as yet unclassified'!addObsoleteSubclass: aClass	"Do nothing."! !!Metaclass methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return true if it is safe to zap the method dictionary on #obsolete"	thisClass == nil		ifTrue:[^true]		ifFalse:[^thisClass canZapMethodDictionary]! !!Metaclass methodsFor: 'as yet unclassified'!isSystemDefined	"Answer false if I am a UniClass (an instance-specific lightweight class)"	^ true! !!NativeFunction methodsFor: 'as yet unclassified'!callingConventionString	^ 'native'! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver	^self invokeReceiver: receiver withArguments: #()! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1	^self invokeReceiver: receiver withArguments: (Array with: arg1)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4 with: arg5	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver withArguments: argArray	handle isNull ifTrue: [ self bind ].	^ self primInvokeReceiver: receiver withArguments: argArray.! !!NativeFunction methodsFor: 'as yet unclassified'!primInvokeReceiver: receiver withArguments: argArray	"Manually invoke the receiver, representing an native function."	<primitive: 197>	^self primitiveFailed! !!ObjectTest methodsFor: 'as yet unclassified'!testBecome	"self debug: #testBecome"	"this test should that all the variables pointing to an object are pointing now to another one, and all      object pointing to the other are pointing to the object"	| pt1 pt2 pt3 |	pt1 := 0@0.	pt2 := pt1.	pt3 := 100@100.	pt1 become: pt3.	self assert: pt2 = (100@100).	self assert: pt3 = (0@0).	self assert: pt1 = (100@100).! !!ObjectTest methodsFor: 'as yet unclassified'!testBecomeForward	"self debug: #testBecomeForward"	"this test should that all the variables pointing to an object are pointing now to another one.	Not that this inverse is not true. This kind of become is called oneWayBecome in VW"	| pt1 pt2 pt3 |	pt1 := 0@0.	pt2 := pt1.	pt3 := 100@100.	pt1 becomeForward: pt3.	self assert: pt2 = (100@100).	self assert: pt3 == pt2.	self assert: pt1 = (100@100)! !!PrimitiveType class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalValue! !!PrimitiveType class methodsFor: 'as yet unclassified'!handleFromObject: anObject	^ self handleFromObject: anObject ifError: [ self throwTypeConvertionError ]! !!PrimitiveType class methodsFor: 'as yet unclassified'!handleFromObject: object ifError: aBlock	self subclassResponsibility.! !!PrimitiveType class methodsFor: 'as yet unclassified'!objectFromHandle: handle	^ self objectFromHandle: handle ifError: [  self throwTypeConvertionError ]! !!PrimitiveType class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock	self subclassResponsibility.! !!PrimitiveType class methodsFor: 'as yet unclassified'!throwTypeConvertionError	^ TypeConvertionError new signal! !!IntegerType class methodsFor: 'as yet unclassified'!handleFromObject: anInteger ifError: aBlock	| handle |		(self checkType: anInteger) ifFalse: [ ^ aBlock value ].	handle := ExternalValue new.	self store: anInteger in: handle.	^ handle.	! !!IntegerType class methodsFor: 'as yet unclassified'!isBigEndian	^  false! !!IntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	self subclassResponsibility.! !!IntegerType class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: errorBlock	| value |		value := self loadFrom: handle.	(value > self max ) ifTrue: [ ^ errorBlock value ].	^ value.! !!Process methodsFor: 'as yet unclassified'!primitiveBeInitialProcess	<primitive: 196>	self primitiveFailed! !!ProcessorScheduler methodsFor: 'as yet unclassified'!activeProcess	^ self primActiveProcess! !!ProcessorScheduler methodsFor: 'as yet unclassified'!primActiveProcess	<primitive: 195>	self primitiveFail.! !!ProcessorScheduler methodsFor: 'as yet unclassified'!startUp	| firstProcess |"	(processList isNil or: [ processList isEmpty not ]) ifTrue: [ self initialize ]."	self initialize.	firstProcess := Process new.	firstProcess name: 'Init'.	firstProcess priority: self userSchedulingPriority.	firstProcess state: #running."	firstProcess threadData: self activeThreadData."	firstProcess primitiveBeInitialProcess.! !!ReadOnlyAsciiZ methodsFor: 'as yet unclassified'!asString	^ handle toString.! !!ReadOnlyAsciiZ class methodsFor: 'as yet unclassified'!handleFromObject: aByteArray ifError: aBlock	"Can not be used as arguments"	aBlock value.! !!ReadOnlyAsciiZ class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; asString! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!addressRelativeTo: bytecodes	| functionAddress bytecodesAddress |	functionAddress := self function address asInteger.	bytecodesAddress := (ExternalAddress forArray: bytecodes ) asInteger.	^ functionAddress - bytecodesAddress - offset - 4! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!function	^ self library functionNamed: functionName.! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!functionName	^ functionName! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!functionName: aSymbol	^ functionName := aSymbol! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!library	^ Executable default! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!patch: bytecodes	self patch: bytecodes with: (self addressRelativeTo: bytecodes).! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!patch: bytecodes with: value	bytecodes longAt: (offset + 1) put: value bigEndian: false.! !!FunctionRelocation methodsFor: 'as yet unclassified'!addressRelativeTo: bytecodes	^ self primAddressRelativeTo: bytecodes! !!FunctionRelocation methodsFor: 'as yet unclassified'!primAddressRelativeTo: bytecodes	<primitive: 155>	self primitiveFail.! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!defaultLibraryClass	^ NativeLibrary! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!library 		^ self defaultLibraryClass named: libraryName! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!libraryName	^ libraryName! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!libraryName: aSymbol	^ libraryName := aSymbol! !!ExternalFunctionRelocation methodsFor: 'as yet unclassified'!defaultLibraryClass	^ ExternalLibrary2! !!SequenceableCollection methodsFor: 'as yet unclassified'!asTraitComposition	"For convenience the composition {T1. T2 ...} is the same as T1 + T2 + ..."	^self isEmpty		ifFalse: [			self size = 1				ifTrue: [self first asTraitComposition]				ifFalse: [					self copyWithoutFirst 						inject: self first						into: [:left :right | left + right]]]		ifTrue: [			TraitComposition new]! !!Array methodsFor: 'as yet unclassified'!elementsExchangeIdentityWith: otherArray	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsExchangeIdentityWith: otherArray.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!elementsForwardIdentityTo: otherArray	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsForwardIdentityTo: otherArray.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!elementsForwardIdentityTo: otherArray copyHash: copyHash	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsForwardIdentityTo: otherArray copyHash: copyHash.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!primElementsExchangeIdentityWith: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  At the same time, all pointers to the elements of otherArray are replaced by pointers to the corresponding elements of this array.  The identityHashes remain with the pointers rather than with the objects so that objects in hashed structures should still be properly indexed after the mutation."	<primitive: 128>	otherArray class == Array ifFalse: [^ self error: 'arg must be array'].	self size = otherArray size ifFalse: [^ self error: 'arrays must be same size'].	(self anySatisfy: [:obj | obj class == SmallInteger]) ifTrue: [^ self error: 'can''t become SmallIntegers'].	(otherArray anySatisfy: [:obj | obj class == SmallInteger]) ifTrue: [^ self error: 'can''t become SmallIntegers'].	"Must have failed because not enough space in forwarding table (see ObjectMemory-prepareForwardingTableForBecoming:with:twoWay:).  Do GC and try again only once"	(Smalltalk bytesLeft: true) = Smalltalk primitiveGarbageCollect		ifTrue: [^ self primitiveFailed].	^ self elementsExchangeIdentityWith: otherArray! !!Array methodsFor: 'as yet unclassified'!primElementsForwardIdentityTo: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  The identityHashes remain with the pointers rather than with the objects so that the objects in this array should still be properly indexed in any existing hashed structures after the mutation."	<primitive: 72>	self primitiveFailed! !!Array methodsFor: 'as yet unclassified'!primElementsForwardIdentityTo: otherArray copyHash: copyHash	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  The identityHashes remain with the pointers rather than with the objects so that the objects in this array should still be properly indexed in any existing hashed structures after the mutation."	<primitive: 249>	self primitiveFailed! !!ExternalValue methodsFor: 'as yet unclassified'!beNull	"Make the receiver a NULL pointer"	self atAllPut: 0.! !!ExternalValue methodsFor: 'as yet unclassified'!isNull	^(self basicAt: 1) = 0	and: (self basicAt: 2) = 0	and: (self basicAt: 3) = 0	and: (self basicAt: 4) = 0	! !!ExternalValue class methodsFor: 'as yet unclassified'!initialize	Smalltalk addToStartUpList: self.! !!ExternalValue class methodsFor: 'as yet unclassified'!new	"External addresses are always 4 bytes long"	^super new: 4! !!ExternalValue class methodsFor: 'as yet unclassified'!new: n	"You better don't try this..."	^self shouldNotImplement! !!ExternalValue class methodsFor: 'as yet unclassified'!startUp: resuming	resuming ifTrue: [		self allInstancesDo: [ :addr |			addr beNull		]	].! !!SharedPool class methodsFor: 'as yet unclassified'!bindingOf: varName	"Answer the binding of some variable resolved in the scope of the receiver"	| aSymbol binding |	aSymbol := varName asSymbol.	"First look in classVar dictionary."	binding := self classPool bindingOf: aSymbol.	binding ifNotNil:[^binding].	"Next look in shared pools."	self sharedPools do:[:pool | 		binding := pool bindingOf: aSymbol.		binding ifNotNil:[^binding].	].	"subclassing and environment are not preserved"	^nil! !!SharedPool class methodsFor: 'as yet unclassified'!bindingsDo: aBlock	^self classPool bindingsDo: aBlock! !!SharedPool class methodsFor: 'as yet unclassified'!classBindingOf: varName	"For initialization messages grant the regular scope"	^super bindingOf: varName! !!SharedPool class methodsFor: 'as yet unclassified'!hasBindingThatBeginsWith: aString	"Answer true if the receiver has a binding that begins with aString, false otherwise"	"First look in classVar dictionary."	(self classPool hasBindingThatBeginsWith: aString) ifTrue:[^true].	"Next look in shared pools."	self sharedPools do:[:pool | 		(pool hasBindingThatBeginsWith: aString) ifTrue: [^true]].	^false! !!SharedPool class methodsFor: 'as yet unclassified'!includesKey: aName	"does this pool include aName"	^(self bindingOf: aName) notNil! !!SharedPool class methodsFor: 'as yet unclassified'!keysDo: aBlock"A hopefully temporary fix for an issue arising from miss-spelled variable names in code being compiled. The correction code (see Class>possibleVariablesFor:continuedFrom: assumes that sharedPools are Dictionaries. The proper fix would involve making sure all pools are actually subclasses of SharedPool, which they are not currently."	self bindingsDo:[:b|		aBlock value: b key]! !!Shell methodsFor: 'as yet unclassified'!display: string	| buffer |		buffer := AsciiZ fromString: string.	^ FileDescriptor stdout writeBuffer: buffer size: buffer size.! !!Shell methodsFor: 'as yet unclassified'!input: prompt	^ LibReadLine default readline: prompt! !!Shell methodsFor: 'as yet unclassified'!main	| line value failed anotherLine buffer |	LibReadLine default readHistory: self historyFileName.	[		anotherLine := false.		buffer := ''.		[ 	| prompt |			prompt := anotherLine ifTrue: [ '' ] ifFalse: [ '> ' ].			line _ self input: prompt.			line isEmpty				ifTrue: [ true ] 				ifFalse: [					(line last = $\)						ifTrue: [							anotherLine := true.							line at: line size put: Character lf.						]						ifFalse: [ anotherLine := false ].					buffer := buffer, line.					anotherLine				]		] whileTrue. 		buffer = 'quit' or: [ buffer = 'save' ]	] whileFalse: [		self addToHistory: buffer.		failed _ false.		value _ Compiler new evaluate: buffer in: nil to: nil notifying: self ifFail: [ failed _ true].		failed ifFalse: [ self display: (value printString); lf ]	].	LibReadLine default writeHistory: self historyFileName.	buffer = 'save' ifTrue: [ Smalltalk snapshotAndQuit ].	^value.! !!SignedIntegerType class methodsFor: 'as yet unclassified'!checkType: value	^ value isInteger and: [ value >= self min and: [ value <= self max ] ]! !!SignedIntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	^ handle longAt: 1 bigEndian: self isBigEndian.! !!SignedIntegerType class methodsFor: 'as yet unclassified'!store: anInteger in: handle	handle longAt: 1 put: anInteger bigEndian: self isBigEndian.! !!SignedByte class methodsFor: 'as yet unclassified'!max			^ 127! !!SignedByte class methodsFor: 'as yet unclassified'!min			^ -128! !!SignedInteger class methodsFor: 'as yet unclassified'!max			^ 2147483647! !!SignedInteger class methodsFor: 'as yet unclassified'!min			^ -2147483648! !!SignedShortInteger class methodsFor: 'as yet unclassified'!max			^ 32767! !!SignedShortInteger class methodsFor: 'as yet unclassified'!min			^ -32768! !!SourceReference methodsFor: 'as yet unclassified'!sourceFrom: aString	self hasEmptySourceReference ifTrue: [ ^ '' ].	^ aString copyFrom: sourceStart to: sourceStop! !!StandardFileStream class methodsFor: 'as yet unclassified'!retryWithGC: execBlock until: testBlock forFileNamed: fullName	"Re-implemented to only force GC if a file with the given name exists"	| blockValue foundIt |	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	"See if we have a file with the given name"	foundIt := self registry keys "hold on strongly for now" 		anySatisfy:[:file| file name sameAs: fullName].	foundIt ifFalse:[^blockValue].	Smalltalk garbageCollectMost.	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollect.	^execBlock value.! !!SystemDictionary methodsFor: 'as yet unclassified'!forgetClass: aClass logged: aBool 	"Delete the class, aClass, from the system.	Note that this doesn't do everything required to dispose of a class - to do that use Class>>removeFromSystem."	aBool ifTrue: [SystemChangeNotifier uniqueInstance classRemoved: aClass fromCategory: aClass category].			SystemOrganization removeElement: aClass name.	self removeFromStartUpList: aClass.	self removeFromShutDownList: aClass.	self removeKey: aClass name ifAbsent: [].	self flushClassNameCache! !!SystemDictionary methodsFor: 'as yet unclassified'!removeClassNamed: aName	"Invoked from fileouts:  if there is currently a class in the system named aName, then remove it.  If anything untoward happens, report it in the Transcript.  "	| oldClass |	(oldClass _ self at: aName asSymbol ifAbsent: [nil]) == nil		ifTrue:			[Transcript cr; show: 'Removal of class named ', aName, ' ignored because ', aName, ' does not exist.'.			^ self].	oldClass removeFromSystem! !!SystemDictionary methodsFor: 'as yet unclassified'!startUp	Processor startUp.	ProcessorScheduler startUp.	self processStartUpList: true.	self installLowSpaceWatcher.! !!SystemTracer methodsFor: 'as yet unclassified'!getAligned: size	^ (( size + 3 ) bitShift: -2) bitShift: 2.! !!TraitBehavior methodsFor: 'as yet unclassified'!addUser: aClassOrTrait	users add: aClassOrTrait! !!TraitBehavior methodsFor: 'as yet unclassified'!classesComposedWithMe	^users gather: [:u | u classesComposedWithMe]! !!TraitBehavior methodsFor: 'as yet unclassified'!initialize	self methodDict: Dictionary new.	self traitComposition: nil.	users _ IdentitySet new.! !!TraitBehavior methodsFor: 'as yet unclassified'!removeUser: aClassOrTrait	users remove: aClassOrTrait ifAbsent: []! !!TraitBehavior methodsFor: 'as yet unclassified'!users	^users! !!TraitComposition methodsFor: 'as yet unclassified'!assertValidUser: aBehavior	"Assert that this trait composition set for aBehavior	does not introduce a cycle."		(self allTraits includes: aBehavior) ifTrue: [		TraitCompositionException signal: 'Cycle in compositions:  The composition (in)directly includes this trait!!']! !!TraitComposition methodsFor: 'as yet unclassified'!methodDescriptionsForSelector: aSymbol	"Return a collection of TraitMethodDescriptions for aSymbol and all the 	aliases of aSymbol."	| selectors collection |	selectors _ IdentitySet with: aSymbol.	self transformations do: [:each |		selectors addAll: (each aliasesForSelector: aSymbol)].	collection _ OrderedCollection new: selectors size.	selectors do: [:each |		collection add: (self methodDescriptionForSelector: each)].	^collection! !!TraitDescription methodsFor: 'as yet unclassified'!trait	"for compatibility with TraitTransformations"	^ self! !!TraitDescription methodsFor: 'as yet unclassified'!updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil	| currentCategory effectiveCategory sel changedCategories composition |	changedCategories _ IdentitySet new.	composition := self hasTraitComposition		ifTrue: [self traitComposition]		ifFalse: [TraitComposition new].	(composition methodDescriptionsForSelector: aSymbol) do: [:each |		sel _ each selector.		(self includesLocalSelector: sel) ifFalse: [			currentCategory _ self organization categoryOfElement: sel.			effectiveCategory _ each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.			effectiveCategory isNil ifTrue: [				currentCategory ifNotNil: [changedCategories add: currentCategory].				self organization removeElement: sel.			] ifFalse: [				((currentCategory isNil or: [currentCategory == ClassOrganizer ambiguous or: [currentCategory == oldCategoryOrNil]]) and: [currentCategory ~~ effectiveCategory]) ifTrue: [					currentCategory ifNotNil: [changedCategories add: currentCategory].					self organization 						classify: sel 						under: effectiveCategory						suppressIfDefault: false]]]].	^ changedCategories! !!TraitDescription methodsFor: 'as yet unclassified'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	(self includesSelector: aSelector)		ifTrue: [^ self organization categoryOfElement: aSelector]		ifFalse: [^nil]! !!Trait methodsFor: 'as yet unclassified'!initialize	super initialize.	classTrait _ ClassTrait for: self! !!TranscriptCodeView class methodsFor: 'as yet unclassified'!initialize	Smalltalk addToStartUpList: self.! !!TranscriptCodeView class methodsFor: 'as yet unclassified'!startUp: resuming	resuming ifTrue: [		TranscriptCodeBuffer := nil.	].! !!TranscriptStream methodsFor: 'as yet unclassified'!open	TranscriptCodeEditor open.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!atEnd	position ifNil: [ ^ nil ].	^ position >= readLimit! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!close	"Close this file."	fileID ifNotNil: [		fileID close.		fileID := nil.		position := nil.	].! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!open: fileName flags: flags	[ fileID := LibC6 default open: fileName flags: flags ]		on: ExternalFunctionError		do: [ ^ nil ].	name := fileName.	readLimit := fileID size.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!open: fileName forWrite: writeMode 	| flags |	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	flags := writeMode 		ifTrue: [ LibC6 default valueForOpenFlagNamed: 'O_RDWR' ]		ifFalse: [ LibC6 default valueForOpenFlagNamed: 'O_RDONLY' ].	rwmode := writeMode.	^ self open: fileName flags: flags.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!openForOverwrite: fileName	| flags |	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	flags := ((LibC6 default valueForOpenFlagNamed: 'O_RDWR') 			bitOr: ( LibC6 default valueForOpenFlagNamed: 'O_TRUNC' )) 			bitOr: ( LibC6 default valueForOpenFlagNamed: 'O_CREAT' ).	rwmode := true.	^ self open: fileName flags: flags.! !!BufferedFileStream methodsFor: 'as yet unclassified'!close	"Close this file."	self flush.	^ super close.! !!BufferedFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	self subclassResponsibility! !!BufferedFileStream methodsFor: 'as yet unclassified'!defaultBufferSize	^ DefaultBufferSize.! !!BufferedFileStream methodsFor: 'as yet unclassified'!flush	| bufferPosition bufferSize |	fileID ifNil: [ ^ nil ].	rwmode ifFalse: [ ^ nil ].	bufferPosition := position truncateTo: (collection size).	bufferSize := collection size min: ( readLimit - bufferPosition).	fileID position: bufferPosition.	bufferSize > 0 ifTrue: [ fileID writeString: collection size: bufferSize ].	 ! !!BufferedFileStream methodsFor: 'as yet unclassified'!initializeBuffer	| bufferSize |	position := 0.	collection := self defaultBufferClass new: self defaultBufferSize.	bufferSize := collection size min: readLimit.	bufferSize > 0 ifTrue: [ fileID readString: collection size: bufferSize ]. ! !!BufferedFileStream methodsFor: 'as yet unclassified'!next	| byte |	byte := self peek.	self position: position + 1.	^ byte! !!BufferedFileStream methodsFor: 'as yet unclassified'!nextPut: char	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	position ifNil: [ self position: 0 ].	collection at: (position \\ (collection size)) + 1put: char.	self position: position + 1.	^ char! !!BufferedFileStream methodsFor: 'as yet unclassified'!open: fileName flags: flags	(super open: fileName flags: flags) ifNotNil: [ self initializeBuffer ].! !!BufferedFileStream methodsFor: 'as yet unclassified'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	position ifNil: [ self position: 0 ].	self atEnd ifTrue: [^ nil ].	^ collection at: (position \\ (collection size)) + 1.! !!BufferedFileStream methodsFor: 'as yet unclassified'!position: newPosition	| oldBufferPosition newBufferPosition bufferSize |	fileID ifNil: [ ^nil ].	newPosition < 0 ifTrue: [ ^nil ]."	((newPosition > readLimit) and: [ rwmode not ])  ifTrue: [ ^nil ]."	newPosition > readLimit ifTrue: [		rwmode ifTrue: [ readLimit := newPosition ] ifFalse: [ ^nil ]	].	oldBufferPosition := position truncateTo: (collection size).	newBufferPosition := newPosition truncateTo: (collection size).	newBufferPosition = oldBufferPosition ifFalse: [ 		self flush.		fileID position: newBufferPosition.		bufferSize := collection size min: ( readLimit - newBufferPosition).		collection := self defaultBufferClass new: self defaultBufferSize.		bufferSize > 0 ifTrue: [ fileID readString: collection size: bufferSize ].	].	position := newPosition."	rwmode ifTrue: [ readLimit := newPosition ]."	^ position.! !!BinaryFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	^ ByteArray! !!TextFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	^ String! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!concreteStream	"Who should we really direct class queries to?  "	^ UnbufferedFileStream.! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!fileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new open: fileName forWrite: true! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!forceNewFileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new openForOverwrite: fileName! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!readOnlyFileNamed: fileName 	"Open an existing file with the given name for reading."	| f |	f := self new open: fileName forWrite: false.	^ f isNil		ifFalse: [f]		ifTrue: ["File does not exist..."			((FileDoesNotExistException fileName: fileName) readOnly: true) signal].	"StandardFileStream readOnlyFileNamed: 'kjsd.txt' "! !!BufferedFileStream class methodsFor: 'as yet unclassified'!initialize	self initializeDefaultBufferSize.! !!BufferedFileStream class methodsFor: 'as yet unclassified'!initializeDefaultBufferSize	DefaultBufferSize := 4096.! !!UnhandledError methodsFor: 'as yet unclassified'!devDefaultAction	"The current computation is terminated. The cause of the error should be logged or reported to the user. If the program is operating in an interactive debugging environment the computation should be suspended and the debugger activated."	(GtkMessageDialog question: exception messageText, ', debug it?' ) = #yes		ifTrue: [ ^Processor activeProcess debugError: exception ]."	^ Processor activeProcess terminate."! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!checkType: value	^ value isInteger and: [ value >= 0 and: [ value <= self max ] ]! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	^ handle unsignedLongAt: 1 bigEndian: self isBigEndian.! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!min	^ 0! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!store: anInteger in: handle	handle unsignedLongAt: 1 put: anInteger bigEndian: self isBigEndian.! !!UnsignedByte class methodsFor: 'as yet unclassified'!max			^ 255! !!UnsignedInteger class methodsFor: 'as yet unclassified'!max			^ 4294967295! !!UnsignedShortInteger class methodsFor: 'as yet unclassified'!max			^ 65535! !!Workspace methodsFor: 'as yet unclassified'!buildMenuBar	| menu  edit  |	menu := GtkMenuBar new.	edit := GtkMenu new.	menu		append: AppLauncher fileMenu;		append: (edit createMenuItem: '_Edit');		append: workspaceView menu;		append: AppLauncher toolsMenu;		append: AppLauncher helpMenu.					^ menu.! !!Workspace methodsFor: 'as yet unclassified'!buildToolBar	| toolBar |	^ GtkToolbar new		appendItems: workspaceView toolBar;		yourself! !!Workspace methodsFor: 'as yet unclassified'!defaultCodeViewClass	^ WorkspaceView! !!Workspace methodsFor: 'as yet unclassified'!initialize	workspaceView := self defaultCodeViewClass new.	self container: (GtkVBox new		packStart: (self buildMenuBar) expand: false;		packStart: (self buildToolBar) expand: false;		packStart: (workspaceView view);		packStart: (GtkStatusbar new) expand: false	).! !!Workspace methodsFor: 'as yet unclassified'!inspectedVar: anObject	workspaceView inspectedVar: anObject.! !!TranscriptCodeEditor methodsFor: 'as yet unclassified'!defaultCodeViewClass	^ TranscriptCodeView! !!Workspace class methodsFor: 'as yet unclassified'!defaultSize	^ 640@480.! !!Workspace class methodsFor: 'as yet unclassified'!title	^'Workspace'! !!TranscriptCodeEditor class methodsFor: 'as yet unclassified'!title	^'Transcript'! !BufferedFileStream initialize!BufferedFileStream class removeSelector: #new!TranscriptCodeView initialize!TraitBehavior removeSelector: #initializeUsers!Application subclass: #Shell	instanceVariableNames: 'bindings'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!ExternalValue initialize!NativeFunctionRelocation removeSelector: #addressRelativeTo:!NativeFunctionRelocation removeSelector: #function!NativeFunctionRelocation removeSelector: #functionName!NativeFunctionRelocation removeSelector: #functionName:!NativeFunctionRelocation removeSelector: #patch:!NativeFunctionRelocation removeSelector: #patch:with:!ReadOnlyAsciiZ class removeSelector: #objectFromHandle:!ProcessorScheduler removeSelector: #activeProcess2!ProcessorScheduler removeSelector: #activeThreadData!ProcessorScheduler removeSelector: #primActiveThreadData!Process removeSelector: #threadData:!PrimitiveType class removeSelector: #defaultHandlerType!PrimitiveType class removeSelector: #instantiateHandler!NativeFunction removeSelector: #address!NativeFunction removeSelector: #bind!NativeFunction removeSelector: #invoke!NativeFunction removeSelector: #invokeAnswering:!NativeFunction removeSelector: #invokeAnswering:with:!NativeFunction removeSelector: #invokeAnswering:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:withArguments:!NativeFunction removeSelector: #invokeWith:!NativeFunction removeSelector: #invokeWith:with:!NativeFunction removeSelector: #invokeWith:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:with:with:!NativeFunction removeSelector: #invokeWithArguments:!NativeFunction removeSelector: #name!NativeFunction removeSelector: #name:!NativeFunction removeSelector: #throwNotKnownError!LibraryData removeSelector: #primitiveGetValue!LibExample initialize!LibC6 initialize!LibC6 removeSelector: #initializeUnistd!LibC6 removeSelector: #openPath:flags:!LibC6 removeSelector: #write2:buffer:size:!LibC removeSelector: #close!GPointer class removeSelector: #instantiateHandler!FileStream removeSelector: #position!FileDescriptor initialize!FileDescriptor removeSelector: #movePositionTo:!FileDescriptor removeSelector: #name!FileDescriptor removeSelector: #name:!FileDescriptor removeSelector: #positionFromEns:!FileDescriptor removeSelector: #setPositionAt:!FileDescriptor removeSelector: #setPositionFromEndAt:!CDeclFunction class removeSelector: #name:libraryNamed:returnType:argTypes:!ExecutableFunction class removeSelector: #name:library:!ExecutableFunction class removeSelector: #name:libraryNamed:!CDeclFunction removeSelector: #classFromType:!CDeclFunction removeSelector: #throwExternalFunctionError!ExecutableFunction removeSelector: #address!ExecutableFunction removeSelector: #bind!ExecutableFunction removeSelector: #invoke!ExecutableFunction removeSelector: #invokeWith:!ExecutableFunction removeSelector: #invokeWith:with:!ExecutableFunction removeSelector: #invokeWith:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithArguments:!ExecutableFunction removeSelector: #invokeWithReceiver:!ExecutableFunction removeSelector: #invokeWithReceiver:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:withArguments:!ExecutableFunction removeSelector: #library!ExecutableFunction removeSelector: #library:!ExecutableFunction removeSelector: #libraryName!ExecutableFunction removeSelector: #libraryNamed:!ExecutableFunction removeSelector: #name!ExecutableFunction removeSelector: #name:!ExecutableFunction removeSelector: #name:library:!ExecutableFunction removeSelector: #name:libraryNamed:!ExecutableFunction removeSelector: #primInvokeReceiver:withArguments:!ExecutableFunction removeSelector: #primInvokeWithArguments:!ExecutableFunction removeSelector: #primInvokeWithReceiver:withArguments:!ExecutableFunction removeSelector: #throwNotKnownError!ExternalSymbol removeSelector: #callingConventionString!ExternalObjectProxy removeSelector: #register!ExternalObjectProxy removeSelector: #unregister!AsciiZ class removeSelector: #objectFromHandle:!Executable class removeSelector: #huenul!DynamicLibrary class removeSelector: #addLibrary:named:!DynamicLibrary class removeSelector: #huemul!DynamicLibrary initialize!DynamicLibrary class removeSelector: #name:!DynamicLibrary class removeSelector: #named:!ExternalObject class removeSelector: #handle:!ExternalObject initialize!ExternalObject class removeSelector: #registry!ExternalObject class removeSelector: #registry:!AsciiZ removeSelector: #setFrom:!ExternalBuffer removeSelector: #finalize!ExternalBuffer removeSelector: #selfCheck!ExternalBuffer removeSelector: #setFrom:!ExternalBuffer removeSelector: #storeInto:size:!Executable removeSelector: #initialize!Executable removeSelector: #instantiateFunctionClass:!Executable removeSelector: #name:!Executable removeSelector: #nativeFunctionNamed:!Executable removeSelector: #primitiveOpen!DynamicLibrary removeSelector: #addExternal:!DynamicLibrary removeSelector: #basicName!DynamicLibrary removeSelector: #bind:!DynamicLibrary removeSelector: #bindFunction:!DynamicLibrary removeSelector: #cDeclFunctionNamed:returnType:argTypes:!DynamicLibrary removeSelector: #primitiveBind:!DynamicLibrary removeSelector: #primitiveBindFunction:!ExternalObject removeSelector: #isNullPointer!Object subclass: #ExternalObject	instanceVariableNames: 'handle'	classVariableNames: 'Registry'	poolDictionaries: ''	category: 'FFI-Types'!ExternalFunctionError class removeSelector: #function:!ExternalFunctionError removeSelector: #function!ExternalFunctionError removeSelector: #function:!ExternalFunctionError removeSelector: #isResumable!Error subclass: #ExternalFunctionError	instanceVariableNames: 'functionName'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!Application class removeSelector: #start!Application class removeSelector: #startWithArguments:!Class removeSelector: #superclass:methodDict:format:name:organization:instVarNames:classPool:sharedPools:!ClassBuilder removeSelector: #computeFormat:instSize:forSuper:ccIndex:!ClassBuilder removeSelector: #format:variable:words:pointers:weak:!Smalltalk removeClassNamed: #SystemChangeNotifierTest!RBProgramNodeVisitor subclass: #ASTChecker	instanceVariableNames: 'scope varsChangedInSend'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!RBProgramNodeVisitor subclass: #ASTTranslator	instanceVariableNames: 'methodBuilder receiverForCascade'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #Application	instanceVariableNames: 'arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!AssembleInstruction subclass: #AssembleCMov	instanceVariableNames: ''	classVariableNames: 'Condition'	poolDictionaries: ''	category: 'Exupery'!Object subclass: #AssemblerExupery	instanceVariableNames: 'stream blockAddresses jumpOffsets bytecodes instructionEncoders plugin relocator picEntries debugCollector source'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #BlockClosure	instanceVariableNames: 'method environment'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Contexts'!PluggableGtkSimpleApplication subclass: #ClassFinder	instanceVariableNames: 'classTrait'	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!Object subclass: #ColouringRegisterAllocator	instanceVariableNames: 'source result machine interferenceGraph registerStack registerFile registerTable spiltRegisters hasSpilt coloursUsed simplifyWorklist spillWorklist moveWorklist coalescedMoves isValidating deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #DebugInfo	instanceVariableNames: 'codeSourceReferences argVarsReferences tempVarsReferences capturedVarsReferences'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!Object subclass: #EventManager	instanceVariableNames: 'actionMap'	classVariableNames: 'ActionMaps'	poolDictionaries: ''	category: 'System-Object'!Error subclass: #ExternalFunctionError	instanceVariableNames: 'functionName '	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!Object subclass: #ExternalObject	instanceVariableNames: 'handle '	classVariableNames: 'Registry '	poolDictionaries: ''	category: 'FFI-Types'!ExternalObject subclass: #DynamicLibrary	instanceVariableNames: 'name symbolCache'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!DynamicLibrary subclass: #Executable	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!ExternalObject subclass: #ExternalBuffer	instanceVariableNames: 'size'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalBuffer subclass: #AsciiZ	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!DynamicLibrary class	instanceVariableNames: 'default'!ExternalObject subclass: #ExternalObjectProxy	instanceVariableNames: 'object'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalObjectProxy subclass: #ExternalArrayProxy	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalObject subclass: #ExternalSymbol	instanceVariableNames: 'name library'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!ExternalSymbol subclass: #ExecutableFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!ExecutableFunction subclass: #CDeclFunction	instanceVariableNames: 'returnType argTypes'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Error subclass: #ExternalSymbolError	instanceVariableNames: 'symbolName'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!ExternalObject subclass: #FileDescriptor	instanceVariableNames: ''	classVariableNames: 'StandardDescriptors'	poolDictionaries: ''	category: 'FFI-Types'!Error subclass: #FileStreamException	instanceVariableNames: 'fileName'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #CannotDeleteFileException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #FileDoesNotExistException	instanceVariableNames: 'readOnly'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #FileExistsException	instanceVariableNames: 'fileClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!AssemblyCopier subclass: #FinalCopier	instanceVariableNames: 'deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!LexicalScope subclass: #FunctionScope	instanceVariableNames: 'thisContextVar thisEnvVar tempVars capturedVars isHome hasInnerFreeVars hideTemps argVars uninitializedTemps capturedParentEnv'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #GIRBuilder	instanceVariableNames: 'ir currentBlock machine relocationInfo primitiveNode literals thisEnvVar cacheMap literalTemp source start stop debugInfo'	classVariableNames: 'InlinedSelectors SpecialConstants SpecialSelectors'	poolDictionaries: ''	category: 'Compiler-IR'!LexicalScope subclass: #InstanceScope	instanceVariableNames: 'vars'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!DynamicLibrary subclass: #LibC6	instanceVariableNames: ''	classVariableNames: 'LSeekDirectives OpenFlags'	poolDictionaries: ''	category: 'FFI-Libraries'!Object subclass: #LibExample	instanceVariableNames: ''	classVariableNames: 'GETPID'	poolDictionaries: ''	category: 'Guille-Test'!DynamicLibrary subclass: #LibReadLine	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!ExternalSymbol subclass: #LibraryData	instanceVariableNames: 'type'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Object subclass: #LivenessAnalyser	instanceVariableNames: 'source hasUpdated isValidating deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #MedLanguage	instanceVariableNames: 'in out start stop'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedCMov	instanceVariableNames: 'type from to'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedEnter	instanceVariableNames: 'argument'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedLeave	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedLiteral	instanceVariableNames: 'literal'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLiteral subclass: #MedFunction	instanceVariableNames: 'block byteCodeAddress'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!ExecutableFunction subclass: #NativeFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Object subclass: #PrimitiveType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!PrimitiveType subclass: #IntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!RBProgramNode subclass: #RBReturnNode	instanceVariableNames: 'return value homeBinding frameBinding'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Nodes'!ExternalObject subclass: #ReadOnlyAsciiZ	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SemanticWarning subclass: #RedeclaredVariableWarning	instanceVariableNames: 'variableNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #RelocationInfo	instanceVariableNames: 'offset'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #ExecutableFunctionRelocation	instanceVariableNames: 'functionName'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #FunctionRelocation	instanceVariableNames: 'function'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #LiteralRelocation	instanceVariableNames: 'literals'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!ExecutableFunctionRelocation subclass: #NativeFunctionRelocation	instanceVariableNames: 'libraryName'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!NativeFunctionRelocation subclass: #ExternalFunctionRelocation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #PrimitiveRelocation	instanceVariableNames: 'number'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!Object subclass: #ScopeVar	instanceVariableNames: 'scope usage'	classVariableNames: 'UsageAutomaton'	poolDictionaries: ''	category: 'Compiler-Semantics'!ScopeVar subclass: #GlobalVar	instanceVariableNames: 'assoc'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!ScopeVar subclass: #LocalVar	instanceVariableNames: 'name index'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!LocalVar subclass: #ArgVar	instanceVariableNames: 'isArg'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!LocalVar subclass: #CapturedVar	instanceVariableNames: 'sourceTemp'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!ByteArray variableByteSubclass: #ExternalValue	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!Object subclass: #SharedPool	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Pools'!Application subclass: #Shell	instanceVariableNames: 'bindings '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!IntegerType subclass: #SignedIntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedByte	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedShortInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!Object subclass: #SourceReference	instanceVariableNames: 'sourceStart sourceStop codeStop'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!RelocationInfo subclass: #SpecialSelectorRelocation	instanceVariableNames: 'specialSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!Model subclass: #StringHolder	instanceVariableNames: 'contents'	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Kernel-Remnants'!Object subclass: #SystemTracer	instanceVariableNames: 'byteStream traceQueue oopMap nextChunk nilOop count'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Tracer'!LocalVar subclass: #TempVar	instanceVariableNames: 'isArg'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Error subclass: #TraitException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Kernel'!TraitException subclass: #TraitCompositionException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Composition'!Error subclass: #TypeConvertionError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!FileStream subclass: #UnbufferedFileStream	instanceVariableNames: 'name fileID'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!Smalltalk renameClassNamed: #BufferedFileStream2 as: #BufferedFileStream!UnbufferedFileStream subclass: #BufferedFileStream	instanceVariableNames: ''	classVariableNames: 'DefaultBufferSize'	poolDictionaries: ''	category: 'Files-Kernel'!BufferedFileStream subclass: #BinaryFileStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!BufferedFileStream subclass: #TextFileStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!IntegerType subclass: #UnsignedIntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedByte	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedShortInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SemanticWarning subclass: #UnusedVariableWarning	instanceVariableNames: 'variableNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #VarReference	instanceVariableNames: 'name'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!RelocationInfo subclass: #VariableRelocation	instanceVariableNames: 'variable'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!PluggableGtkSimpleApplication subclass: #Workspace	instanceVariableNames: 'workspaceView'	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!Workspace subclass: #TranscriptCodeEditor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!!Object methodsFor: 'as yet unclassified'!errorSubscriptBounds: index 	"Create an error notification that an improper integer was used as an index."	self error: 'subscript is out of bounds: ' , index printString! !!Object methodsFor: 'as yet unclassified'!executeMethod: compiledMethod withArgs: argArray	"Execute compiledMethod against the receiver and args in argArray"	| selector |	<primitive: 188>	selector _ Symbol new.	self class addSelectorSilently: selector withMethod: compiledMethod.	^ [self perform: selector withArguments: argArray]		ensure: [self class basicRemoveSelector: selector]! !!Object methodsFor: 'as yet unclassified'!withArgs: argArray executeMethod: compiledMethod	"For compatibility with Aqueak"	self executeMethod: compiledMethod withArgs: argArray! !!Application methodsFor: 'as yet unclassified'!arguments	^ arguments.! !!Application methodsFor: 'as yet unclassified'!arguments: anArray	arguments := anArray.! !!Application methodsFor: 'as yet unclassified'!main	self subclassResponsibility.! !!Application methodsFor: 'as yet unclassified'!startUp	Smalltalk startUp.	^ self main.! !!Behavior methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return true if it is safe to zap the method dictionary on #obsolete"	^true! !!Behavior methodsFor: 'as yet unclassified'!isWeak	^ (format bitAnd: 4) = 1.! !!Behavior methodsFor: 'as yet unclassified'!obsolete	"Invalidate and recycle local methods,	e.g., zap the method dictionary if can be done safely."	self canZapMethodDictionary		ifTrue: [self methodDict: self emptyMethodDictionary].! !!Behavior methodsFor: 'as yet unclassified'!removeSelector: selector	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method."	| oldMethod |		oldMethod _ self methodDict at: selector ifAbsent: [^ self].	self methodDict removeKey: selector.	"Now flush Squeak's method cache, either by selector or by method"	oldMethod flushCache.	selector flushCache! !!Behavior methodsFor: 'as yet unclassified'!selectorsAndMethodsDo: aBlock	"Evaluate selectorBlock for all the message selectors in my method dictionary."	^ self methodDict keysAndValuesDo: aBlock! !!Behavior methodsFor: 'as yet unclassified'!setTraitComposition: aTraitComposition	| oldComposition |	(self hasTraitComposition not and: [aTraitComposition isEmpty]) ifTrue: [^self].	aTraitComposition assertValidUser: self.	oldComposition _ self traitComposition.	self traitComposition: aTraitComposition."	self applyChangesOfNewTraitCompositionReplacing: oldComposition."		oldComposition traits do: [:each | each removeUser: self].	aTraitComposition traits do: [:each | each addUser: self]! !!Behavior methodsFor: 'as yet unclassified'!traitCompositionString	^self hasTraitComposition		ifTrue: [self traitComposition asString]		ifFalse: ['{}']! !!Behavior methodsFor: 'as yet unclassified'!typeOfClass	"Answer a symbol uniquely describing the type of the receiver"	self isWeak ifTrue: [ ^ #weak ].	^ (format bitAnd: 3) caseOf: {		[ 0 ] -> [ #normal ].		[ 1 ] -> [ #variable ].		[ 2 ] -> [ #bytes ].		[ 3 ] -> [ #words ]	}! !!Behavior methodsFor: 'as yet unclassified'!whichSelectorsReferTo: literal	"Answer a set of selectors whose methods access the argument as a literal."	| who |	who _ IdentitySet new.	self selectorsAndMethodsDo: 		[:sel :method |		(method hasLiteral: literal)			ifTrue:				[((literal isVariableBinding) not					or: [method literals allButLast includes: literal])						ifTrue: [who add: sel]]].	^ who! !!BehaviorTest methodsFor: 'as yet unclassified'!testBehaviorSubclasses	"self run: #testBehaviorSubclasses"		| b b2 |"	b := Behavior new.	b superclass: OrderedCollection.	b methodDictionary: Dictionary new.	self shouldnt: [b subclasses ] raise: Error.	self shouldnt: [b withAllSubclasses] raise: Error.	self shouldnt: [b allSubclasses] raise: Error.	b2 := Behavior new.	b2 superclass: b.	b2 methodDictionary: Dictionary new.	self assert: (b subclasses includes: b2).	self assert: (b withAllSubclasses includes: b)."! !!BlockClosure methodsFor: 'as yet unclassified'!valueWithArguments: anArray 	"Evaluate the block with given args. Fail if the block expects other than the given number of arguments."	^ environment executeMethod: method withArgs: anArray ! !!ClassBrowser methodsFor: 'as yet unclassified'!buildClassCategoriesView	| model tree col cell |	tree := nil->nil.	SystemOrganization categories do: [ :each |		| category |		category := tree.		(each subStrings: '-') do: [ :cat |			category value ifNil: [ category value: Dictionary new].			category := category value associationAt: cat ifAbsent: [ category value at: cat put: nil. category value associationAt: cat ]		]	].	model := GtkTreeStore new: {String. String}.	[ self addSubcategoriesFrom: tree fromIter: nil inModel: model ] fork.	classCategoriesTree := GtkTreeView model: model.	col := GtkTreeViewColumn title: 'Class categories'.	cell := GtkCellRendererPixbuf new.	col		packStart: cell expand: false;		addAttribute: #stockId column: 1 on: cell.	cell := GtkCellRendererText new.	col		packStart: cell;		addAttribute: #text column: 0 on: cell.		classCategoriesTree appendColumn: col.	classCategoriesTree selection when: #changed send: #onClassCategoryChanged to: self.	classCategoriesTree enableTreeLines: true.	^ GtkScrolledWindow withChild: classCategoriesTree! !!ClassBrowser methodsFor: 'as yet unclassified'!loadClassMethodsOf: aClassClass	| iter |	classMethodsTree model clear.	aClassClass organization categories do: [ :cat |		iter := classMethodsTree model append: nil->{cat asString. true. 'grey'. 'gtk-info'}.		(aClassClass organization listAtCategoryNamed: cat) asSortedCollection do: [ :sel |			classMethodsTree model append: iter->{sel asString. false. 'grey'. 'gtk-execute'}		]	].	classMethodsTree expandAll.! !!ClassBrowser methodsFor: 'as yet unclassified'!loadInstanceMethodsOf: aClass	| iter |	instanceMethodsTree model clear.	aClass organization categories do: [ :cat |		iter := instanceMethodsTree model append: nil->{cat asString. true. 'grey'. 'gtk-info'}.		(aClass organization listAtCategoryNamed: cat) asSortedCollection do: [ :sel |			instanceMethodsTree model append: iter->{sel asString. false. 'grey'. 'gtk-execute'}		]	].	instanceMethodsTree expandAll.! !!ClassBrowser methodsFor: 'as yet unclassified'!onClassHierarchyChanged	| class iter path newIter aCategory classHierarchySelectedRow classesTreeSelectedRow |	classHierarchySelectedRow := classHierarchyTree selectedRow.	classHierarchySelectedRow ifNotNil: [		class := Smalltalk at: (classHierarchySelectedRow first asSymbol).							aCategory := class category.		( aCategory isNotNil and: [ aCategory ~= selectedClassCategory ] ) ifTrue: [			selectedClassCategory := aCategory.			iter := classCategoriesTree model firstIter.			newIter := nil.			(aCategory subStrings: '-') do: [ :cat |				newIter ifNotNil: [ iter := newIter ].				iter := self classCategoryFor: cat firstIter: iter.				newIter := classCategoriesTree model firstChildAt: iter.			].			path := classCategoriesTree model pathFromIter: iter.			classCategoriesTree expandRowsUpTo: path.			classCategoriesTree moveCursorAt: path.					classesTree model clear.			(SystemOrganization listAtCategoryNamed: aCategory) sort do: [ :ea |				classesTree model append: {ea asString. 'gtk-execute'}			]		].							self selectClass: class.	]! !!ClassBuilder methodsFor: 'as yet unclassified'!formatForType: type	^ type caseOf: {		[ #normal ] -> [ 0 ].		[ #variable ] -> [ 1 ].		[ #bytes ] -> [ 2 ].		[ #words ] -> [ 3 ].		[ #weak ] -> [ 5 "binary: 4 + 0 + 0 + 1" ]	} otherwise: [ self error: 'Unknown class type' ].! !!ClassBuilder methodsFor: 'as yet unclassified'!needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Answer whether we need a new subclass to conform to the requested changes"	"Check if we really need a new subclass"	oldClass ifNil:[^true]. "yes, it's a new class"	newSuper == oldClass superclass ifFalse:[^true]. "yes, it's a superclass change"	type = oldClass typeOfClass ifFalse:[^true]. "yes, it's a format change"	instVars = oldClass instVarNames ifFalse:[^true]. "yes, it's an iVar change"	^false! !!ClassBuilder methodsFor: 'as yet unclassified'!newSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Create a new subclass of the given superclass with the given specification."	| newClass |	(oldClass == nil or:[oldClass isMeta not]) 		ifTrue:[newClass := self privateNewSubclassOf: newSuper from: oldClass]		ifFalse:[newClass := oldClass clone].	newClass 		superclass: newSuper		methodDictionary: "Method"Dictionary new		instanceSize: (newSuper instSize + instVars size)		format: (self formatForType: type);		setInstVarNames: instVars.	oldClass ifNotNil:[		newClass organization: oldClass organization.		"Recompile the new class"		oldClass hasMethods 			ifTrue:[newClass compileAllFrom: oldClass].		oldClass hasTraitComposition ifTrue: [			newClass setTraitComposition: oldClass traitComposition copyTraitExpression ].		oldClass class hasTraitComposition ifTrue: [			newClass class setTraitComposition: oldClass class traitComposition copyTraitExpression ].				self recordClass: oldClass replacedBy: newClass.	].	(oldClass == nil or:[oldClass isObsolete not]) 		ifTrue:[newSuper addSubclass: newClass]		ifFalse:[newSuper addObsoleteSubclass: newClass].	^newClass! !!ClassBuilder methodsFor: 'as yet unclassified'!privateNewSubclassOf: newSuper from: oldClass	"Create a new meta and non-meta subclass of newSuper using oldClass as template"	"WARNING: This method does not preserve the superclass/subclass invariant!!"	| newSuperMeta oldMeta newMeta |	oldClass ifNil:[^self privateNewSubclassOf: newSuper].	newSuperMeta _ newSuper ifNil:[Class] ifNotNil:[newSuper class].	oldMeta _ oldClass class.	newMeta _ oldMeta clone.	newMeta 		superclass: newSuperMeta		methodDictionary: "Method"Dictionary new		instanceSize: oldMeta instSize		format: oldMeta format;		setInstVarNames: oldMeta instVarNames;		organization: oldMeta organization.	"Recompile the meta class"	oldMeta hasMethods 		ifTrue:[newMeta compileAllFrom: oldMeta].	"Record the meta class change"	self recordClass: oldMeta replacedBy: newMeta.	"And create a new instance"	^newMeta adoptInstance: oldClass from: oldMeta! !!ClassBuilder methodsFor: 'as yet unclassified'!reshapeClass: oldClass toSuper: newSuper	"Reshape the given class to the new super class. Recompile all the methods in the newly created class. Answer the new class."	| instVars |	instVars _ instVarMap at: oldClass name ifAbsent:[oldClass instVarNames].	^self newSubclassOf: newSuper 			type: oldClass typeOfClass 			instanceVariables: instVars 			from: oldClass! !!ClassDescription methodsFor: 'as yet unclassified'!classVersion	"Default.  Any class may return a later version to inform readers that use ReferenceStream.  8/17/96 tk"	"This method allows you to distinguish between class versions when the shape of the class 	hasn't changed (when there's no change in the instVar names).	In the conversion methods you usually can tell by the inst var names 	what old version you have. In a few cases, though, the same inst var 	names were kept but their interpretation changed (like in the layoutFrame).	By changing the class version when you keep the same instVars you can 	warn older and newer images that they have to convert."	^ 0! !!ClassDescription methodsFor: 'as yet unclassified'!obsolete	"Make the receiver obsolete."	superclass removeSubclass: self.	self organization: nil.	super obsolete.! !!ClassDescription methodsFor: 'as yet unclassified'!removeSelector: selector 	"Remove the message whose selector is given from the method 	dictionary of the receiver, if it is there. Answer nil otherwise."		| priorMethod priorProtocol | 	priorMethod _ self compiledMethodAt: selector ifAbsent: [^ nil].	priorProtocol _ self whichCategoryIncludesSelector: selector.	SystemChangeNotifier uniqueInstance		doSilently: [self organization removeElement: selector ].	super removeSelector: selector.	SystemChangeNotifier uniqueInstance 			methodRemoved: priorMethod selector: selector inProtocol: priorProtocol class: self.! !!ClassDescription methodsFor: 'as yet unclassified'!updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil	| currentCategory effectiveCategory sel changedCategories composition |	changedCategories _ IdentitySet new.	composition := self hasTraitComposition		ifTrue: [self traitComposition]		ifFalse: [TraitComposition new].	(composition methodDescriptionsForSelector: aSymbol) do: [:each |		sel _ each selector.		(self includesLocalSelector: sel) ifFalse: [			currentCategory _ self organization categoryOfElement: sel.			effectiveCategory _ each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.			effectiveCategory isNil ifTrue: [				currentCategory ifNotNil: [changedCategories add: currentCategory].				self organization removeElement: sel.			] ifFalse: [				((currentCategory isNil or: [currentCategory == ClassOrganizer ambiguous or: [currentCategory == oldCategoryOrNil]]) and: [currentCategory ~~ effectiveCategory]) ifTrue: [					currentCategory ifNotNil: [changedCategories add: currentCategory].					self organization 						classify: sel 						under: effectiveCategory						suppressIfDefault: false]]]].	^ changedCategories! !!ClassDescription methodsFor: 'as yet unclassified'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	(self includesSelector: aSelector)		ifTrue: [^ self organization categoryOfElement: aSelector]		ifFalse: [^nil]! !!Class methodsFor: 'as yet unclassified'!classPool: aDictionary	classPool _ aDictionary! !!Class methodsFor: 'as yet unclassified'!copy 	| newClass |	newClass _ self class copy new		superclass: superclass		methodDict: self methodDict copy		instanceSize: self instSize		format: format		name: name		organization: self organization copy		instVarNames: instanceVariables copy		classPool: classPool copy		sharedPools: sharedPools.	Class instSize+1 to: self class instSize do:		[:offset | newClass instVarAt: offset put: (self instVarAt: offset)].	^ newClass! !!Class methodsFor: 'as yet unclassified'!deactivate	"A remnant from the 3.3a modules work, retained . Does nothing, but may be overridden in Metaclasses."! !!Class methodsFor: 'as yet unclassified'!isSystemDefined	"Answer true if the receiver is a system-defined class, and not a UniClass (an instance-specific lightweight class)"	^ self == self officialClass! !!Class methodsFor: 'as yet unclassified'!obsolete	"Change the receiver and all of its subclasses to an obsolete class."	self == Object 		ifTrue: [^self error: 'Object is NOT obsolete'].	self setName: 'AnObsolete' , self name.	Object class instSize + 1 to: self class instSize do:		[:i | self instVarAt: i put: nil]. "Store nil over class instVars."	self classPool: nil.	self sharedPools: nil.	self class obsolete.	super obsolete.! !!Class methodsFor: 'as yet unclassified'!officialClass	"I am not a UniClass.  (See Player officialClass).  Return the class you use to make new subclasses."	^ self! !!Class methodsFor: 'as yet unclassified'!removeFromSystem	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."	self removeFromSystem: true.! !!Class methodsFor: 'as yet unclassified'!removeFromSystem: logged	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."		"keep the class name and category for triggering the system change message. If we wait to long, then we get obsolete information which is not what we want."	"tell class to deactivate and unload itself-- two separate events in the module system"	self deactivate; unload.	self superclass ifNotNil:		["If we have no superclass there's nothing to be remembered"		self superclass addObsoleteSubclass: self].	self environment forgetClass: self logged: logged.	self obsolete.! !!Class methodsFor: 'as yet unclassified'!sharedPools: aCollection	sharedPools _ aCollection! !!Class methodsFor: 'as yet unclassified'!superclass: sup methodDict: md instanceSize: is format: ft name: nm organization: org instVarNames: nilOrArray classPool: pool sharedPools: poolSet 	"Answer an instance of me, a new class, using the arguments of the 	message as the needed information.	Must only be sent to a new instance; else we would need Object flushCache."	superclass := sup.	methodDict := md.	instanceSize := is.	format := ft.	name := nm.	instanceVariables := nilOrArray.	classPool := pool.	sharedPools := poolSet.	self organization: org.! !!Class methodsFor: 'as yet unclassified'!unload	"Sent when a the class is removed.  Does nothing, but may be overridden by (class-side) subclasses."! !!Class methodsFor: 'as yet unclassified'!variableByteSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable byte-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableByteSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!variableSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable pointer variables."	^(ClassBuilder new)		superclass: self		variableSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!variableWordSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable word-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableWordSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!weakSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have weak indexable pointer variables."	^(ClassBuilder new)		superclass: self		weakSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!AppLauncher class methodsFor: 'as yet unclassified'!openAboutHuemul	| dlg logo |	logo := GdkPixbuf fromFile: 'Huemul.jpg'.	dlg := GtkAboutDialog new.	dlg		aboutDialogName: 'Huemul Smalltalk';		version: '0.8';		license: (StandardFileStream readOnlyFileNamed: 'LICENSE') upToEnd;		website: 'http://www.guillermomolina.com.ar/huemul';		comments: 'This is Huemul Smalltalk';		authors: {'Guillermo Adrian Molina'};		logo: logo.	dlg runAndDestroy! !!AppLauncher class methodsFor: 'as yet unclassified'!openWorkspace	^ Workspace open! !!Application class methodsFor: 'as yet unclassified'!startUp	^ self new startUp.! !!Application class methodsFor: 'as yet unclassified'!startUpWithArguments: arguments	| application |	application := self new.	application arguments: arguments.	^ application startUp.! !!Behavior class methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return false since zapping the method dictionary of Behavior class or its subclasses will cause the system to fail."	^false! !!ClassBrowser class methodsFor: 'as yet unclassified'!defaultSize	^ 640@480.! !!ClassBrowser class methodsFor: 'as yet unclassified'!title	^'Class browser'! !!ClassFinder class methodsFor: 'as yet unclassified'!defaultSize	^ 200@300.! !!ClassFinder class methodsFor: 'as yet unclassified'!title	^'Class finder'! !!CompiledMethod methodsFor: 'as yet unclassified'!hasLiteral: literal	"Answer whether the receiver references the argument, literal."	literals ifNil: [ ^false ].	^ literals hasLiteral: literal.! !!CompiledMethod methodsFor: 'as yet unclassified'!sourcePointer	"Answer the integer which can be used to find the source file and position for this method.	Not sources yet"	^ 0! !!CompiledMethodWithNode class methodsFor: 'as yet unclassified'!method: aCompiledMethod node: aMethodNode	^ self new method: aCompiledMethod; node: aMethodNode.! !!Compiler methodsFor: 'as yet unclassified'!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into a method. In other words, if receiver is not nil, then the text can refer to instance variables of that receiver (the Inspector uses this). If aContext is not nil, the text can refer to temporaries in that context (the Debugger uses this). If aRequestor is not nil, then it will receive a notify:at: message before the attempt to evaluate is aborted. Finally, the compiled method is directly invoked without modifying the receiving-class."	"| methodNode method value |	  	(Preferences compileUseNewCompiler or: 			[aContext ifNotNil: [aContext method isClosureCompiled] ifNil: [false]]) ifTrue: 				[^ self evaluate2: textOrStream 					    in: aContext 					    to: receiver 					    notifying: aRequestor 					    ifFail: failBlock 					    logged: logFlag].		class := (aContext isNil 		ifTrue: [ receiver ] 		ifFalse: [ aContext receiver ])			class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode := self 		translate: sourceStream		noPattern: true 		ifFail: [ ^ failBlock value ].	method := methodNode generate.	self interactive		ifTrue: [ method := method copyWithTempNames: methodNode tempNames ].	value := receiver		executeMethod: method 		withArgs: (context isNil			ifTrue: [ #() ]			ifFalse: [ Array with: aContext ]).	logFlag 		ifTrue: [ SystemChangeNotifier uniqueInstance evaluated: sourceStream contents context: aContext ].	^ value."	| string block |	string _ textOrStream readStream upToEnd.	block := self compileDoIt: string in: aContext to: receiver notifying: aRequestor ifFail: [^ failBlock value] log: logFlag.	^ block value! !!Exception methodsFor: 'as yet unclassified'!messageText	messageText ifNil: [ ^ self class name asString ].	^messageText! !!Exception methodsFor: 'as yet unclassified'!receiver	^ self signalerContext receiver! !!ExternalFunctionError methodsFor: 'as yet unclassified'!functionName	"Answer the function name that was beiing used."	^functionName! !!ExternalFunctionError methodsFor: 'as yet unclassified'!functionName: argument	"Specify the function name that was beiing used."	functionName := argument! !!ExternalFunctionError class methodsFor: 'as yet unclassified'!functionName: argument	^self new functionName: argument; yourself! !!ExternalObject methodsFor: 'as yet unclassified'!= anObject 	(anObject isKindOf: self class)		ifTrue: [^ anObject handle = self handle]		ifFalse: [^ false]! !!ExternalObject methodsFor: 'as yet unclassified'!beNull	^ handle beNull.! !!ExternalObject methodsFor: 'as yet unclassified'!finalize		self free.	self unregister.! !!ExternalObject methodsFor: 'as yet unclassified'!free	"Should override this"! !!ExternalObject methodsFor: 'as yet unclassified'!initialize	handle := self class defaultHandlerClass new.	self register.! !!ExternalObject methodsFor: 'as yet unclassified'!isNull	^ self handle isNull.! !!ExternalObject methodsFor: 'as yet unclassified'!register	Registry add: self.! !!ExternalObject methodsFor: 'as yet unclassified'!unregister		Registry remove: self ifAbsent:[  ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!addSymbol: anExternalSymbol	^ symbolCache at: anExternalSymbol name put: anExternalSymbol.! !!DynamicLibrary methodsFor: 'as yet unclassified'!bindSymbol: anExternalSymbol	^ self primitiveBindSymbol: anExternalSymbol.! !!DynamicLibrary methodsFor: 'as yet unclassified'!cDeclFunctionNamed: functionName	^ symbolCache at: functionName ifAbsent: [ self error: 'You must initialize the function before using it' ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!close		handle isNull ifFalse: [ 		self primitiveClose		handle beNull.	].! !!DynamicLibrary methodsFor: 'as yet unclassified'!initialize	super initialize.	symbolCache := Dictionary new.! !!DynamicLibrary methodsFor: 'as yet unclassified'!initializeCDeclFunctionNamed: functionName returnType: retType argTypes: argTypesArray	^ symbolCache at: functionName put: 			(CDeclFunction name: functionName library: self  returnType: retType argTypes: argTypesArray)! !!DynamicLibrary methodsFor: 'as yet unclassified'!initializeLibraryDataNamed: symbolName type: type	^ symbolCache at: symbolName put: (LibraryData name: symbolName library: self  type: type)! !!DynamicLibrary methodsFor: 'as yet unclassified'!libraryDataNamed: symbolName	^ symbolCache at: symbolName ifAbsent: [ self error: 'You must initialize the symbol before using it' ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!name	^name! !!DynamicLibrary methodsFor: 'as yet unclassified'!name: aName	name := aName.! !!DynamicLibrary methodsFor: 'as yet unclassified'!nativeFunctionNamed: functionName	^ symbolCache at: functionName ifAbsent: [ 		symbolCache at: functionName put: (NativeFunction name: functionName library: self)	].! !!DynamicLibrary methodsFor: 'as yet unclassified'!open		handle isNull ifTrue: [ self primitiveOpen ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveBindSymbol: anExternalSymbol	"Primitive. Find the given symbol in the library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 203>	^ anExternalSymbol throwNotKnownError.! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveClose	"Primitive. Close the given library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 202>! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveOpen	"Primitive. Open the given library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 198>	self primitiveFailed.! !!DynamicLibrary methodsFor: 'as yet unclassified'!printOn: aStream	aStream nextPutAll: self name.! !!DynamicLibrary methodsFor: 'as yet unclassified'!symbolNamed: symbolName	^ symbolCache at: symbolName ifAbsent: [ self error: 'You must initialize the symbol before using it' ]! !!Executable methodsFor: 'as yet unclassified'!name	^ Utilities executableName ! !!Executable methodsFor: 'as yet unclassified'!primitiveSmallIntegerAdd: receiver with: argument	^ (self nativeFunctionNamed: #primitiveSmallIntegerAdd) invokeReceiver: receiver with: argument.! !!ExternalBuffer methodsFor: 'as yet unclassified'!asByteArray	| array |	size ifNil: [ ^ self class throwTypeConvertionError ].	array := ByteArray new: self basicSize.	self storeInto: array.	^ array	! !!ExternalBuffer methodsFor: 'as yet unclassified'!atAllPut: constant	^ LibC6 default memSet: self constant: constant count: self size.! !!ExternalBuffer methodsFor: 'as yet unclassified'!atAllPutZero	^ self atAllPut: 0.! !!ExternalBuffer methodsFor: 'as yet unclassified'!basicSize	^ size.! !!ExternalBuffer methodsFor: 'as yet unclassified'!byteAt: index	<primitive: 190>	index isNumber		ifTrue: [self errorSubscriptBounds: index]		ifFalse: [self errorNonIntegerIndex].! !!ExternalBuffer methodsFor: 'as yet unclassified'!byteAt: index put: value	<primitive: 191>	index isNumber		ifTrue: [self errorSubscriptBounds: index]		ifFalse: [self errorNonIntegerIndex].! !!ExternalBuffer methodsFor: 'as yet unclassified'!free		handle isNull ifFalse: [ 		LibC6 default free: self.		self beNull.	]! !!ExternalBuffer methodsFor: 'as yet unclassified'!loadFrom: aByteArray	<primitive: 199>	self primitiveFailed.! !!ExternalBuffer methodsFor: 'as yet unclassified'!size	^ self basicSize.! !!ExternalBuffer methodsFor: 'as yet unclassified'!size: anInteger	size := anInteger.! !!ExternalBuffer methodsFor: 'as yet unclassified'!storeInto: aByteArray	<primitive: 218>	^ self class throwTypeConvertionError.! !!AsciiZ methodsFor: 'as yet unclassified'!asString	^ handle toString.! !!AsciiZ methodsFor: 'as yet unclassified'!asString2	| calcSize string |	size ifNil: [ ^ self class throwTypeConvertionError ].	calcSize := self strlen.	calcSize >= self size ifTrue: [ ^ self class throwTypeConvertionError ].	string := String new: calcSize.	self storeInto: string.	^ string! !!AsciiZ methodsFor: 'as yet unclassified'!loadFrom: aString		super loadFrom: aString.	self byteAt: (aString size + 1) put: 0.! !!AsciiZ methodsFor: 'as yet unclassified'!strlen	^ LibC6 default strLen: self.! !!ExternalFunction methodsFor: 'as yet unclassified'!library	^ library! !!ExternalFunction methodsFor: 'as yet unclassified'!library: aLibrary	library := aLibrary! !!ExternalFunction methodsFor: 'as yet unclassified'!name	^name! !!ExternalFunction methodsFor: 'as yet unclassified'!name: aName	name := aName! !!ExternalFunction methodsFor: 'as yet unclassified'!name: aName library: aLibrary	self name: aName.	self library: aLibrary! !!ExternalFunction methodsFor: 'as yet unclassified'!reload	library ifNil: [ ^ self throwNotKnownError ].	self handle: (library findFunction: self)! !!ExternalLibrary methodsFor: 'as yet unclassified'!bindFunction: function	| answer |	answer := self primitiveBindFunction: function.	answer ifNotNil: [ ^ answer ].	self open. "Library may be closed, open it and retry"	answer := self primitiveBindFunction: answer.	answer ifNotNil: [ ^ answer ].	^ function throwNotKnownError.		! !!ExternalLibrary methodsFor: 'as yet unclassified'!closeLibrary		(handle isNotNil and: [ handle isNull not ]) ifTrue: [ self primitiveClose ].	self handle: nil.	functionCache := nil.! !!ExternalLibrary methodsFor: 'as yet unclassified'!openLibrary		self primitiveOpen.	self initializeFunctionCache.! !!ExternalLibrary methodsFor: 'as yet unclassified'!primitiveBindFunction: function	"Primitive. Find the given symbol in the library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 203>	^ nil.! !!ExternalObject class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: self! !!ExternalObject class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalAddress! !!ExternalObject class methodsFor: 'as yet unclassified'!handleFromObject: anObject	^ self handleFromObject: anObject ifError: [ self throwTypeConvertionError ]! !!ExternalObject class methodsFor: 'as yet unclassified'!handleFromObject: anObject ifError: aBlock		(anObject isKindOf: ExternalObject) ifFalse: [ ^ aBlock value ].	^ anObject handle.	! !!ExternalObject class methodsFor: 'as yet unclassified'!initialize	Registry := WeakRegistry new.	Smalltalk addToShutDownList: self.! !!ExternalObject class methodsFor: 'as yet unclassified'!objectFromHandle: handle	^self objectFromHandle: handle ifError: [ self throwTypeConvertionError ]! !!ExternalObject class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; yourself! !!ExternalObject class methodsFor: 'as yet unclassified'!quit	Registry do: [ :each | each free ].	self allSubclassesDo: [ :ea | ea quit ]! !!ExternalObject class methodsFor: 'as yet unclassified'!shutDown: quitting	quitting ifTrue: [ self quit ].! !!ExternalObject class methodsFor: 'as yet unclassified'!throwTypeConvertionError	^ TypeConvertionError new signal! !!DynamicLibrary class methodsFor: 'as yet unclassified'!default	self = DynamicLibrary ifTrue: [ self error: 'Create a class to create its singleton' ].	default ifNil: [	"Represents the executable itself"		default := self new.		default name: self moduleName.		default open.	].	^ default.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!initialize	self = DynamicLibrary ifFalse: [ 		Smalltalk addToShutDownList: self	].! !!DynamicLibrary class methodsFor: 'as yet unclassified'!moduleName	self subClassResponsibility.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!resetLibrary	default := nil.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!shutDown: aBool	default ifNotNil: [ default close ].! !!Executable class methodsFor: 'as yet unclassified'!huemul	^ self default! !!Executable class methodsFor: 'as yet unclassified'!moduleName	^nil.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: ByteArray! !!ExternalBuffer class methodsFor: 'as yet unclassified'!fromByteArray: aByteArray	| anExternalBuffer |		anExternalBuffer := ExternalBuffer new: aByteArray size.	anExternalBuffer setFrom: aByteArray.	^ anExternalBuffer.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!handleFromObject: aByteArray ifError: aBlock		(aByteArray isKindOf: ByteArray) ifFalse: [ 		^ super handleFromObject: aByteArray ifError: aBlock	].	^ ( self fromByteArray: aByteArray ) handle.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!new: size	| anExternalBuffer |	"This space is allocated from the system not 	from Object Memory, you will have to give it back, 	as it is not garbage collected"	anExternalBuffer := LibC6 default malloc: (size +  10).	anExternalBuffer size: size.	^ anExternalBuffer! !!AsciiZ class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: String! !!AsciiZ class methodsFor: 'as yet unclassified'!fromString: aString	| anAsciiZ |		anAsciiZ := AsciiZ new: aString size + 1.	anAsciiZ loadFrom: aString.	^ anAsciiZ.! !!AsciiZ class methodsFor: 'as yet unclassified'!handleFromObject: aString ifError: aBlock		(aString isKindOf: String) ifFalse: [ 		^ super handleFromObject: aString ifError: aBlock	].	^ ( self fromString: aString ) handle.! !!AsciiZ class methodsFor: 'as yet unclassified'!new: size	| buffer asciiZ |	buffer := super new: size.	asciiZ := AsciiZ new handle: buffer handle.	asciiZ size: size.	asciiZ atAllPutZero.	buffer handle: ExternalAddress nullPointer.	^ asciiZ! !!AsciiZ class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; asString! !!ExternalFunction class methodsFor: 'as yet unclassified'!name: aName library: aLibrary	^self new name: aName library: aLibrary! !!ExternalLibrary class methodsFor: 'as yet unclassified'!huemul	Huemul ifNil: [	"Represents the executable itself"		Huemul := self new.		Huemul open.	].	^ Huemul.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!handle	self object ifNil: [ handle beNull ].	^ handle.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!initialize	super initialize.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!initializePointer	self handle forObject: self object.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!object	^ self objectPointer at: 1! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!object: anObject	self objectPointer at: 1 put: anObject.	self initializePointer.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!objectPointer	object ifNil: [ object := WeakArray new: 1 ].	^ object! !!ExternalArrayProxy methodsFor: 'as yet unclassified'!initializePointer	self handle forArray: self object.! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!fromObject: anObject		^ self new object: anObject; yourself! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!handleFromObject: anObject ifError: aBlock		^ ( self fromObject: anObject ) handle.! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		^ aBlock value! !!ExternalSymbol methodsFor: 'as yet unclassified'!address	handle isNull ifTrue: [ self bind ].	^ handle.! !!ExternalSymbol methodsFor: 'as yet unclassified'!bind	^ library bindSymbol: self.! !!ExternalSymbol methodsFor: 'as yet unclassified'!classFromType: aType	^ Smalltalk at: aType ifAbsent: [ self throwExternalSymbolError ].! !!ExternalSymbol methodsFor: 'as yet unclassified'!library	^ library! !!ExternalSymbol methodsFor: 'as yet unclassified'!library: aLibrary	library := aLibrary! !!ExternalSymbol methodsFor: 'as yet unclassified'!libraryName	^ library name.! !!ExternalSymbol methodsFor: 'as yet unclassified'!name	^name! !!ExternalSymbol methodsFor: 'as yet unclassified'!name: aName	name := aName! !!ExternalSymbol methodsFor: 'as yet unclassified'!name: aName library: aLibrary	self name: aName.	self library: aLibrary! !!ExternalSymbol methodsFor: 'as yet unclassified'!throwExternalSymbolError	^(ExternalSymbolError symbolName: name) signal.! !!ExternalSymbol methodsFor: 'as yet unclassified'!throwNotKnownError	^(ExternalSymbolError symbolName: name) signal.! !!ExecutableFunction methodsFor: 'as yet unclassified'!callingConventionString	self subclassResponsibility.! !!CDeclFunction methodsFor: 'as yet unclassified'!argTypes: anArrayOfTypes	argTypes := anArrayOfTypes.! !!CDeclFunction methodsFor: 'as yet unclassified'!callingConventionString	^ 'cdecl'! !!CDeclFunction methodsFor: 'as yet unclassified'!invoke	^self invokeWithArguments: #()! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1	^self invokeWithArguments: (Array with: arg1)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2	^self invokeWithArguments: (Array with: arg1 with: arg2)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4 with: arg5	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWithArguments: argArray	| argSize argHandleArray returnClass returnHandle |	argSize := argArray size.	argSize = argTypes size ifFalse: [ self throwExternalFunctionError ].	argHandleArray := Array new: argSize.	1 to: argSize do: [ :i |		| argType argClass argHandle arg |		argType := argTypes at: i.		argClass := self classFromType: argType.		arg := argArray at: i.		argHandle := argClass handleFromObject: arg.		argHandleArray at: i put: argHandle.	].	returnHandle := nil.	returnType = #Void ifFalse: [		returnClass := self classFromType: returnType.		returnHandle := returnClass defaultHandlerClass new.	].	handle isNull ifTrue: [ self bind ].	self primInvokeAnswering: returnHandle withArguments: argHandleArray.	returnType = #Void ifTrue: [ ^ nil ].	^ returnClass objectFromHandle: returnHandle.! !!CDeclFunction methodsFor: 'as yet unclassified'!primInvokeAnswering: aReturnValue withArguments: argArray	"Manually invoke the receiver, representing an external function."	<primitive: 204>	^self primitiveFailed! !!CDeclFunction methodsFor: 'as yet unclassified'!returnType: aType	returnType := aType.! !!CDeclFunction methodsFor: 'as yet unclassified'!returnType: aType argTypes: anArrayOfTypes	self returnType: aType.	self argTypes: anArrayOfTypes.! !!ExternalSymbol class methodsFor: 'as yet unclassified'!name: aName library: aLibrary	^self new name: aName library: aLibrary; bind! !!CDeclFunction class methodsFor: 'as yet unclassified'!name: aName library: aLibrary returnType: retType argTypes: argTypesArray	^self new name: aName library: aLibrary;		 returnType: retType argTypes: argTypesArray;		bind! !!ExternalSymbolError methodsFor: 'as yet unclassified'!isResumable	"Determine whether an exception is resumable."	^true! !!ExternalSymbolError methodsFor: 'as yet unclassified'!symbolName	^ symbolName! !!ExternalSymbolError methodsFor: 'as yet unclassified'!symbolName: argument	"Specify the function name that was beiing used."	symbolName := argument! !!ExternalSymbolError class methodsFor: 'as yet unclassified'!symbolName: argument	^self new symbolName: argument; yourself! !!FileDescriptor methodsFor: 'as yet unclassified'!close		self fileDescriptor > 2 ifTrue: [ 		LibC6 default close: self.		self fileDescriptor: -1.	]! !!FileDescriptor methodsFor: 'as yet unclassified'!fileDescriptor	^ SignedInteger objectFromHandle: handle. ! !!FileDescriptor methodsFor: 'as yet unclassified'!fileDescriptor: anInteger	handle := SignedInteger handleFromObject: anInteger. ! !!FileDescriptor methodsFor: 'as yet unclassified'!free		self close.! !!FileDescriptor methodsFor: 'as yet unclassified'!movePosition: offset"relative to actual position"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_CUR' ).	! !!FileDescriptor methodsFor: 'as yet unclassified'!position	^ self movePosition: 0.	! !!FileDescriptor methodsFor: 'as yet unclassified'!position: offset"absolute position"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_SET' ).! !!FileDescriptor methodsFor: 'as yet unclassified'!positionFromEnd: offset"relative to end of file"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_END' ).	! !!FileDescriptor methodsFor: 'as yet unclassified'!read: size	| retValue buffer |	buffer := ExternalBuffer new: size.	retValue := self readBuffer: buffer size: size.	! !!FileDescriptor methodsFor: 'as yet unclassified'!readBuffer: buffer size: size	^ LibC6 default read: self buffer: buffer size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!readString: aString	^ LibC6 default read: self string: aString size: aString size! !!FileDescriptor methodsFor: 'as yet unclassified'!readString: aString size: size	| internalSize |	internalSize := size.	aString size < size ifTrue: [ internalSize := aString size ].	^ LibC6 default read: self string: aString size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!size	| position size |	position := self position.	size := self positionFromEnd: 0.	self position: position.	^ size	! !!FileDescriptor methodsFor: 'as yet unclassified'!writeBuffer: buffer size: size	^ LibC6 default write: self buffer: buffer size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!writeString: aString	^ LibC6 default write: self string: aString size: aString size! !!FileDescriptor methodsFor: 'as yet unclassified'!writeString: aString size: size	| internalSize |	internalSize := size.	aString size < size ifTrue: [ internalSize := aString size ].	^ LibC6 default write: self string: aString size: size! !!FileDescriptor class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalValue! !!FileDescriptor class methodsFor: 'as yet unclassified'!initialize	self initializeStandardDescriptors! !!FileDescriptor class methodsFor: 'as yet unclassified'!initializeStandardDescriptors	StandardDescriptors := Dictionary new.	StandardDescriptors at: #stdout put: (self newFileDescriptor: 0).	StandardDescriptors at: #stdin put: (self newFileDescriptor: 1).	StandardDescriptors at: #stderr put: (self newFileDescriptor: 2).! !!FileDescriptor class methodsFor: 'as yet unclassified'!newFileDescriptor: anInteger	^ self new fileDescriptor: anInteger; yourself.! !!FileDescriptor class methodsFor: 'as yet unclassified'!standardDescriptors	^ StandardDescriptors! !!FileDescriptor class methodsFor: 'as yet unclassified'!stderr	^ StandardDescriptors at: #stderr.! !!FileDescriptor class methodsFor: 'as yet unclassified'!stdin	^ StandardDescriptors at: #stdin.! !!FileDescriptor class methodsFor: 'as yet unclassified'!stdout	^ StandardDescriptors at: #stdout.! !!FileStream methodsFor: 'as yet unclassified'!atEnd	"Answer true if the current position is >= the end of file position.	 1/31/96 sw: subclassResponsibility"	self subclassResponsibility! !!FileStream class methodsFor: 'as yet unclassified'!fileDoesNotExistUserHandling: fullFileName	(GtkMessageDialog question: fullFileName, ' does not exist, create it?') = #yes		ifTrue: [ ^ self new open: fullFileName forWrite: true ].! !!FileStream class methodsFor: 'as yet unclassified'!fileExistsUserHandling: fullFileName	(GtkMessageDialog question: fullFileName, ' exist, overwrite it?') = #yes		ifTrue: [ ^ self new openForOverwrite: fullFileName ].! !!FileStream class methodsFor: 'as yet unclassified'!readOnlyFileDoesNotExistUserHandling: fullFileName	GtkMessageDialog error: fullFileName, ' does not exist'! !!FileDoesNotExistException methodsFor: 'as yet unclassified'!defaultAction	"The default action taken if the exception is signaled."	^self readOnly		ifTrue: [FileStream readOnlyFileDoesNotExistUserHandling: self fileName]		ifFalse: [FileStream fileDoesNotExistUserHandling: self fileName]! !!GIRBuilder methodsFor: 'as yet unclassified'!compiledMethod	| bytecodes |	bytecodes := self bytecodes.	bytecodes ifNil: [ ^ nil ].	^ CompiledMethod new		primitive: 0;		numArgs: self numArgs;		numTemps: self numTemps;		literals: self literals;		relocationInfo: self relocationInfo;		bytecodes: bytecodes;		debugInfo: debugInfo;		source: source;		relocate.! !!GPointer methodsFor: 'as yet unclassified'!initialize	handle := self class defaultHandlerClass new.! !!GPointer class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalAddress! !!GPointer class methodsFor: 'as yet unclassified'!handle: aByteArray	^self basicNew handle: aByteArray; yourself! !!GObject class methodsFor: 'as yet unclassified'!handleFromObject: object	^ object handle.	! !!Gtk methodsFor: 'as yet unclassified'!initialize	self initializeGtkLibrary.	self startMainLoop.! !!Gtk class methodsFor: 'as yet unclassified'!shutDown: quiting	"Quits the Gtk main loop"	Default ifNotNil: [		Default quitMainLoop.		Default close.		Default := nil.	].! !!GtkDemoStockIds methodsFor: 'as yet unclassified'!initialize	| model tree |	model := GtkListStore new: {String. String. String. String}.	GtkStockItem allStocks do: [ :ea |		ea ifNotNil: [			model append: {				ea stockId asGtkStockId.				ea stockId.				ea label.				Gtk acceleratorName: ea keyval asCharacter modifier: ea modifier}]].	tree := GtkTreeView model: model.	self createFirstColumn: tree.	tree appendColumns: {		GtkTreeViewColumn title: 'Label' text: 2.		GtkTreeViewColumn title: 'Accel' text: 3.		GtkTreeViewColumn title: 'ID' text: 0}.	tree selection when: #changed send: #onItemChanged: to: self withArgumentsFirst: {tree}.			self container: (GtkHBox spacing: 5).	self container		packStart: (GtkScrolledWindow withChild: tree);		packEnd: self createInfoFrame expand: false fill: false! !!GtkDemoStockIds methodsFor: 'as yet unclassified'!onItemChanged: aTreeView	aTreeView selectedRow in: [:row |		idLabel label: row first.		nameLabel label: '#', row second.		accelLabel label: row third.		iconImage stock: row second iconSize: #dialog]! !!InMidstOfFileinNotification methodsFor: 'as yet unclassified'!defaultAction	^ self resume: false! !!LibC methodsFor: 'as yet unclassified'!closeLibrary	cLibrary closeLibrary.	cLibrary := nil.! !!LibC methodsFor: 'as yet unclassified'!initializeCLibrary	cLibrary := ExternalLibrary new.	cLibrary name: 'libc.so.6'.	cLibrary openLibrary.! !!LibC class methodsFor: 'as yet unclassified'!shutDown: quiting	"Quits the Gtk main loop"	self default closeLibrary.	Default := nil.! !!LibC6 methodsFor: 'as yet unclassified'!close: fd	| retValue |	retValue := ( self cDeclFunctionNamed: #close ) invokeWith: fd.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #close ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!errno	^ (self libraryDataNamed: #errno) value.	! !!LibC6 methodsFor: 'as yet unclassified'!errno: errno	(self libraryDataNamed: #errno) value: errno.	! !!LibC6 methodsFor: 'as yet unclassified'!free: anExternalBuffer	( self cDeclFunctionNamed: #free ) invokeWith: anExternalBuffer.	! !!LibC6 methodsFor: 'as yet unclassified'!getCurrentDirName	| retValue |	[ retValue := ( self cDeclFunctionNamed: 'get_current_dir_name' asSymbol ) invoke ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: 'get_current_dir_name' asSymbol ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!getEnv: envVariable	^ ( self cDeclFunctionNamed: #getenv ) invokeWith: envVariable.! !!LibC6 methodsFor: 'as yet unclassified'!getpid	^ (self cDeclFunctionNamed: #getpid) invoke.	! !!LibC6 methodsFor: 'as yet unclassified'!initialize	super initialize.	self initializeUniStd.	self initializeStdLib.	self initializeString.	self initializeFCntl.	self initializeStdIO.	self initializeErrNO.! !!LibC6 methodsFor: 'as yet unclassified'!initializeErrNO	self initializeLibraryDataNamed: #errno type: #SignedInteger.! !!LibC6 methodsFor: 'as yet unclassified'!initializeFCntl	self initializeCDeclFunctionNamed: #open returnType: #FileDescriptor argTypes: #( AsciiZ SignedInteger UnsignedInteger ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeStdIO	self initializeCDeclFunctionNamed: #printf  returnType: #SignedInteger argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: #perror  returnType: #Void argTypes: #( AsciiZ  ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeStdLib	self initializeCDeclFunctionNamed: #malloc  returnType: #ExternalBuffer argTypes: #( UnsignedInteger  ).	self initializeCDeclFunctionNamed: #free  returnType: #Void argTypes: #( ExternalBuffer  ).	self initializeCDeclFunctionNamed: #getenv  returnType: #AsciiZ argTypes: #( AsciiZ ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeString	self initializeCDeclFunctionNamed: #strlen returnType: #UnsignedInteger argTypes: #( AsciiZ ).	self initializeCDeclFunctionNamed: #strcat returnType: #AsciiZ argTypes: #( AsciiZ AsciiZ ).	self initializeCDeclFunctionNamed: #strcpy returnType: #AsciiZ argTypes: #( AsciiZ AsciiZ ).	self initializeCDeclFunctionNamed: #strerror returnType: #ReadOnlyAsciiZ argTypes: #( SignedInteger ).	self initializeCDeclFunctionNamed: #memset returnType: #ExternalBuffer argTypes: #( ExternalBuffer SignedInteger  UnsignedInteger ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeUniStd	self initializeCDeclFunctionNamed: #getpid  returnType: #UnsignedInteger argTypes: #().	self initializeCDeclFunctionNamed: 'get_current_dir_name' asSymbol  returnType: #AsciiZ argTypes: #().	self initializeCDeclFunctionNamed: #close  returnType: #SignedInteger argTypes: #( FileDescriptor ).	self initializeCDeclFunctionNamed: #lseek  returnType: #UnsignedInteger argTypes: #( FileDescriptor UnsignedInteger SignedInteger ).	self initializeCDeclFunctionNamed: #read  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalBuffer UnsignedInteger ).	self initializeCDeclFunctionNamed: #write  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalBuffer UnsignedInteger )."Redefinition of read for Strings"	symbolCache at: #readString put: (CDeclFunction name: #read library: self  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalArrayProxy UnsignedInteger ) )."Redefinition of write for Strings"	symbolCache at: #writeString put: (CDeclFunction name: #write library: self  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalArrayProxy UnsignedInteger ) ).! !!LibC6 methodsFor: 'as yet unclassified'!lseek: fileDescriptor offset: offset whence: whence	| returnValue |	returnValue := (self cDeclFunctionNamed: #lseek) invokeWith: fileDescriptor with: offset with: whence.	returnValue < 0 ifTrue: [		self throwErrorForExternalFunctionNamed: #lseek.		^ nil.	].	^ returnValue.	! !!LibC6 methodsFor: 'as yet unclassified'!malloc: size	| retValue |	[ retValue := ( self cDeclFunctionNamed: #malloc ) invokeWith: size ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: #malloc withMessage: 'can not allocate memory' ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!memSet: buffer constant: c count: n	^ (self cDeclFunctionNamed: #memset) invokeWith: buffer with: c with: n.	! !!LibC6 methodsFor: 'as yet unclassified'!open: path flags: flags	^ self open: path flags: flags mode: 8r644	! !!LibC6 methodsFor: 'as yet unclassified'!open: path flags: flags mode: mode	| fileDescriptor |	fileDescriptor := (self cDeclFunctionNamed: #open) invokeWith: path with: flags with: mode.	fileDescriptor fileDescriptor < 0 ifTrue: [		self throwErrorForExternalFunctionNamed: #open.		^ nil.	].	^ fileDescriptor.	! !!LibC6 methodsFor: 'as yet unclassified'!perror: aString	( self cDeclFunctionNamed: #perror ) invokeWith: aString.	! !!LibC6 methodsFor: 'as yet unclassified'!printf: aString	^ ( self cDeclFunctionNamed: #printf ) invokeWith: aString.	! !!LibC6 methodsFor: 'as yet unclassified'!read: fd buffer: buffer size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #read ) invokeWith: fd with: buffer with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #read ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!read: fd string: aString size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #readString ) invokeWith: fd with: aString with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #readString ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!strCat: destString with: sourceString	^ ( self cDeclFunctionNamed: #strcat ) invokeWith: destString with: sourceString.	! !!LibC6 methodsFor: 'as yet unclassified'!strCpy: destString with: sourceString	^ ( self cDeclFunctionNamed: #strcpy ) invokeWith: destString with: sourceString.	! !!LibC6 methodsFor: 'as yet unclassified'!strError: errno	| retValue |	[ retValue := ( self cDeclFunctionNamed: #strerror ) invokeWith: errno ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: #strerror ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!strLen: string	^ ( self cDeclFunctionNamed: #strlen ) invokeWith: string	! !!LibC6 methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName	^ self throwErrorForExternalFunctionNamed: functionName withMessage: (self strError: self errno).	! !!LibC6 methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName withMessage: aString	| error |	error := ExternalFunctionError functionName: functionName.	error messageText: aString.	^ error signal.	! !!LibC6 methodsFor: 'as yet unclassified'!valueForLSeekDirectiveNamed: aString	^ LSeekDirectives at: aString asSymbol.	! !!LibC6 methodsFor: 'as yet unclassified'!valueForOpenFlagNamed: aString	^ OpenFlags at: aString asSymbol.	! !!LibC6 methodsFor: 'as yet unclassified'!write: fd buffer: buffer size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #write ) invokeWith: fd with: buffer with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #write ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!write: fd string: aString size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #writeString ) invokeWith: fd with: aString with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #writeString ].	^ retValue.	! !!LibC6 class methodsFor: 'as yet unclassified'!initialize	self initializeOpenFlags.	self initializeLSeekDirectives.! !!LibC6 class methodsFor: 'as yet unclassified'!initializeLSeekDirectives	| lSeekDirectives |		lSeekDirectives := Dictionary new.	lSeekDirectives at: 'SEEK_SET' put: 0.	lSeekDirectives at: 'SEEK_CUR' put: 1.	lSeekDirectives at: 'SEEK_END' put: 2.	LSeekDirectives := lSeekDirectives! !!LibC6 class methodsFor: 'as yet unclassified'!initializeOpenFlags	| flagArray openFlags |		flagArray := #( 		('O_RDONLY'		0)		('O_WRONLY'		8r1)		('O_RDWR'		8r2)		('O_CREAT'		8r100)			('O_EXCL'			8r200)			('O_NOCTTY'		8r400)			('O_TRUNC'		8r1000)			('O_APPEND'		8r2000)		('O_NONBLOCK'	8r4000)		('O_SYNC'		8r10000)		('O_ASYNC'		8r20000)	).	openFlags := Dictionary new.	flagArray do: [ :i |		openFlags at: i first asSymbol put: i second	].	OpenFlags := openFlags! !!LibC6 class methodsFor: 'as yet unclassified'!moduleName	^ 'libc.so.6'.! !!LibExample methodsFor: 'as yet unclassified'!getpid	^ GETPID invoke! !!LibExample class methodsFor: 'as yet unclassified'!getpid	^ GETPID! !!LibExample class methodsFor: 'as yet unclassified'!initialize	GETPID := CDeclFunction name: 'getpid' libraryNamed: 'libc.so.6' returnType: #UnsignedInteger argTypes: #().! !!LibReadLine methodsFor: 'as yet unclassified'!addHistory: aString	( self cDeclFunctionNamed: 'add_history' asSymbol ) invokeWith: aString.! !!LibReadLine methodsFor: 'as yet unclassified'!initialize	super initialize.	self initializeCDeclFunctionNamed: #readline  returnType: #AsciiZ argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'add_history' asSymbol returnType: #Void argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'read_history' asSymbol returnType: #SignedInteger argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'write_history' asSymbol returnType: #SignedInteger argTypes: #( AsciiZ  ).! !!LibReadLine methodsFor: 'as yet unclassified'!readHistory: aFileName	| errno |	errno := ( self cDeclFunctionNamed: 'read_history' asSymbol ) invokeWith: aFileName.	errno = 0 ifFalse: [ self throwErrorForExternalFunctionNamed: 'read_history' asSymbol errno: errno ].	^ errno.! !!LibReadLine methodsFor: 'as yet unclassified'!readline: prompt	^ ( self cDeclFunctionNamed: #readline ) invokeWith: prompt.! !!LibReadLine methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName errno: errno	| error |	error := ExternalFunctionError functionName: functionName.	error messageText: (LibC6 default strError: errno).	^ error signal.! !!LibReadLine methodsFor: 'as yet unclassified'!writeHistory: aFileName	| errno |	errno := ( self cDeclFunctionNamed: 'write_history' asSymbol ) invokeWith: aFileName.	errno = 0 ifFalse: [ self throwErrorForExternalFunctionNamed: 'write_history' asSymbol errno: errno ].	^ errno.! !!LibReadLine class methodsFor: 'as yet unclassified'!moduleName	^ 'libreadline.so'.! !!LibraryData methodsFor: 'as yet unclassified'!primitiveGetValue: valueHandle	<primitive: 216>	^self primitiveFailed! !!LibraryData methodsFor: 'as yet unclassified'!primitiveSetValue: valueHandle	<primitive: 217>	^self primitiveFailed! !!LibraryData methodsFor: 'as yet unclassified'!type	^ type.! !!LibraryData methodsFor: 'as yet unclassified'!type: aType	type := aType.! !!LibraryData methodsFor: 'as yet unclassified'!value	| valueClass valueHandle |	valueClass := self classFromType: type.	valueHandle := valueClass defaultHandlerClass new.	handle isNull ifTrue: [ self bind ].	self primitiveGetValue: valueHandle.	^ valueClass objectFromHandle: valueHandle.! !!LibraryData methodsFor: 'as yet unclassified'!value: aValue	| argHandle argClass |	argClass := self classFromType: type.	argHandle := argClass handleFromObject: aValue.	handle isNull ifTrue: [ self bind ].	self primitiveSetValue: argHandle! !!LibraryData class methodsFor: 'as yet unclassified'!name: aName library: aLibrary type: type	^self new name: aName library: aLibrary;		type: type;		bind! !!Metaclass methodsFor: 'as yet unclassified'!addObsoleteSubclass: aClass	"Do nothing."! !!Metaclass methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return true if it is safe to zap the method dictionary on #obsolete"	thisClass == nil		ifTrue:[^true]		ifFalse:[^thisClass canZapMethodDictionary]! !!Metaclass methodsFor: 'as yet unclassified'!isSystemDefined	"Answer false if I am a UniClass (an instance-specific lightweight class)"	^ true! !!NativeFunction methodsFor: 'as yet unclassified'!callingConventionString	^ 'native'! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver	^self invokeReceiver: receiver withArguments: #()! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1	^self invokeReceiver: receiver withArguments: (Array with: arg1)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4 with: arg5	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver withArguments: argArray	handle isNull ifTrue: [ self bind ].	^ self primInvokeReceiver: receiver withArguments: argArray.! !!NativeFunction methodsFor: 'as yet unclassified'!primInvokeReceiver: receiver withArguments: argArray	"Manually invoke the receiver, representing an native function."	<primitive: 197>	^self primitiveFailed! !!ObjectTest methodsFor: 'as yet unclassified'!testBecome	"self debug: #testBecome"	"this test should that all the variables pointing to an object are pointing now to another one, and all      object pointing to the other are pointing to the object"	| pt1 pt2 pt3 |	pt1 := 0@0.	pt2 := pt1.	pt3 := 100@100.	pt1 become: pt3.	self assert: pt2 = (100@100).	self assert: pt3 = (0@0).	self assert: pt1 = (100@100).! !!ObjectTest methodsFor: 'as yet unclassified'!testBecomeForward	"self debug: #testBecomeForward"	"this test should that all the variables pointing to an object are pointing now to another one.	Not that this inverse is not true. This kind of become is called oneWayBecome in VW"	| pt1 pt2 pt3 |	pt1 := 0@0.	pt2 := pt1.	pt3 := 100@100.	pt1 becomeForward: pt3.	self assert: pt2 = (100@100).	self assert: pt3 == pt2.	self assert: pt1 = (100@100)! !!PrimitiveType class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalValue! !!PrimitiveType class methodsFor: 'as yet unclassified'!handleFromObject: anObject	^ self handleFromObject: anObject ifError: [ self throwTypeConvertionError ]! !!PrimitiveType class methodsFor: 'as yet unclassified'!handleFromObject: object ifError: aBlock	self subclassResponsibility.! !!PrimitiveType class methodsFor: 'as yet unclassified'!objectFromHandle: handle	^ self objectFromHandle: handle ifError: [  self throwTypeConvertionError ]! !!PrimitiveType class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock	self subclassResponsibility.! !!PrimitiveType class methodsFor: 'as yet unclassified'!throwTypeConvertionError	^ TypeConvertionError new signal! !!IntegerType class methodsFor: 'as yet unclassified'!handleFromObject: anInteger ifError: aBlock	| handle |		(self checkType: anInteger) ifFalse: [ ^ aBlock value ].	handle := ExternalValue new.	self store: anInteger in: handle.	^ handle.	! !!IntegerType class methodsFor: 'as yet unclassified'!isBigEndian	^  false! !!IntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	self subclassResponsibility.! !!IntegerType class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: errorBlock	| value |		value := self loadFrom: handle.	(value > self max ) ifTrue: [ ^ errorBlock value ].	^ value.! !!Process methodsFor: 'as yet unclassified'!primitiveBeInitialProcess	<primitive: 196>	self primitiveFailed! !!ProcessorScheduler methodsFor: 'as yet unclassified'!activeProcess	^ self primActiveProcess! !!ProcessorScheduler methodsFor: 'as yet unclassified'!primActiveProcess	<primitive: 195>	self primitiveFail.! !!ProcessorScheduler methodsFor: 'as yet unclassified'!startUp	| firstProcess |"	(processList isNil or: [ processList isEmpty not ]) ifTrue: [ self initialize ]."	self initialize.	firstProcess := Process new.	firstProcess name: 'Init'.	firstProcess priority: self userSchedulingPriority.	firstProcess state: #running."	firstProcess threadData: self activeThreadData."	firstProcess primitiveBeInitialProcess.! !!ReadOnlyAsciiZ methodsFor: 'as yet unclassified'!asString	^ handle toString.! !!ReadOnlyAsciiZ class methodsFor: 'as yet unclassified'!handleFromObject: aByteArray ifError: aBlock	"Can not be used as arguments"	aBlock value.! !!ReadOnlyAsciiZ class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; asString! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!addressRelativeTo: bytecodes	| functionAddress bytecodesAddress |	functionAddress := self function address asInteger.	bytecodesAddress := (ExternalAddress forArray: bytecodes ) asInteger.	^ functionAddress - bytecodesAddress - offset - 4! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!function	^ self library functionNamed: functionName.! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!functionName	^ functionName! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!functionName: aSymbol	^ functionName := aSymbol! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!library	^ Executable default! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!patch: bytecodes	self patch: bytecodes with: (self addressRelativeTo: bytecodes).! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!patch: bytecodes with: value	bytecodes longAt: (offset + 1) put: value bigEndian: false.! !!FunctionRelocation methodsFor: 'as yet unclassified'!addressRelativeTo: bytecodes	^ self primAddressRelativeTo: bytecodes! !!FunctionRelocation methodsFor: 'as yet unclassified'!primAddressRelativeTo: bytecodes	<primitive: 155>	self primitiveFail.! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!defaultLibraryClass	^ NativeLibrary! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!library 		^ self defaultLibraryClass named: libraryName! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!libraryName	^ libraryName! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!libraryName: aSymbol	^ libraryName := aSymbol! !!ExternalFunctionRelocation methodsFor: 'as yet unclassified'!defaultLibraryClass	^ ExternalLibrary2! !!SequenceableCollection methodsFor: 'as yet unclassified'!asTraitComposition	"For convenience the composition {T1. T2 ...} is the same as T1 + T2 + ..."	^self isEmpty		ifFalse: [			self size = 1				ifTrue: [self first asTraitComposition]				ifFalse: [					self copyWithoutFirst 						inject: self first						into: [:left :right | left + right]]]		ifTrue: [			TraitComposition new]! !!Array methodsFor: 'as yet unclassified'!elementsExchangeIdentityWith: otherArray	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsExchangeIdentityWith: otherArray.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!elementsForwardIdentityTo: otherArray	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsForwardIdentityTo: otherArray.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!elementsForwardIdentityTo: otherArray copyHash: copyHash	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsForwardIdentityTo: otherArray copyHash: copyHash.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!primElementsExchangeIdentityWith: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  At the same time, all pointers to the elements of otherArray are replaced by pointers to the corresponding elements of this array.  The identityHashes remain with the pointers rather than with the objects so that objects in hashed structures should still be properly indexed after the mutation."	<primitive: 128>	otherArray class == Array ifFalse: [^ self error: 'arg must be array'].	self size = otherArray size ifFalse: [^ self error: 'arrays must be same size'].	(self anySatisfy: [:obj | obj class == SmallInteger]) ifTrue: [^ self error: 'can''t become SmallIntegers'].	(otherArray anySatisfy: [:obj | obj class == SmallInteger]) ifTrue: [^ self error: 'can''t become SmallIntegers'].	"Must have failed because not enough space in forwarding table (see ObjectMemory-prepareForwardingTableForBecoming:with:twoWay:).  Do GC and try again only once"	(Smalltalk bytesLeft: true) = Smalltalk primitiveGarbageCollect		ifTrue: [^ self primitiveFailed].	^ self elementsExchangeIdentityWith: otherArray! !!Array methodsFor: 'as yet unclassified'!primElementsForwardIdentityTo: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  The identityHashes remain with the pointers rather than with the objects so that the objects in this array should still be properly indexed in any existing hashed structures after the mutation."	<primitive: 72>	self primitiveFailed! !!Array methodsFor: 'as yet unclassified'!primElementsForwardIdentityTo: otherArray copyHash: copyHash	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  The identityHashes remain with the pointers rather than with the objects so that the objects in this array should still be properly indexed in any existing hashed structures after the mutation."	<primitive: 249>	self primitiveFailed! !!ExternalValue methodsFor: 'as yet unclassified'!beNull	"Make the receiver a NULL pointer"	self atAllPut: 0.! !!ExternalValue methodsFor: 'as yet unclassified'!isNull	^(self basicAt: 1) = 0	and: (self basicAt: 2) = 0	and: (self basicAt: 3) = 0	and: (self basicAt: 4) = 0	! !!ExternalValue class methodsFor: 'as yet unclassified'!initialize	Smalltalk addToStartUpList: self.! !!ExternalValue class methodsFor: 'as yet unclassified'!new	"External addresses are always 4 bytes long"	^super new: 4! !!ExternalValue class methodsFor: 'as yet unclassified'!new: n	"You better don't try this..."	^self shouldNotImplement! !!ExternalValue class methodsFor: 'as yet unclassified'!startUp: resuming	resuming ifTrue: [		self allInstancesDo: [ :addr |			addr beNull		]	].! !!SharedPool class methodsFor: 'as yet unclassified'!bindingOf: varName	"Answer the binding of some variable resolved in the scope of the receiver"	| aSymbol binding |	aSymbol := varName asSymbol.	"First look in classVar dictionary."	binding := self classPool bindingOf: aSymbol.	binding ifNotNil:[^binding].	"Next look in shared pools."	self sharedPools do:[:pool | 		binding := pool bindingOf: aSymbol.		binding ifNotNil:[^binding].	].	"subclassing and environment are not preserved"	^nil! !!SharedPool class methodsFor: 'as yet unclassified'!bindingsDo: aBlock	^self classPool bindingsDo: aBlock! !!SharedPool class methodsFor: 'as yet unclassified'!classBindingOf: varName	"For initialization messages grant the regular scope"	^super bindingOf: varName! !!SharedPool class methodsFor: 'as yet unclassified'!hasBindingThatBeginsWith: aString	"Answer true if the receiver has a binding that begins with aString, false otherwise"	"First look in classVar dictionary."	(self classPool hasBindingThatBeginsWith: aString) ifTrue:[^true].	"Next look in shared pools."	self sharedPools do:[:pool | 		(pool hasBindingThatBeginsWith: aString) ifTrue: [^true]].	^false! !!SharedPool class methodsFor: 'as yet unclassified'!includesKey: aName	"does this pool include aName"	^(self bindingOf: aName) notNil! !!SharedPool class methodsFor: 'as yet unclassified'!keysDo: aBlock"A hopefully temporary fix for an issue arising from miss-spelled variable names in code being compiled. The correction code (see Class>possibleVariablesFor:continuedFrom: assumes that sharedPools are Dictionaries. The proper fix would involve making sure all pools are actually subclasses of SharedPool, which they are not currently."	self bindingsDo:[:b|		aBlock value: b key]! !!Shell methodsFor: 'as yet unclassified'!display: string	| buffer |		buffer := AsciiZ fromString: string.	^ FileDescriptor stdout writeBuffer: buffer size: buffer size.! !!Shell methodsFor: 'as yet unclassified'!input: prompt	^ LibReadLine default readline: prompt! !!Shell methodsFor: 'as yet unclassified'!main	| line value failed anotherLine buffer |	LibReadLine default readHistory: self historyFileName.	[		anotherLine := false.		buffer := ''.		[ 	| prompt |			prompt := anotherLine ifTrue: [ '' ] ifFalse: [ '> ' ].			line _ self input: prompt.			line isEmpty				ifTrue: [ true ] 				ifFalse: [					(line last = $\)						ifTrue: [							anotherLine := true.							line at: line size put: Character lf.						]						ifFalse: [ anotherLine := false ].					buffer := buffer, line.					anotherLine				]		] whileTrue. 		buffer = 'quit' or: [ buffer = 'save' ]	] whileFalse: [		self addToHistory: buffer.		failed _ false.		value _ Compiler new evaluate: buffer in: nil to: nil notifying: self ifFail: [ failed _ true].		failed ifFalse: [ self display: (value printString); lf ]	].	LibReadLine default writeHistory: self historyFileName.	buffer = 'save' ifTrue: [ Smalltalk snapshotAndQuit ].	^value.! !!SignedIntegerType class methodsFor: 'as yet unclassified'!checkType: value	^ value isInteger and: [ value >= self min and: [ value <= self max ] ]! !!SignedIntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	^ handle longAt: 1 bigEndian: self isBigEndian.! !!SignedIntegerType class methodsFor: 'as yet unclassified'!store: anInteger in: handle	handle longAt: 1 put: anInteger bigEndian: self isBigEndian.! !!SignedByte class methodsFor: 'as yet unclassified'!max			^ 127! !!SignedByte class methodsFor: 'as yet unclassified'!min			^ -128! !!SignedInteger class methodsFor: 'as yet unclassified'!max			^ 2147483647! !!SignedInteger class methodsFor: 'as yet unclassified'!min			^ -2147483648! !!SignedShortInteger class methodsFor: 'as yet unclassified'!max			^ 32767! !!SignedShortInteger class methodsFor: 'as yet unclassified'!min			^ -32768! !!SourceReference methodsFor: 'as yet unclassified'!sourceFrom: aString	self hasEmptySourceReference ifTrue: [ ^ '' ].	^ aString copyFrom: sourceStart to: sourceStop! !!StandardFileStream class methodsFor: 'as yet unclassified'!retryWithGC: execBlock until: testBlock forFileNamed: fullName	"Re-implemented to only force GC if a file with the given name exists"	| blockValue foundIt |	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	"See if we have a file with the given name"	foundIt := self registry keys "hold on strongly for now" 		anySatisfy:[:file| file name sameAs: fullName].	foundIt ifFalse:[^blockValue].	Smalltalk garbageCollectMost.	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollect.	^execBlock value.! !!SystemDictionary methodsFor: 'as yet unclassified'!forgetClass: aClass logged: aBool 	"Delete the class, aClass, from the system.	Note that this doesn't do everything required to dispose of a class - to do that use Class>>removeFromSystem."	aBool ifTrue: [SystemChangeNotifier uniqueInstance classRemoved: aClass fromCategory: aClass category].			SystemOrganization removeElement: aClass name.	self removeFromStartUpList: aClass.	self removeFromShutDownList: aClass.	self removeKey: aClass name ifAbsent: [].	self flushClassNameCache! !!SystemDictionary methodsFor: 'as yet unclassified'!removeClassNamed: aName	"Invoked from fileouts:  if there is currently a class in the system named aName, then remove it.  If anything untoward happens, report it in the Transcript.  "	| oldClass |	(oldClass _ self at: aName asSymbol ifAbsent: [nil]) == nil		ifTrue:			[Transcript cr; show: 'Removal of class named ', aName, ' ignored because ', aName, ' does not exist.'.			^ self].	oldClass removeFromSystem! !!SystemDictionary methodsFor: 'as yet unclassified'!startUp	Processor startUp.	ProcessorScheduler startUp.	self processStartUpList: true.	self installLowSpaceWatcher.! !!SystemTracer methodsFor: 'as yet unclassified'!getAligned: size	^ (( size + 3 ) bitShift: -2) bitShift: 2.! !!TraitBehavior methodsFor: 'as yet unclassified'!addUser: aClassOrTrait	users add: aClassOrTrait! !!TraitBehavior methodsFor: 'as yet unclassified'!classesComposedWithMe	^users gather: [:u | u classesComposedWithMe]! !!TraitBehavior methodsFor: 'as yet unclassified'!initialize	self methodDict: Dictionary new.	self traitComposition: nil.	users _ IdentitySet new.! !!TraitBehavior methodsFor: 'as yet unclassified'!removeUser: aClassOrTrait	users remove: aClassOrTrait ifAbsent: []! !!TraitBehavior methodsFor: 'as yet unclassified'!users	^users! !!TraitComposition methodsFor: 'as yet unclassified'!assertValidUser: aBehavior	"Assert that this trait composition set for aBehavior	does not introduce a cycle."		(self allTraits includes: aBehavior) ifTrue: [		TraitCompositionException signal: 'Cycle in compositions:  The composition (in)directly includes this trait!!']! !!TraitComposition methodsFor: 'as yet unclassified'!methodDescriptionsForSelector: aSymbol	"Return a collection of TraitMethodDescriptions for aSymbol and all the 	aliases of aSymbol."	| selectors collection |	selectors _ IdentitySet with: aSymbol.	self transformations do: [:each |		selectors addAll: (each aliasesForSelector: aSymbol)].	collection _ OrderedCollection new: selectors size.	selectors do: [:each |		collection add: (self methodDescriptionForSelector: each)].	^collection! !!TraitDescription methodsFor: 'as yet unclassified'!trait	"for compatibility with TraitTransformations"	^ self! !!TraitDescription methodsFor: 'as yet unclassified'!updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil	| currentCategory effectiveCategory sel changedCategories composition |	changedCategories _ IdentitySet new.	composition := self hasTraitComposition		ifTrue: [self traitComposition]		ifFalse: [TraitComposition new].	(composition methodDescriptionsForSelector: aSymbol) do: [:each |		sel _ each selector.		(self includesLocalSelector: sel) ifFalse: [			currentCategory _ self organization categoryOfElement: sel.			effectiveCategory _ each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.			effectiveCategory isNil ifTrue: [				currentCategory ifNotNil: [changedCategories add: currentCategory].				self organization removeElement: sel.			] ifFalse: [				((currentCategory isNil or: [currentCategory == ClassOrganizer ambiguous or: [currentCategory == oldCategoryOrNil]]) and: [currentCategory ~~ effectiveCategory]) ifTrue: [					currentCategory ifNotNil: [changedCategories add: currentCategory].					self organization 						classify: sel 						under: effectiveCategory						suppressIfDefault: false]]]].	^ changedCategories! !!TraitDescription methodsFor: 'as yet unclassified'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	(self includesSelector: aSelector)		ifTrue: [^ self organization categoryOfElement: aSelector]		ifFalse: [^nil]! !!Trait methodsFor: 'as yet unclassified'!initialize	super initialize.	classTrait _ ClassTrait for: self! !!TranscriptCodeView class methodsFor: 'as yet unclassified'!initialize	Smalltalk addToStartUpList: self.! !!TranscriptCodeView class methodsFor: 'as yet unclassified'!startUp: resuming	resuming ifTrue: [		TranscriptCodeBuffer := nil.	].! !!TranscriptStream methodsFor: 'as yet unclassified'!open	TranscriptCodeEditor open.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!atEnd	position ifNil: [ ^ nil ].	^ position >= readLimit! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!close	"Close this file."	fileID ifNotNil: [		fileID close.		fileID := nil.		position := nil.	].! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!open: fileName flags: flags	[ fileID := LibC6 default open: fileName flags: flags ]		on: ExternalFunctionError		do: [ ^ nil ].	name := fileName.	readLimit := fileID size.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!open: fileName forWrite: writeMode 	| flags |	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	flags := writeMode 		ifTrue: [ LibC6 default valueForOpenFlagNamed: 'O_RDWR' ]		ifFalse: [ LibC6 default valueForOpenFlagNamed: 'O_RDONLY' ].	rwmode := writeMode.	^ self open: fileName flags: flags.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!openForOverwrite: fileName	| flags |	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	flags := ((LibC6 default valueForOpenFlagNamed: 'O_RDWR') 			bitOr: ( LibC6 default valueForOpenFlagNamed: 'O_TRUNC' )) 			bitOr: ( LibC6 default valueForOpenFlagNamed: 'O_CREAT' ).	rwmode := true.	^ self open: fileName flags: flags.! !!BufferedFileStream methodsFor: 'as yet unclassified'!close	"Close this file."	self flush.	^ super close.! !!BufferedFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	self subclassResponsibility! !!BufferedFileStream methodsFor: 'as yet unclassified'!defaultBufferSize	^ DefaultBufferSize.! !!BufferedFileStream methodsFor: 'as yet unclassified'!flush	| bufferPosition bufferSize |	fileID ifNil: [ ^ nil ].	rwmode ifFalse: [ ^ nil ].	bufferPosition := position truncateTo: (collection size).	bufferSize := collection size min: ( readLimit - bufferPosition).	fileID position: bufferPosition.	bufferSize > 0 ifTrue: [ fileID writeString: collection size: bufferSize ].	 ! !!BufferedFileStream methodsFor: 'as yet unclassified'!initializeBuffer	| bufferSize |	position := 0.	collection := self defaultBufferClass new: self defaultBufferSize.	bufferSize := collection size min: readLimit.	bufferSize > 0 ifTrue: [ fileID readString: collection size: bufferSize ]. ! !!BufferedFileStream methodsFor: 'as yet unclassified'!next	| byte |	byte := self peek.	self position: position + 1.	^ byte! !!BufferedFileStream methodsFor: 'as yet unclassified'!nextPut: char	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	position ifNil: [ self position: 0 ].	collection at: (position \\ (collection size)) + 1put: char.	self position: position + 1.	^ char! !!BufferedFileStream methodsFor: 'as yet unclassified'!open: fileName flags: flags	(super open: fileName flags: flags) ifNotNil: [ self initializeBuffer ].! !!BufferedFileStream methodsFor: 'as yet unclassified'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	position ifNil: [ self position: 0 ].	self atEnd ifTrue: [^ nil ].	^ collection at: (position \\ (collection size)) + 1.! !!BufferedFileStream methodsFor: 'as yet unclassified'!position: newPosition	| oldBufferPosition newBufferPosition bufferSize |	fileID ifNil: [ ^nil ].	newPosition < 0 ifTrue: [ ^nil ]."	((newPosition > readLimit) and: [ rwmode not ])  ifTrue: [ ^nil ]."	newPosition > readLimit ifTrue: [		rwmode ifTrue: [ readLimit := newPosition ] ifFalse: [ ^nil ]	].	oldBufferPosition := position truncateTo: (collection size).	newBufferPosition := newPosition truncateTo: (collection size).	newBufferPosition = oldBufferPosition ifFalse: [ 		self flush.		fileID position: newBufferPosition.		bufferSize := collection size min: ( readLimit - newBufferPosition).		collection := self defaultBufferClass new: self defaultBufferSize.		bufferSize > 0 ifTrue: [ fileID readString: collection size: bufferSize ].	].	position := newPosition."	rwmode ifTrue: [ readLimit := newPosition ]."	^ position.! !!BinaryFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	^ ByteArray! !!TextFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	^ String! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!concreteStream	"Who should we really direct class queries to?  "	^ UnbufferedFileStream.! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!fileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new open: fileName forWrite: true! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!forceNewFileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new openForOverwrite: fileName! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!readOnlyFileNamed: fileName 	"Open an existing file with the given name for reading."	| f |	f := self new open: fileName forWrite: false.	^ f isNil		ifFalse: [f]		ifTrue: ["File does not exist..."			((FileDoesNotExistException fileName: fileName) readOnly: true) signal].	"StandardFileStream readOnlyFileNamed: 'kjsd.txt' "! !!BufferedFileStream class methodsFor: 'as yet unclassified'!initialize	self initializeDefaultBufferSize.! !!BufferedFileStream class methodsFor: 'as yet unclassified'!initializeDefaultBufferSize	DefaultBufferSize := 4096.! !!BufferedFileStream class methodsFor: 'as yet unclassified'!new	^ TextFileStream new.! !!UnhandledError methodsFor: 'as yet unclassified'!devDefaultAction	"The current computation is terminated. The cause of the error should be logged or reported to the user. If the program is operating in an interactive debugging environment the computation should be suspended and the debugger activated."	(GtkMessageDialog question: exception messageText, ', debug it?' ) = #yes		ifTrue: [ ^Processor activeProcess debugError: exception ]."	^ Processor activeProcess terminate."! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!checkType: value	^ value isInteger and: [ value >= 0 and: [ value <= self max ] ]! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	^ handle unsignedLongAt: 1 bigEndian: self isBigEndian.! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!min	^ 0! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!store: anInteger in: handle	handle unsignedLongAt: 1 put: anInteger bigEndian: self isBigEndian.! !!UnsignedByte class methodsFor: 'as yet unclassified'!max			^ 255! !!UnsignedInteger class methodsFor: 'as yet unclassified'!max			^ 4294967295! !!UnsignedShortInteger class methodsFor: 'as yet unclassified'!max			^ 65535! !!Workspace methodsFor: 'as yet unclassified'!buildMenuBar	| menu  edit  |	menu := GtkMenuBar new.	edit := GtkMenu new.	menu		append: AppLauncher fileMenu;		append: (edit createMenuItem: '_Edit');		append: workspaceView menu;		append: AppLauncher toolsMenu;		append: AppLauncher helpMenu.					^ menu.! !!Workspace methodsFor: 'as yet unclassified'!buildToolBar	| toolBar |	^ GtkToolbar new		appendItems: workspaceView toolBar;		yourself! !!Workspace methodsFor: 'as yet unclassified'!defaultCodeViewClass	^ WorkspaceView! !!Workspace methodsFor: 'as yet unclassified'!initialize	workspaceView := self defaultCodeViewClass new.	self container: (GtkVBox new		packStart: (self buildMenuBar) expand: false;		packStart: (self buildToolBar) expand: false;		packStart: (workspaceView view);		packStart: (GtkStatusbar new) expand: false	).! !!Workspace methodsFor: 'as yet unclassified'!inspectedVar: anObject	workspaceView inspectedVar: anObject.! !!TranscriptCodeEditor methodsFor: 'as yet unclassified'!defaultCodeViewClass	^ TranscriptCodeView! !!Workspace class methodsFor: 'as yet unclassified'!defaultSize	^ 640@480.! !!Workspace class methodsFor: 'as yet unclassified'!title	^'Workspace'! !!TranscriptCodeEditor class methodsFor: 'as yet unclassified'!title	^'Transcript'! !BufferedFileStream initialize!TranscriptCodeView initialize!TraitBehavior removeSelector: #initializeUsers!Application subclass: #Shell	instanceVariableNames: 'bindings'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!ExternalValue initialize!NativeFunctionRelocation removeSelector: #addressRelativeTo:!NativeFunctionRelocation removeSelector: #function!NativeFunctionRelocation removeSelector: #functionName!NativeFunctionRelocation removeSelector: #functionName:!NativeFunctionRelocation removeSelector: #patch:!NativeFunctionRelocation removeSelector: #patch:with:!ReadOnlyAsciiZ class removeSelector: #objectFromHandle:!ProcessorScheduler removeSelector: #activeProcess2!ProcessorScheduler removeSelector: #activeThreadData!ProcessorScheduler removeSelector: #primActiveThreadData!Process removeSelector: #threadData:!PrimitiveType class removeSelector: #defaultHandlerType!PrimitiveType class removeSelector: #instantiateHandler!NativeFunction removeSelector: #address!NativeFunction removeSelector: #bind!NativeFunction removeSelector: #invoke!NativeFunction removeSelector: #invokeAnswering:!NativeFunction removeSelector: #invokeAnswering:with:!NativeFunction removeSelector: #invokeAnswering:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:withArguments:!NativeFunction removeSelector: #invokeWith:!NativeFunction removeSelector: #invokeWith:with:!NativeFunction removeSelector: #invokeWith:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:with:with:!NativeFunction removeSelector: #invokeWithArguments:!NativeFunction removeSelector: #name!NativeFunction removeSelector: #name:!NativeFunction removeSelector: #throwNotKnownError!LibraryData removeSelector: #primitiveGetValue!LibExample initialize!LibC6 initialize!LibC6 removeSelector: #initializeUnistd!LibC6 removeSelector: #openPath:flags:!LibC6 removeSelector: #write2:buffer:size:!LibC removeSelector: #close!GPointer class removeSelector: #instantiateHandler!FileStream removeSelector: #position!FileDescriptor initialize!FileDescriptor removeSelector: #movePositionTo:!FileDescriptor removeSelector: #name!FileDescriptor removeSelector: #name:!FileDescriptor removeSelector: #positionFromEns:!FileDescriptor removeSelector: #setPositionAt:!FileDescriptor removeSelector: #setPositionFromEndAt:!CDeclFunction class removeSelector: #name:libraryNamed:returnType:argTypes:!ExecutableFunction class removeSelector: #name:library:!ExecutableFunction class removeSelector: #name:libraryNamed:!CDeclFunction removeSelector: #classFromType:!CDeclFunction removeSelector: #throwExternalFunctionError!ExecutableFunction removeSelector: #address!ExecutableFunction removeSelector: #bind!ExecutableFunction removeSelector: #invoke!ExecutableFunction removeSelector: #invokeWith:!ExecutableFunction removeSelector: #invokeWith:with:!ExecutableFunction removeSelector: #invokeWith:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithArguments:!ExecutableFunction removeSelector: #invokeWithReceiver:!ExecutableFunction removeSelector: #invokeWithReceiver:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:withArguments:!ExecutableFunction removeSelector: #library!ExecutableFunction removeSelector: #library:!ExecutableFunction removeSelector: #libraryName!ExecutableFunction removeSelector: #libraryNamed:!ExecutableFunction removeSelector: #name!ExecutableFunction removeSelector: #name:!ExecutableFunction removeSelector: #name:library:!ExecutableFunction removeSelector: #name:libraryNamed:!ExecutableFunction removeSelector: #primInvokeReceiver:withArguments:!ExecutableFunction removeSelector: #primInvokeWithArguments:!ExecutableFunction removeSelector: #primInvokeWithReceiver:withArguments:!ExecutableFunction removeSelector: #throwNotKnownError!ExternalSymbol removeSelector: #callingConventionString!ExternalObjectProxy removeSelector: #register!ExternalObjectProxy removeSelector: #unregister!AsciiZ class removeSelector: #objectFromHandle:!Executable class removeSelector: #huenul!DynamicLibrary class removeSelector: #addLibrary:named:!DynamicLibrary class removeSelector: #huemul!DynamicLibrary initialize!DynamicLibrary class removeSelector: #name:!DynamicLibrary class removeSelector: #named:!ExternalObject class removeSelector: #handle:!ExternalObject initialize!ExternalObject class removeSelector: #registry!ExternalObject class removeSelector: #registry:!AsciiZ removeSelector: #setFrom:!ExternalBuffer removeSelector: #finalize!ExternalBuffer removeSelector: #selfCheck!ExternalBuffer removeSelector: #setFrom:!ExternalBuffer removeSelector: #storeInto:size:!Executable removeSelector: #initialize!Executable removeSelector: #instantiateFunctionClass:!Executable removeSelector: #name:!Executable removeSelector: #nativeFunctionNamed:!Executable removeSelector: #primitiveOpen!DynamicLibrary removeSelector: #addExternal:!DynamicLibrary removeSelector: #basicName!DynamicLibrary removeSelector: #bind:!DynamicLibrary removeSelector: #bindFunction:!DynamicLibrary removeSelector: #cDeclFunctionNamed:returnType:argTypes:!DynamicLibrary removeSelector: #primitiveBind:!DynamicLibrary removeSelector: #primitiveBindFunction:!ExternalObject removeSelector: #isNullPointer!Object subclass: #ExternalObject	instanceVariableNames: 'handle'	classVariableNames: 'Registry'	poolDictionaries: ''	category: 'FFI-Types'!ExternalFunctionError class removeSelector: #function:!ExternalFunctionError removeSelector: #function!ExternalFunctionError removeSelector: #function:!ExternalFunctionError removeSelector: #isResumable!Error subclass: #ExternalFunctionError	instanceVariableNames: 'functionName'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!Application class removeSelector: #start!Application class removeSelector: #startWithArguments:!Class removeSelector: #superclass:methodDict:format:name:organization:instVarNames:classPool:sharedPools:!ClassBuilder removeSelector: #computeFormat:instSize:forSuper:ccIndex:!ClassBuilder removeSelector: #format:variable:words:pointers:weak:!Smalltalk removeClassNamed: #SystemChangeNotifierTest!RBProgramNodeVisitor subclass: #ASTChecker	instanceVariableNames: 'scope varsChangedInSend'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!RBProgramNodeVisitor subclass: #ASTTranslator	instanceVariableNames: 'methodBuilder receiverForCascade'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #Application	instanceVariableNames: 'arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!AssembleInstruction subclass: #AssembleCMov	instanceVariableNames: ''	classVariableNames: 'Condition'	poolDictionaries: ''	category: 'Exupery'!Object subclass: #AssemblerExupery	instanceVariableNames: 'stream blockAddresses jumpOffsets bytecodes instructionEncoders plugin relocator picEntries debugCollector source'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #BlockClosure	instanceVariableNames: 'method environment'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Contexts'!PluggableGtkSimpleApplication subclass: #ClassFinder	instanceVariableNames: 'classTrait'	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!Object subclass: #ColouringRegisterAllocator	instanceVariableNames: 'source result machine interferenceGraph registerStack registerFile registerTable spiltRegisters hasSpilt coloursUsed simplifyWorklist spillWorklist moveWorklist coalescedMoves isValidating deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #DebugInfo	instanceVariableNames: 'codeSourceReferences argVarsReferences tempVarsReferences capturedVarsReferences'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!Object subclass: #EventManager	instanceVariableNames: 'actionMap'	classVariableNames: 'ActionMaps'	poolDictionaries: ''	category: 'System-Object'!Error subclass: #ExternalFunctionError	instanceVariableNames: 'functionName '	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!Object subclass: #ExternalObject	instanceVariableNames: 'handle '	classVariableNames: 'Registry '	poolDictionaries: ''	category: 'FFI-Types'!ExternalObject subclass: #DynamicLibrary	instanceVariableNames: 'name symbolCache'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!DynamicLibrary subclass: #Executable	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!ExternalObject subclass: #ExternalBuffer	instanceVariableNames: 'size'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalBuffer subclass: #AsciiZ	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!DynamicLibrary class	instanceVariableNames: 'default'!ExternalObject subclass: #ExternalObjectProxy	instanceVariableNames: 'object'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalObjectProxy subclass: #ExternalArrayProxy	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalObject subclass: #ExternalSymbol	instanceVariableNames: 'name library'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!ExternalSymbol subclass: #ExecutableFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!ExecutableFunction subclass: #CDeclFunction	instanceVariableNames: 'returnType argTypes'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Error subclass: #ExternalSymbolError	instanceVariableNames: 'symbolName'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!ExternalObject subclass: #FileDescriptor	instanceVariableNames: ''	classVariableNames: 'StandardDescriptors'	poolDictionaries: ''	category: 'FFI-Types'!Error subclass: #FileStreamException	instanceVariableNames: 'fileName'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #CannotDeleteFileException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #FileDoesNotExistException	instanceVariableNames: 'readOnly'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #FileExistsException	instanceVariableNames: 'fileClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!AssemblyCopier subclass: #FinalCopier	instanceVariableNames: 'deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!LexicalScope subclass: #FunctionScope	instanceVariableNames: 'thisContextVar thisEnvVar tempVars capturedVars isHome hasInnerFreeVars hideTemps argVars uninitializedTemps capturedParentEnv'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #GIRBuilder	instanceVariableNames: 'ir currentBlock machine relocationInfo primitiveNode literals thisEnvVar cacheMap literalTemp source start stop debugInfo'	classVariableNames: 'InlinedSelectors SpecialConstants SpecialSelectors'	poolDictionaries: ''	category: 'Compiler-IR'!LexicalScope subclass: #InstanceScope	instanceVariableNames: 'vars'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!DynamicLibrary subclass: #LibC6	instanceVariableNames: ''	classVariableNames: 'LSeekDirectives OpenFlags'	poolDictionaries: ''	category: 'FFI-Libraries'!Object subclass: #LibExample	instanceVariableNames: ''	classVariableNames: 'GETPID'	poolDictionaries: ''	category: 'Guille-Test'!DynamicLibrary subclass: #LibReadLine	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!ExternalSymbol subclass: #LibraryData	instanceVariableNames: 'type'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Object subclass: #LivenessAnalyser	instanceVariableNames: 'source hasUpdated isValidating deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #MedLanguage	instanceVariableNames: 'in out start stop'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedCMov	instanceVariableNames: 'type from to'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedEnter	instanceVariableNames: 'argument'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedLeave	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedLiteral	instanceVariableNames: 'literal'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLiteral subclass: #MedFunction	instanceVariableNames: 'block byteCodeAddress'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!ExecutableFunction subclass: #NativeFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Object subclass: #PrimitiveType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!PrimitiveType subclass: #IntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!RBProgramNode subclass: #RBReturnNode	instanceVariableNames: 'return value homeBinding frameBinding'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Nodes'!ExternalObject subclass: #ReadOnlyAsciiZ	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SemanticWarning subclass: #RedeclaredVariableWarning	instanceVariableNames: 'variableNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #RelocationInfo	instanceVariableNames: 'offset'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #ExecutableFunctionRelocation	instanceVariableNames: 'functionName'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #FunctionRelocation	instanceVariableNames: 'function'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #LiteralRelocation	instanceVariableNames: 'literals'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!ExecutableFunctionRelocation subclass: #NativeFunctionRelocation	instanceVariableNames: 'libraryName'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!NativeFunctionRelocation subclass: #ExternalFunctionRelocation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #PrimitiveRelocation	instanceVariableNames: 'number'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!Object subclass: #ScopeVar	instanceVariableNames: 'scope usage'	classVariableNames: 'UsageAutomaton'	poolDictionaries: ''	category: 'Compiler-Semantics'!ScopeVar subclass: #GlobalVar	instanceVariableNames: 'assoc'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!ScopeVar subclass: #LocalVar	instanceVariableNames: 'name index'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!LocalVar subclass: #ArgVar	instanceVariableNames: 'isArg'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!LocalVar subclass: #CapturedVar	instanceVariableNames: 'sourceTemp'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!ByteArray variableByteSubclass: #ExternalValue	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!Object subclass: #SharedPool	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Pools'!Application subclass: #Shell	instanceVariableNames: 'bindings '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!IntegerType subclass: #SignedIntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedByte	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedShortInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!Object subclass: #SourceReference	instanceVariableNames: 'sourceStart sourceStop codeStop'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!RelocationInfo subclass: #SpecialSelectorRelocation	instanceVariableNames: 'specialSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!Model subclass: #StringHolder	instanceVariableNames: 'contents'	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Kernel-Remnants'!Object subclass: #SystemTracer	instanceVariableNames: 'byteStream traceQueue oopMap nextChunk nilOop count'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Tracer'!LocalVar subclass: #TempVar	instanceVariableNames: 'isArg'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Error subclass: #TraitException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Kernel'!TraitException subclass: #TraitCompositionException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Composition'!Error subclass: #TypeConvertionError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!FileStream subclass: #UnbufferedFileStream	instanceVariableNames: 'name fileID'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!Smalltalk renameClassNamed: #BufferedFileStream2 as: #BufferedFileStream!UnbufferedFileStream subclass: #BufferedFileStream	instanceVariableNames: ''	classVariableNames: 'DefaultBufferSize'	poolDictionaries: ''	category: 'Files-Kernel'!BufferedFileStream subclass: #BinaryFileStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!BufferedFileStream subclass: #TextFileStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!IntegerType subclass: #UnsignedIntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedByte	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedShortInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SemanticWarning subclass: #UnusedVariableWarning	instanceVariableNames: 'variableNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #VarReference	instanceVariableNames: 'name'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!RelocationInfo subclass: #VariableRelocation	instanceVariableNames: 'variable'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!PluggableGtkSimpleApplication subclass: #Workspace	instanceVariableNames: 'workspaceView'	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!Workspace subclass: #TranscriptCodeEditor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!!Object methodsFor: 'as yet unclassified'!errorSubscriptBounds: index 	"Create an error notification that an improper integer was used as an index."	self error: 'subscript is out of bounds: ' , index printString! !!Object methodsFor: 'as yet unclassified'!executeMethod: compiledMethod withArgs: argArray	"Execute compiledMethod against the receiver and args in argArray"	| selector |	<primitive: 188>	selector _ Symbol new.	self class addSelectorSilently: selector withMethod: compiledMethod.	^ [self perform: selector withArguments: argArray]		ensure: [self class basicRemoveSelector: selector]! !!Object methodsFor: 'as yet unclassified'!withArgs: argArray executeMethod: compiledMethod	"For compatibility with Aqueak"	self executeMethod: compiledMethod withArgs: argArray! !!Application methodsFor: 'as yet unclassified'!arguments	^ arguments.! !!Application methodsFor: 'as yet unclassified'!arguments: anArray	arguments := anArray.! !!Application methodsFor: 'as yet unclassified'!main	self subclassResponsibility.! !!Application methodsFor: 'as yet unclassified'!startUp	Smalltalk startUp.	^ self main.! !!Behavior methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return true if it is safe to zap the method dictionary on #obsolete"	^true! !!Behavior methodsFor: 'as yet unclassified'!isWeak	^ (format bitAnd: 4) = 1.! !!Behavior methodsFor: 'as yet unclassified'!obsolete	"Invalidate and recycle local methods,	e.g., zap the method dictionary if can be done safely."	self canZapMethodDictionary		ifTrue: [self methodDict: self emptyMethodDictionary].! !!Behavior methodsFor: 'as yet unclassified'!removeSelector: selector	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method."	| oldMethod |		oldMethod _ self methodDict at: selector ifAbsent: [^ self].	self methodDict removeKey: selector.	"Now flush Squeak's method cache, either by selector or by method"	oldMethod flushCache.	selector flushCache! !!Behavior methodsFor: 'as yet unclassified'!selectorsAndMethodsDo: aBlock	"Evaluate selectorBlock for all the message selectors in my method dictionary."	^ self methodDict keysAndValuesDo: aBlock! !!Behavior methodsFor: 'as yet unclassified'!setTraitComposition: aTraitComposition	| oldComposition |	(self hasTraitComposition not and: [aTraitComposition isEmpty]) ifTrue: [^self].	aTraitComposition assertValidUser: self.	oldComposition _ self traitComposition.	self traitComposition: aTraitComposition."	self applyChangesOfNewTraitCompositionReplacing: oldComposition."		oldComposition traits do: [:each | each removeUser: self].	aTraitComposition traits do: [:each | each addUser: self]! !!Behavior methodsFor: 'as yet unclassified'!traitCompositionString	^self hasTraitComposition		ifTrue: [self traitComposition asString]		ifFalse: ['{}']! !!Behavior methodsFor: 'as yet unclassified'!typeOfClass	"Answer a symbol uniquely describing the type of the receiver"	self isWeak ifTrue: [ ^ #weak ].	^ (format bitAnd: 3) caseOf: {		[ 0 ] -> [ #normal ].		[ 1 ] -> [ #variable ].		[ 2 ] -> [ #bytes ].		[ 3 ] -> [ #words ]	}! !!Behavior methodsFor: 'as yet unclassified'!whichSelectorsReferTo: literal	"Answer a set of selectors whose methods access the argument as a literal."	| who |	who _ IdentitySet new.	self selectorsAndMethodsDo: 		[:sel :method |		(method hasLiteral: literal)			ifTrue:				[((literal isVariableBinding) not					or: [method literals allButLast includes: literal])						ifTrue: [who add: sel]]].	^ who! !!BehaviorTest methodsFor: 'as yet unclassified'!testBehaviorSubclasses	"self run: #testBehaviorSubclasses"		| b b2 |"	b := Behavior new.	b superclass: OrderedCollection.	b methodDictionary: Dictionary new.	self shouldnt: [b subclasses ] raise: Error.	self shouldnt: [b withAllSubclasses] raise: Error.	self shouldnt: [b allSubclasses] raise: Error.	b2 := Behavior new.	b2 superclass: b.	b2 methodDictionary: Dictionary new.	self assert: (b subclasses includes: b2).	self assert: (b withAllSubclasses includes: b)."! !!BlockClosure methodsFor: 'as yet unclassified'!valueWithArguments: anArray 	"Evaluate the block with given args. Fail if the block expects other than the given number of arguments."	^ environment executeMethod: method withArgs: anArray ! !!ClassBrowser methodsFor: 'as yet unclassified'!buildClassCategoriesView	| model tree col cell |	tree := nil->nil.	SystemOrganization categories do: [ :each |		| category |		category := tree.		(each subStrings: '-') do: [ :cat |			category value ifNil: [ category value: Dictionary new].			category := category value associationAt: cat ifAbsent: [ category value at: cat put: nil. category value associationAt: cat ]		]	].	model := GtkTreeStore new: {String. String}.	[ self addSubcategoriesFrom: tree fromIter: nil inModel: model ] fork.	classCategoriesTree := GtkTreeView model: model.	col := GtkTreeViewColumn title: 'Class categories'.	cell := GtkCellRendererPixbuf new.	col		packStart: cell expand: false;		addAttribute: #stockId column: 1 on: cell.	cell := GtkCellRendererText new.	col		packStart: cell;		addAttribute: #text column: 0 on: cell.		classCategoriesTree appendColumn: col.	classCategoriesTree selection when: #changed send: #onClassCategoryChanged to: self.	classCategoriesTree enableTreeLines: true.	^ GtkScrolledWindow withChild: classCategoriesTree! !!ClassBrowser methodsFor: 'as yet unclassified'!loadClassMethodsOf: aClassClass	| iter |	classMethodsTree model clear.	aClassClass organization categories do: [ :cat |		iter := classMethodsTree model append: nil->{cat asString. true. 'grey'. 'gtk-info'}.		(aClassClass organization listAtCategoryNamed: cat) asSortedCollection do: [ :sel |			classMethodsTree model append: iter->{sel asString. false. 'grey'. 'gtk-execute'}		]	].	classMethodsTree expandAll.! !!ClassBrowser methodsFor: 'as yet unclassified'!loadInstanceMethodsOf: aClass	| iter |	instanceMethodsTree model clear.	aClass organization categories do: [ :cat |		iter := instanceMethodsTree model append: nil->{cat asString. true. 'grey'. 'gtk-info'}.		(aClass organization listAtCategoryNamed: cat) asSortedCollection do: [ :sel |			instanceMethodsTree model append: iter->{sel asString. false. 'grey'. 'gtk-execute'}		]	].	instanceMethodsTree expandAll.! !!ClassBrowser methodsFor: 'as yet unclassified'!onClassHierarchyChanged	| class iter path newIter aCategory classHierarchySelectedRow classesTreeSelectedRow |	classHierarchySelectedRow := classHierarchyTree selectedRow.	classHierarchySelectedRow ifNotNil: [		class := Smalltalk at: (classHierarchySelectedRow first asSymbol).							aCategory := class category.		( aCategory isNotNil and: [ aCategory ~= selectedClassCategory ] ) ifTrue: [			selectedClassCategory := aCategory.			iter := classCategoriesTree model firstIter.			newIter := nil.			(aCategory subStrings: '-') do: [ :cat |				newIter ifNotNil: [ iter := newIter ].				iter := self classCategoryFor: cat firstIter: iter.				newIter := classCategoriesTree model firstChildAt: iter.			].			path := classCategoriesTree model pathFromIter: iter.			classCategoriesTree expandRowsUpTo: path.			classCategoriesTree moveCursorAt: path.					classesTree model clear.			(SystemOrganization listAtCategoryNamed: aCategory) sort do: [ :ea |				classesTree model append: {ea asString. 'gtk-execute'}			]		].							self selectClass: class.	]! !!ClassBuilder methodsFor: 'as yet unclassified'!formatForType: type	^ type caseOf: {		[ #normal ] -> [ 0 ].		[ #variable ] -> [ 1 ].		[ #bytes ] -> [ 2 ].		[ #words ] -> [ 3 ].		[ #weak ] -> [ 5 "binary: 4 + 0 + 0 + 1" ]	} otherwise: [ self error: 'Unknown class type' ].! !!ClassBuilder methodsFor: 'as yet unclassified'!needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Answer whether we need a new subclass to conform to the requested changes"	"Check if we really need a new subclass"	oldClass ifNil:[^true]. "yes, it's a new class"	newSuper == oldClass superclass ifFalse:[^true]. "yes, it's a superclass change"	type = oldClass typeOfClass ifFalse:[^true]. "yes, it's a format change"	instVars = oldClass instVarNames ifFalse:[^true]. "yes, it's an iVar change"	^false! !!ClassBuilder methodsFor: 'as yet unclassified'!newSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Create a new subclass of the given superclass with the given specification."	| newClass |	(oldClass == nil or:[oldClass isMeta not]) 		ifTrue:[newClass := self privateNewSubclassOf: newSuper from: oldClass]		ifFalse:[newClass := oldClass clone].	newClass 		superclass: newSuper		methodDictionary: "Method"Dictionary new		instanceSize: (newSuper instSize + instVars size)		format: (self formatForType: type);		setInstVarNames: instVars.	oldClass ifNotNil:[		newClass organization: oldClass organization.		"Recompile the new class"		oldClass hasMethods 			ifTrue:[newClass compileAllFrom: oldClass].		oldClass hasTraitComposition ifTrue: [			newClass setTraitComposition: oldClass traitComposition copyTraitExpression ].		oldClass class hasTraitComposition ifTrue: [			newClass class setTraitComposition: oldClass class traitComposition copyTraitExpression ].				self recordClass: oldClass replacedBy: newClass.	].	(oldClass == nil or:[oldClass isObsolete not]) 		ifTrue:[newSuper addSubclass: newClass]		ifFalse:[newSuper addObsoleteSubclass: newClass].	^newClass! !!ClassBuilder methodsFor: 'as yet unclassified'!privateNewSubclassOf: newSuper from: oldClass	"Create a new meta and non-meta subclass of newSuper using oldClass as template"	"WARNING: This method does not preserve the superclass/subclass invariant!!"	| newSuperMeta oldMeta newMeta |	oldClass ifNil:[^self privateNewSubclassOf: newSuper].	newSuperMeta _ newSuper ifNil:[Class] ifNotNil:[newSuper class].	oldMeta _ oldClass class.	newMeta _ oldMeta clone.	newMeta 		superclass: newSuperMeta		methodDictionary: "Method"Dictionary new		instanceSize: oldMeta instSize		format: oldMeta format;		setInstVarNames: oldMeta instVarNames;		organization: oldMeta organization.	"Recompile the meta class"	oldMeta hasMethods 		ifTrue:[newMeta compileAllFrom: oldMeta].	"Record the meta class change"	self recordClass: oldMeta replacedBy: newMeta.	"And create a new instance"	^newMeta adoptInstance: oldClass from: oldMeta! !!ClassBuilder methodsFor: 'as yet unclassified'!reshapeClass: oldClass toSuper: newSuper	"Reshape the given class to the new super class. Recompile all the methods in the newly created class. Answer the new class."	| instVars |	instVars _ instVarMap at: oldClass name ifAbsent:[oldClass instVarNames].	^self newSubclassOf: newSuper 			type: oldClass typeOfClass 			instanceVariables: instVars 			from: oldClass! !!ClassDescription methodsFor: 'as yet unclassified'!classVersion	"Default.  Any class may return a later version to inform readers that use ReferenceStream.  8/17/96 tk"	"This method allows you to distinguish between class versions when the shape of the class 	hasn't changed (when there's no change in the instVar names).	In the conversion methods you usually can tell by the inst var names 	what old version you have. In a few cases, though, the same inst var 	names were kept but their interpretation changed (like in the layoutFrame).	By changing the class version when you keep the same instVars you can 	warn older and newer images that they have to convert."	^ 0! !!ClassDescription methodsFor: 'as yet unclassified'!obsolete	"Make the receiver obsolete."	superclass removeSubclass: self.	self organization: nil.	super obsolete.! !!ClassDescription methodsFor: 'as yet unclassified'!removeSelector: selector 	"Remove the message whose selector is given from the method 	dictionary of the receiver, if it is there. Answer nil otherwise."		| priorMethod priorProtocol | 	priorMethod _ self compiledMethodAt: selector ifAbsent: [^ nil].	priorProtocol _ self whichCategoryIncludesSelector: selector.	SystemChangeNotifier uniqueInstance		doSilently: [self organization removeElement: selector ].	super removeSelector: selector.	SystemChangeNotifier uniqueInstance 			methodRemoved: priorMethod selector: selector inProtocol: priorProtocol class: self.! !!ClassDescription methodsFor: 'as yet unclassified'!updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil	| currentCategory effectiveCategory sel changedCategories composition |	changedCategories _ IdentitySet new.	composition := self hasTraitComposition		ifTrue: [self traitComposition]		ifFalse: [TraitComposition new].	(composition methodDescriptionsForSelector: aSymbol) do: [:each |		sel _ each selector.		(self includesLocalSelector: sel) ifFalse: [			currentCategory _ self organization categoryOfElement: sel.			effectiveCategory _ each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.			effectiveCategory isNil ifTrue: [				currentCategory ifNotNil: [changedCategories add: currentCategory].				self organization removeElement: sel.			] ifFalse: [				((currentCategory isNil or: [currentCategory == ClassOrganizer ambiguous or: [currentCategory == oldCategoryOrNil]]) and: [currentCategory ~~ effectiveCategory]) ifTrue: [					currentCategory ifNotNil: [changedCategories add: currentCategory].					self organization 						classify: sel 						under: effectiveCategory						suppressIfDefault: false]]]].	^ changedCategories! !!ClassDescription methodsFor: 'as yet unclassified'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	(self includesSelector: aSelector)		ifTrue: [^ self organization categoryOfElement: aSelector]		ifFalse: [^nil]! !!Class methodsFor: 'as yet unclassified'!classPool: aDictionary	classPool _ aDictionary! !!Class methodsFor: 'as yet unclassified'!copy 	| newClass |	newClass _ self class copy new		superclass: superclass		methodDict: self methodDict copy		instanceSize: self instSize		format: format		name: name		organization: self organization copy		instVarNames: instanceVariables copy		classPool: classPool copy		sharedPools: sharedPools.	Class instSize+1 to: self class instSize do:		[:offset | newClass instVarAt: offset put: (self instVarAt: offset)].	^ newClass! !!Class methodsFor: 'as yet unclassified'!deactivate	"A remnant from the 3.3a modules work, retained . Does nothing, but may be overridden in Metaclasses."! !!Class methodsFor: 'as yet unclassified'!isSystemDefined	"Answer true if the receiver is a system-defined class, and not a UniClass (an instance-specific lightweight class)"	^ self == self officialClass! !!Class methodsFor: 'as yet unclassified'!obsolete	"Change the receiver and all of its subclasses to an obsolete class."	self == Object 		ifTrue: [^self error: 'Object is NOT obsolete'].	self setName: 'AnObsolete' , self name.	Object class instSize + 1 to: self class instSize do:		[:i | self instVarAt: i put: nil]. "Store nil over class instVars."	self classPool: nil.	self sharedPools: nil.	self class obsolete.	super obsolete.! !!Class methodsFor: 'as yet unclassified'!officialClass	"I am not a UniClass.  (See Player officialClass).  Return the class you use to make new subclasses."	^ self! !!Class methodsFor: 'as yet unclassified'!removeFromSystem	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."	self removeFromSystem: true.! !!Class methodsFor: 'as yet unclassified'!removeFromSystem: logged	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."		"keep the class name and category for triggering the system change message. If we wait to long, then we get obsolete information which is not what we want."	"tell class to deactivate and unload itself-- two separate events in the module system"	self deactivate; unload.	self superclass ifNotNil:		["If we have no superclass there's nothing to be remembered"		self superclass addObsoleteSubclass: self].	self environment forgetClass: self logged: logged.	self obsolete.! !!Class methodsFor: 'as yet unclassified'!sharedPools: aCollection	sharedPools _ aCollection! !!Class methodsFor: 'as yet unclassified'!superclass: sup methodDict: md instanceSize: is format: ft name: nm organization: org instVarNames: nilOrArray classPool: pool sharedPools: poolSet 	"Answer an instance of me, a new class, using the arguments of the 	message as the needed information.	Must only be sent to a new instance; else we would need Object flushCache."	superclass := sup.	methodDict := md.	instanceSize := is.	format := ft.	name := nm.	instanceVariables := nilOrArray.	classPool := pool.	sharedPools := poolSet.	self organization: org.! !!Class methodsFor: 'as yet unclassified'!unload	"Sent when a the class is removed.  Does nothing, but may be overridden by (class-side) subclasses."! !!Class methodsFor: 'as yet unclassified'!variableByteSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable byte-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableByteSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!variableSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable pointer variables."	^(ClassBuilder new)		superclass: self		variableSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!variableWordSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable word-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableWordSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!weakSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have weak indexable pointer variables."	^(ClassBuilder new)		superclass: self		weakSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!AppLauncher class methodsFor: 'as yet unclassified'!openAboutHuemul	| dlg logo |	logo := GdkPixbuf fromFile: 'Huemul.jpg'.	dlg := GtkAboutDialog new.	dlg		aboutDialogName: 'Huemul Smalltalk';		version: '0.8';		license: (StandardFileStream readOnlyFileNamed: 'LICENSE') upToEnd;		website: 'http://www.guillermomolina.com.ar/huemul';		comments: 'This is Huemul Smalltalk';		authors: {'Guillermo Adrian Molina'};		logo: logo.	dlg runAndDestroy! !!AppLauncher class methodsFor: 'as yet unclassified'!openWorkspace	^ Workspace open! !!Application class methodsFor: 'as yet unclassified'!startUp	^ self new startUp.! !!Application class methodsFor: 'as yet unclassified'!startUpWithArguments: arguments	| application |	application := self new.	application arguments: arguments.	^ application startUp.! !!Behavior class methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return false since zapping the method dictionary of Behavior class or its subclasses will cause the system to fail."	^false! !!ClassBrowser class methodsFor: 'as yet unclassified'!defaultSize	^ 640@480.! !!ClassBrowser class methodsFor: 'as yet unclassified'!title	^'Class browser'! !!ClassFinder class methodsFor: 'as yet unclassified'!defaultSize	^ 200@300.! !!ClassFinder class methodsFor: 'as yet unclassified'!title	^'Class finder'! !!CompiledMethod methodsFor: 'as yet unclassified'!hasLiteral: literal	"Answer whether the receiver references the argument, literal."	literals ifNil: [ ^false ].	^ literals hasLiteral: literal.! !!CompiledMethod methodsFor: 'as yet unclassified'!sourcePointer	"Answer the integer which can be used to find the source file and position for this method.	Not sources yet"	^ 0! !!CompiledMethodWithNode class methodsFor: 'as yet unclassified'!method: aCompiledMethod node: aMethodNode	^ self new method: aCompiledMethod; node: aMethodNode.! !!Compiler methodsFor: 'as yet unclassified'!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into a method. In other words, if receiver is not nil, then the text can refer to instance variables of that receiver (the Inspector uses this). If aContext is not nil, the text can refer to temporaries in that context (the Debugger uses this). If aRequestor is not nil, then it will receive a notify:at: message before the attempt to evaluate is aborted. Finally, the compiled method is directly invoked without modifying the receiving-class."	"| methodNode method value |	  	(Preferences compileUseNewCompiler or: 			[aContext ifNotNil: [aContext method isClosureCompiled] ifNil: [false]]) ifTrue: 				[^ self evaluate2: textOrStream 					    in: aContext 					    to: receiver 					    notifying: aRequestor 					    ifFail: failBlock 					    logged: logFlag].		class := (aContext isNil 		ifTrue: [ receiver ] 		ifFalse: [ aContext receiver ])			class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode := self 		translate: sourceStream		noPattern: true 		ifFail: [ ^ failBlock value ].	method := methodNode generate.	self interactive		ifTrue: [ method := method copyWithTempNames: methodNode tempNames ].	value := receiver		executeMethod: method 		withArgs: (context isNil			ifTrue: [ #() ]			ifFalse: [ Array with: aContext ]).	logFlag 		ifTrue: [ SystemChangeNotifier uniqueInstance evaluated: sourceStream contents context: aContext ].	^ value."	| string block |	string _ textOrStream readStream upToEnd.	block := self compileDoIt: string in: aContext to: receiver notifying: aRequestor ifFail: [^ failBlock value] log: logFlag.	^ block value! !!Exception methodsFor: 'as yet unclassified'!messageText	messageText ifNil: [ ^ self class name asString ].	^messageText! !!Exception methodsFor: 'as yet unclassified'!receiver	^ self signalerContext receiver! !!ExternalFunctionError methodsFor: 'as yet unclassified'!functionName	"Answer the function name that was beiing used."	^functionName! !!ExternalFunctionError methodsFor: 'as yet unclassified'!functionName: argument	"Specify the function name that was beiing used."	functionName := argument! !!ExternalFunctionError class methodsFor: 'as yet unclassified'!functionName: argument	^self new functionName: argument; yourself! !!ExternalObject methodsFor: 'as yet unclassified'!= anObject 	(anObject isKindOf: self class)		ifTrue: [^ anObject handle = self handle]		ifFalse: [^ false]! !!ExternalObject methodsFor: 'as yet unclassified'!beNull	^ handle beNull.! !!ExternalObject methodsFor: 'as yet unclassified'!finalize		self free.	self unregister.! !!ExternalObject methodsFor: 'as yet unclassified'!free	"Should override this"! !!ExternalObject methodsFor: 'as yet unclassified'!initialize	handle := self class defaultHandlerClass new.	self register.! !!ExternalObject methodsFor: 'as yet unclassified'!isNull	^ self handle isNull.! !!ExternalObject methodsFor: 'as yet unclassified'!register	Registry add: self.! !!ExternalObject methodsFor: 'as yet unclassified'!unregister		Registry remove: self ifAbsent:[  ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!addSymbol: anExternalSymbol	^ symbolCache at: anExternalSymbol name put: anExternalSymbol.! !!DynamicLibrary methodsFor: 'as yet unclassified'!bindSymbol: anExternalSymbol	^ self primitiveBindSymbol: anExternalSymbol.! !!DynamicLibrary methodsFor: 'as yet unclassified'!cDeclFunctionNamed: functionName	^ symbolCache at: functionName ifAbsent: [ self error: 'You must initialize the function before using it' ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!close		handle isNull ifFalse: [ 		self primitiveClose		handle beNull.	].! !!DynamicLibrary methodsFor: 'as yet unclassified'!initialize	super initialize.	symbolCache := Dictionary new.! !!DynamicLibrary methodsFor: 'as yet unclassified'!initializeCDeclFunctionNamed: functionName returnType: retType argTypes: argTypesArray	^ symbolCache at: functionName put: 			(CDeclFunction name: functionName library: self  returnType: retType argTypes: argTypesArray)! !!DynamicLibrary methodsFor: 'as yet unclassified'!initializeLibraryDataNamed: symbolName type: type	^ symbolCache at: symbolName put: (LibraryData name: symbolName library: self  type: type)! !!DynamicLibrary methodsFor: 'as yet unclassified'!libraryDataNamed: symbolName	^ symbolCache at: symbolName ifAbsent: [ self error: 'You must initialize the symbol before using it' ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!name	^name! !!DynamicLibrary methodsFor: 'as yet unclassified'!name: aName	name := aName.! !!DynamicLibrary methodsFor: 'as yet unclassified'!nativeFunctionNamed: functionName	^ symbolCache at: functionName ifAbsent: [ 		symbolCache at: functionName put: (NativeFunction name: functionName library: self)	].! !!DynamicLibrary methodsFor: 'as yet unclassified'!open		handle isNull ifTrue: [ self primitiveOpen ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveBindSymbol: anExternalSymbol	"Primitive. Find the given symbol in the library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 203>	^ anExternalSymbol throwNotKnownError.! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveClose	"Primitive. Close the given library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 202>! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveOpen	"Primitive. Open the given library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 198>	self primitiveFailed.! !!DynamicLibrary methodsFor: 'as yet unclassified'!printOn: aStream	aStream nextPutAll: self name.! !!DynamicLibrary methodsFor: 'as yet unclassified'!symbolNamed: symbolName	^ symbolCache at: symbolName ifAbsent: [ self error: 'You must initialize the symbol before using it' ]! !!Executable methodsFor: 'as yet unclassified'!name	^ Utilities executableName ! !!Executable methodsFor: 'as yet unclassified'!primitiveSmallIntegerAdd: receiver with: argument	^ (self nativeFunctionNamed: #primitiveSmallIntegerAdd) invokeReceiver: receiver with: argument.! !!ExternalBuffer methodsFor: 'as yet unclassified'!asByteArray	| array |	size ifNil: [ ^ self class throwTypeConvertionError ].	array := ByteArray new: self basicSize.	self storeInto: array.	^ array	! !!ExternalBuffer methodsFor: 'as yet unclassified'!atAllPut: constant	^ LibC6 default memSet: self constant: constant count: self size.! !!ExternalBuffer methodsFor: 'as yet unclassified'!atAllPutZero	^ self atAllPut: 0.! !!ExternalBuffer methodsFor: 'as yet unclassified'!basicSize	^ size.! !!ExternalBuffer methodsFor: 'as yet unclassified'!byteAt: index	<primitive: 190>	index isNumber		ifTrue: [self errorSubscriptBounds: index]		ifFalse: [self errorNonIntegerIndex].! !!ExternalBuffer methodsFor: 'as yet unclassified'!byteAt: index put: value	<primitive: 191>	index isNumber		ifTrue: [self errorSubscriptBounds: index]		ifFalse: [self errorNonIntegerIndex].! !!ExternalBuffer methodsFor: 'as yet unclassified'!free		handle isNull ifFalse: [ 		LibC6 default free: self.		self beNull.	]! !!ExternalBuffer methodsFor: 'as yet unclassified'!loadFrom: aByteArray	<primitive: 199>	self primitiveFailed.! !!ExternalBuffer methodsFor: 'as yet unclassified'!size	^ self basicSize.! !!ExternalBuffer methodsFor: 'as yet unclassified'!size: anInteger	size := anInteger.! !!ExternalBuffer methodsFor: 'as yet unclassified'!storeInto: aByteArray	<primitive: 218>	^ self class throwTypeConvertionError.! !!AsciiZ methodsFor: 'as yet unclassified'!asString	^ handle toString.! !!AsciiZ methodsFor: 'as yet unclassified'!asString2	| calcSize string |	size ifNil: [ ^ self class throwTypeConvertionError ].	calcSize := self strlen.	calcSize >= self size ifTrue: [ ^ self class throwTypeConvertionError ].	string := String new: calcSize.	self storeInto: string.	^ string! !!AsciiZ methodsFor: 'as yet unclassified'!loadFrom: aString		super loadFrom: aString.	self byteAt: (aString size + 1) put: 0.! !!AsciiZ methodsFor: 'as yet unclassified'!strlen	^ LibC6 default strLen: self.! !!ExternalFunction methodsFor: 'as yet unclassified'!library	^ library! !!ExternalFunction methodsFor: 'as yet unclassified'!library: aLibrary	library := aLibrary! !!ExternalFunction methodsFor: 'as yet unclassified'!name	^name! !!ExternalFunction methodsFor: 'as yet unclassified'!name: aName	name := aName! !!ExternalFunction methodsFor: 'as yet unclassified'!name: aName library: aLibrary	self name: aName.	self library: aLibrary! !!ExternalFunction methodsFor: 'as yet unclassified'!reload	library ifNil: [ ^ self throwNotKnownError ].	self handle: (library findFunction: self)! !!ExternalLibrary methodsFor: 'as yet unclassified'!bindFunction: function	| answer |	answer := self primitiveBindFunction: function.	answer ifNotNil: [ ^ answer ].	self open. "Library may be closed, open it and retry"	answer := self primitiveBindFunction: answer.	answer ifNotNil: [ ^ answer ].	^ function throwNotKnownError.		! !!ExternalLibrary methodsFor: 'as yet unclassified'!closeLibrary		(handle isNotNil and: [ handle isNull not ]) ifTrue: [ self primitiveClose ].	self handle: nil.	functionCache := nil.! !!ExternalLibrary methodsFor: 'as yet unclassified'!openLibrary		self primitiveOpen.	self initializeFunctionCache.! !!ExternalLibrary methodsFor: 'as yet unclassified'!primitiveBindFunction: function	"Primitive. Find the given symbol in the library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 203>	^ nil.! !!ExternalObject class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: self! !!ExternalObject class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalAddress! !!ExternalObject class methodsFor: 'as yet unclassified'!handleFromObject: anObject	^ self handleFromObject: anObject ifError: [ self throwTypeConvertionError ]! !!ExternalObject class methodsFor: 'as yet unclassified'!handleFromObject: anObject ifError: aBlock		(anObject isKindOf: ExternalObject) ifFalse: [ ^ aBlock value ].	^ anObject handle.	! !!ExternalObject class methodsFor: 'as yet unclassified'!initialize	Registry := WeakRegistry new.	Smalltalk addToShutDownList: self.! !!ExternalObject class methodsFor: 'as yet unclassified'!objectFromHandle: handle	^self objectFromHandle: handle ifError: [ self throwTypeConvertionError ]! !!ExternalObject class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; yourself! !!ExternalObject class methodsFor: 'as yet unclassified'!quit	Registry do: [ :each | each free ].	self allSubclassesDo: [ :ea | ea quit ]! !!ExternalObject class methodsFor: 'as yet unclassified'!shutDown: quitting	quitting ifTrue: [ self quit ].! !!ExternalObject class methodsFor: 'as yet unclassified'!throwTypeConvertionError	^ TypeConvertionError new signal! !!DynamicLibrary class methodsFor: 'as yet unclassified'!default	self = DynamicLibrary ifTrue: [ self error: 'Create a class to create its singleton' ].	default ifNil: [	"Represents the executable itself"		default := self new.		default name: self moduleName.		default open.	].	^ default.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!initialize	self = DynamicLibrary ifFalse: [ 		Smalltalk addToShutDownList: self	].! !!DynamicLibrary class methodsFor: 'as yet unclassified'!moduleName	self subClassResponsibility.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!resetLibrary	default := nil.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!shutDown: aBool	default ifNotNil: [ default close ].! !!Executable class methodsFor: 'as yet unclassified'!huemul	^ self default! !!Executable class methodsFor: 'as yet unclassified'!moduleName	^nil.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: ByteArray! !!ExternalBuffer class methodsFor: 'as yet unclassified'!fromByteArray: aByteArray	| anExternalBuffer |		anExternalBuffer := ExternalBuffer new: aByteArray size.	anExternalBuffer setFrom: aByteArray.	^ anExternalBuffer.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!handleFromObject: aByteArray ifError: aBlock		(aByteArray isKindOf: ByteArray) ifFalse: [ 		^ super handleFromObject: aByteArray ifError: aBlock	].	^ ( self fromByteArray: aByteArray ) handle.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!new: size	| anExternalBuffer |	"This space is allocated from the system not 	from Object Memory, you will have to give it back, 	as it is not garbage collected"	anExternalBuffer := LibC6 default malloc: (size +  10).	anExternalBuffer size: size.	^ anExternalBuffer! !!AsciiZ class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: String! !!AsciiZ class methodsFor: 'as yet unclassified'!fromString: aString	| anAsciiZ |		anAsciiZ := AsciiZ new: aString size + 1.	anAsciiZ loadFrom: aString.	^ anAsciiZ.! !!AsciiZ class methodsFor: 'as yet unclassified'!handleFromObject: aString ifError: aBlock		(aString isKindOf: String) ifFalse: [ 		^ super handleFromObject: aString ifError: aBlock	].	^ ( self fromString: aString ) handle.! !!AsciiZ class methodsFor: 'as yet unclassified'!new: size	| buffer asciiZ |	buffer := super new: size.	asciiZ := AsciiZ new handle: buffer handle.	asciiZ size: size.	asciiZ atAllPutZero.	buffer handle: ExternalAddress nullPointer.	^ asciiZ! !!AsciiZ class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; asString! !!ExternalFunction class methodsFor: 'as yet unclassified'!name: aName library: aLibrary	^self new name: aName library: aLibrary! !!ExternalLibrary class methodsFor: 'as yet unclassified'!huemul	Huemul ifNil: [	"Represents the executable itself"		Huemul := self new.		Huemul open.	].	^ Huemul.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!handle	self object ifNil: [ handle beNull ].	^ handle.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!initialize	super initialize.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!initializePointer	self handle forObject: self object.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!object	^ self objectPointer at: 1! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!object: anObject	self objectPointer at: 1 put: anObject.	self initializePointer.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!objectPointer	object ifNil: [ object := WeakArray new: 1 ].	^ object! !!ExternalArrayProxy methodsFor: 'as yet unclassified'!initializePointer	self handle forArray: self object.! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!fromObject: anObject		^ self new object: anObject; yourself! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!handleFromObject: anObject ifError: aBlock		^ ( self fromObject: anObject ) handle.! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		^ aBlock value! !!ExternalSymbol methodsFor: 'as yet unclassified'!address	handle isNull ifTrue: [ self bind ].	^ handle.! !!ExternalSymbol methodsFor: 'as yet unclassified'!bind	^ library bindSymbol: self.! !!ExternalSymbol methodsFor: 'as yet unclassified'!classFromType: aType	^ Smalltalk at: aType ifAbsent: [ self throwExternalSymbolError ].! !!ExternalSymbol methodsFor: 'as yet unclassified'!library	^ library! !!ExternalSymbol methodsFor: 'as yet unclassified'!library: aLibrary	library := aLibrary! !!ExternalSymbol methodsFor: 'as yet unclassified'!libraryName	^ library name.! !!ExternalSymbol methodsFor: 'as yet unclassified'!name	^name! !!ExternalSymbol methodsFor: 'as yet unclassified'!name: aName	name := aName! !!ExternalSymbol methodsFor: 'as yet unclassified'!name: aName library: aLibrary	self name: aName.	self library: aLibrary! !!ExternalSymbol methodsFor: 'as yet unclassified'!throwExternalSymbolError	^(ExternalSymbolError symbolName: name) signal.! !!ExternalSymbol methodsFor: 'as yet unclassified'!throwNotKnownError	^(ExternalSymbolError symbolName: name) signal.! !!ExecutableFunction methodsFor: 'as yet unclassified'!callingConventionString	self subclassResponsibility.! !!CDeclFunction methodsFor: 'as yet unclassified'!argTypes: anArrayOfTypes	argTypes := anArrayOfTypes.! !!CDeclFunction methodsFor: 'as yet unclassified'!callingConventionString	^ 'cdecl'! !!CDeclFunction methodsFor: 'as yet unclassified'!invoke	^self invokeWithArguments: #()! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1	^self invokeWithArguments: (Array with: arg1)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2	^self invokeWithArguments: (Array with: arg1 with: arg2)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4 with: arg5	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWithArguments: argArray	| argSize argHandleArray returnClass returnHandle |	argSize := argArray size.	argSize = argTypes size ifFalse: [ self throwExternalFunctionError ].	argHandleArray := Array new: argSize.	1 to: argSize do: [ :i |		| argType argClass argHandle arg |		argType := argTypes at: i.		argClass := self classFromType: argType.		arg := argArray at: i.		argHandle := argClass handleFromObject: arg.		argHandleArray at: i put: argHandle.	].	returnHandle := nil.	returnType = #Void ifFalse: [		returnClass := self classFromType: returnType.		returnHandle := returnClass defaultHandlerClass new.	].	handle isNull ifTrue: [ self bind ].	self primInvokeAnswering: returnHandle withArguments: argHandleArray.	returnType = #Void ifTrue: [ ^ nil ].	^ returnClass objectFromHandle: returnHandle.! !!CDeclFunction methodsFor: 'as yet unclassified'!primInvokeAnswering: aReturnValue withArguments: argArray	"Manually invoke the receiver, representing an external function."	<primitive: 204>	^self primitiveFailed! !!CDeclFunction methodsFor: 'as yet unclassified'!returnType: aType	returnType := aType.! !!CDeclFunction methodsFor: 'as yet unclassified'!returnType: aType argTypes: anArrayOfTypes	self returnType: aType.	self argTypes: anArrayOfTypes.! !!ExternalSymbol class methodsFor: 'as yet unclassified'!name: aName library: aLibrary	^self new name: aName library: aLibrary; bind! !!CDeclFunction class methodsFor: 'as yet unclassified'!name: aName library: aLibrary returnType: retType argTypes: argTypesArray	^self new name: aName library: aLibrary;		 returnType: retType argTypes: argTypesArray;		bind! !!ExternalSymbolError methodsFor: 'as yet unclassified'!isResumable	"Determine whether an exception is resumable."	^true! !!ExternalSymbolError methodsFor: 'as yet unclassified'!symbolName	^ symbolName! !!ExternalSymbolError methodsFor: 'as yet unclassified'!symbolName: argument	"Specify the function name that was beiing used."	symbolName := argument! !!ExternalSymbolError class methodsFor: 'as yet unclassified'!symbolName: argument	^self new symbolName: argument; yourself! !!FileDescriptor methodsFor: 'as yet unclassified'!close		self fileDescriptor > 2 ifTrue: [ 		LibC6 default close: self.		self fileDescriptor: -1.	]! !!FileDescriptor methodsFor: 'as yet unclassified'!fileDescriptor	^ SignedInteger objectFromHandle: handle. ! !!FileDescriptor methodsFor: 'as yet unclassified'!fileDescriptor: anInteger	handle := SignedInteger handleFromObject: anInteger. ! !!FileDescriptor methodsFor: 'as yet unclassified'!free		self close.! !!FileDescriptor methodsFor: 'as yet unclassified'!movePosition: offset"relative to actual position"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_CUR' ).	! !!FileDescriptor methodsFor: 'as yet unclassified'!position	^ self movePosition: 0.	! !!FileDescriptor methodsFor: 'as yet unclassified'!position: offset"absolute position"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_SET' ).! !!FileDescriptor methodsFor: 'as yet unclassified'!positionFromEnd: offset"relative to end of file"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_END' ).	! !!FileDescriptor methodsFor: 'as yet unclassified'!read: size	| retValue buffer |	buffer := ExternalBuffer new: size.	retValue := self readBuffer: buffer size: size.	! !!FileDescriptor methodsFor: 'as yet unclassified'!readBuffer: buffer size: size	^ LibC6 default read: self buffer: buffer size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!readString: aString	^ LibC6 default read: self string: aString size: aString size! !!FileDescriptor methodsFor: 'as yet unclassified'!readString: aString size: size	| internalSize |	internalSize := size.	aString size < size ifTrue: [ internalSize := aString size ].	^ LibC6 default read: self string: aString size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!size	| position size |	position := self position.	size := self positionFromEnd: 0.	self position: position.	^ size	! !!FileDescriptor methodsFor: 'as yet unclassified'!writeBuffer: buffer size: size	^ LibC6 default write: self buffer: buffer size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!writeString: aString	^ LibC6 default write: self string: aString size: aString size! !!FileDescriptor methodsFor: 'as yet unclassified'!writeString: aString size: size	| internalSize |	internalSize := size.	aString size < size ifTrue: [ internalSize := aString size ].	^ LibC6 default write: self string: aString size: size! !!FileDescriptor class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalValue! !!FileDescriptor class methodsFor: 'as yet unclassified'!initialize	self initializeStandardDescriptors! !!FileDescriptor class methodsFor: 'as yet unclassified'!initializeStandardDescriptors	StandardDescriptors := Dictionary new.	StandardDescriptors at: #stdout put: (self newFileDescriptor: 0).	StandardDescriptors at: #stdin put: (self newFileDescriptor: 1).	StandardDescriptors at: #stderr put: (self newFileDescriptor: 2).! !!FileDescriptor class methodsFor: 'as yet unclassified'!newFileDescriptor: anInteger	^ self new fileDescriptor: anInteger; yourself.! !!FileDescriptor class methodsFor: 'as yet unclassified'!standardDescriptors	^ StandardDescriptors! !!FileDescriptor class methodsFor: 'as yet unclassified'!stderr	^ StandardDescriptors at: #stderr.! !!FileDescriptor class methodsFor: 'as yet unclassified'!stdin	^ StandardDescriptors at: #stdin.! !!FileDescriptor class methodsFor: 'as yet unclassified'!stdout	^ StandardDescriptors at: #stdout.! !!FileStream methodsFor: 'as yet unclassified'!atEnd	"Answer true if the current position is >= the end of file position.	 1/31/96 sw: subclassResponsibility"	self subclassResponsibility! !!FileStream class methodsFor: 'as yet unclassified'!fileDoesNotExistUserHandling: fullFileName	(GtkMessageDialog question: fullFileName, ' does not exist, create it?') = #yes		ifTrue: [ ^ self new open: fullFileName forWrite: true ].! !!FileStream class methodsFor: 'as yet unclassified'!fileExistsUserHandling: fullFileName	(GtkMessageDialog question: fullFileName, ' exist, overwrite it?') = #yes		ifTrue: [ ^ self new openForOverwrite: fullFileName ].! !!FileStream class methodsFor: 'as yet unclassified'!readOnlyFileDoesNotExistUserHandling: fullFileName	GtkMessageDialog error: fullFileName, ' does not exist'! !!FileDoesNotExistException methodsFor: 'as yet unclassified'!defaultAction	"The default action taken if the exception is signaled."	^self readOnly		ifTrue: [FileStream readOnlyFileDoesNotExistUserHandling: self fileName]		ifFalse: [FileStream fileDoesNotExistUserHandling: self fileName]! !!GIRBuilder methodsFor: 'as yet unclassified'!compiledMethod	| bytecodes |	bytecodes := self bytecodes.	bytecodes ifNil: [ ^ nil ].	^ CompiledMethod new		primitive: 0;		numArgs: self numArgs;		numTemps: self numTemps;		literals: self literals;		relocationInfo: self relocationInfo;		bytecodes: bytecodes;		debugInfo: debugInfo;		source: source;		relocate.! !!GPointer methodsFor: 'as yet unclassified'!initialize	handle := self class defaultHandlerClass new.! !!GPointer class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalAddress! !!GPointer class methodsFor: 'as yet unclassified'!handle: aByteArray	^self basicNew handle: aByteArray; yourself! !!GObject class methodsFor: 'as yet unclassified'!handleFromObject: object	^ object handle.	! !!Gtk methodsFor: 'as yet unclassified'!initialize	self initializeGtkLibrary.	self startMainLoop.! !!Gtk class methodsFor: 'as yet unclassified'!shutDown: quiting	"Quits the Gtk main loop"	Default ifNotNil: [		Default quitMainLoop.		Default close.		Default := nil.	].! !!GtkDemoStockIds methodsFor: 'as yet unclassified'!initialize	| model tree |	model := GtkListStore new: {String. String. String. String}.	GtkStockItem allStocks do: [ :ea |		ea ifNotNil: [			model append: {				ea stockId asGtkStockId.				ea stockId.				ea label.				Gtk acceleratorName: ea keyval asCharacter modifier: ea modifier}]].	tree := GtkTreeView model: model.	self createFirstColumn: tree.	tree appendColumns: {		GtkTreeViewColumn title: 'Label' text: 2.		GtkTreeViewColumn title: 'Accel' text: 3.		GtkTreeViewColumn title: 'ID' text: 0}.	tree selection when: #changed send: #onItemChanged: to: self withArgumentsFirst: {tree}.			self container: (GtkHBox spacing: 5).	self container		packStart: (GtkScrolledWindow withChild: tree);		packEnd: self createInfoFrame expand: false fill: false! !!GtkDemoStockIds methodsFor: 'as yet unclassified'!onItemChanged: aTreeView	aTreeView selectedRow in: [:row |		idLabel label: row first.		nameLabel label: '#', row second.		accelLabel label: row third.		iconImage stock: row second iconSize: #dialog]! !!InMidstOfFileinNotification methodsFor: 'as yet unclassified'!defaultAction	^ self resume: false! !!LibC methodsFor: 'as yet unclassified'!closeLibrary	cLibrary closeLibrary.	cLibrary := nil.! !!LibC methodsFor: 'as yet unclassified'!initializeCLibrary	cLibrary := ExternalLibrary new.	cLibrary name: 'libc.so.6'.	cLibrary openLibrary.! !!LibC class methodsFor: 'as yet unclassified'!shutDown: quiting	"Quits the Gtk main loop"	self default closeLibrary.	Default := nil.! !!LibC6 methodsFor: 'as yet unclassified'!close: fd	| retValue |	retValue := ( self cDeclFunctionNamed: #close ) invokeWith: fd.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #close ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!errno	^ (self libraryDataNamed: #errno) value.	! !!LibC6 methodsFor: 'as yet unclassified'!errno: errno	(self libraryDataNamed: #errno) value: errno.	! !!LibC6 methodsFor: 'as yet unclassified'!free: anExternalBuffer	( self cDeclFunctionNamed: #free ) invokeWith: anExternalBuffer.	! !!LibC6 methodsFor: 'as yet unclassified'!getCurrentDirName	| retValue |	[ retValue := ( self cDeclFunctionNamed: 'get_current_dir_name' asSymbol ) invoke ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: 'get_current_dir_name' asSymbol ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!getEnv: envVariable	^ ( self cDeclFunctionNamed: #getenv ) invokeWith: envVariable.! !!LibC6 methodsFor: 'as yet unclassified'!getpid	^ (self cDeclFunctionNamed: #getpid) invoke.	! !!LibC6 methodsFor: 'as yet unclassified'!initialize	super initialize.	self initializeUniStd.	self initializeStdLib.	self initializeString.	self initializeFCntl.	self initializeStdIO.	self initializeErrNO.! !!LibC6 methodsFor: 'as yet unclassified'!initializeErrNO	self initializeLibraryDataNamed: #errno type: #SignedInteger.! !!LibC6 methodsFor: 'as yet unclassified'!initializeFCntl	self initializeCDeclFunctionNamed: #open returnType: #FileDescriptor argTypes: #( AsciiZ SignedInteger UnsignedInteger ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeStdIO	self initializeCDeclFunctionNamed: #printf  returnType: #SignedInteger argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: #perror  returnType: #Void argTypes: #( AsciiZ  ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeStdLib	self initializeCDeclFunctionNamed: #malloc  returnType: #ExternalBuffer argTypes: #( UnsignedInteger  ).	self initializeCDeclFunctionNamed: #free  returnType: #Void argTypes: #( ExternalBuffer  ).	self initializeCDeclFunctionNamed: #getenv  returnType: #AsciiZ argTypes: #( AsciiZ ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeString	self initializeCDeclFunctionNamed: #strlen returnType: #UnsignedInteger argTypes: #( AsciiZ ).	self initializeCDeclFunctionNamed: #strcat returnType: #AsciiZ argTypes: #( AsciiZ AsciiZ ).	self initializeCDeclFunctionNamed: #strcpy returnType: #AsciiZ argTypes: #( AsciiZ AsciiZ ).	self initializeCDeclFunctionNamed: #strerror returnType: #ReadOnlyAsciiZ argTypes: #( SignedInteger ).	self initializeCDeclFunctionNamed: #memset returnType: #ExternalBuffer argTypes: #( ExternalBuffer SignedInteger  UnsignedInteger ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeUniStd	self initializeCDeclFunctionNamed: #getpid  returnType: #UnsignedInteger argTypes: #().	self initializeCDeclFunctionNamed: 'get_current_dir_name' asSymbol  returnType: #AsciiZ argTypes: #().	self initializeCDeclFunctionNamed: #close  returnType: #SignedInteger argTypes: #( FileDescriptor ).	self initializeCDeclFunctionNamed: #lseek  returnType: #UnsignedInteger argTypes: #( FileDescriptor UnsignedInteger SignedInteger ).	self initializeCDeclFunctionNamed: #read  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalBuffer UnsignedInteger ).	self initializeCDeclFunctionNamed: #write  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalBuffer UnsignedInteger )."Redefinition of read for Strings"	symbolCache at: #readString put: (CDeclFunction name: #read library: self  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalArrayProxy UnsignedInteger ) )."Redefinition of write for Strings"	symbolCache at: #writeString put: (CDeclFunction name: #write library: self  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalArrayProxy UnsignedInteger ) ).! !!LibC6 methodsFor: 'as yet unclassified'!lseek: fileDescriptor offset: offset whence: whence	| returnValue |	returnValue := (self cDeclFunctionNamed: #lseek) invokeWith: fileDescriptor with: offset with: whence.	returnValue < 0 ifTrue: [		self throwErrorForExternalFunctionNamed: #lseek.		^ nil.	].	^ returnValue.	! !!LibC6 methodsFor: 'as yet unclassified'!malloc: size	| retValue |	[ retValue := ( self cDeclFunctionNamed: #malloc ) invokeWith: size ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: #malloc withMessage: 'can not allocate memory' ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!memSet: buffer constant: c count: n	^ (self cDeclFunctionNamed: #memset) invokeWith: buffer with: c with: n.	! !!LibC6 methodsFor: 'as yet unclassified'!open: path flags: flags	^ self open: path flags: flags mode: 8r644	! !!LibC6 methodsFor: 'as yet unclassified'!open: path flags: flags mode: mode	| fileDescriptor |	fileDescriptor := (self cDeclFunctionNamed: #open) invokeWith: path with: flags with: mode.	fileDescriptor fileDescriptor < 0 ifTrue: [		self throwErrorForExternalFunctionNamed: #open.		^ nil.	].	^ fileDescriptor.	! !!LibC6 methodsFor: 'as yet unclassified'!perror: aString	( self cDeclFunctionNamed: #perror ) invokeWith: aString.	! !!LibC6 methodsFor: 'as yet unclassified'!printf: aString	^ ( self cDeclFunctionNamed: #printf ) invokeWith: aString.	! !!LibC6 methodsFor: 'as yet unclassified'!read: fd buffer: buffer size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #read ) invokeWith: fd with: buffer with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #read ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!read: fd string: aString size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #readString ) invokeWith: fd with: aString with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #readString ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!strCat: destString with: sourceString	^ ( self cDeclFunctionNamed: #strcat ) invokeWith: destString with: sourceString.	! !!LibC6 methodsFor: 'as yet unclassified'!strCpy: destString with: sourceString	^ ( self cDeclFunctionNamed: #strcpy ) invokeWith: destString with: sourceString.	! !!LibC6 methodsFor: 'as yet unclassified'!strError: errno	| retValue |	[ retValue := ( self cDeclFunctionNamed: #strerror ) invokeWith: errno ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: #strerror ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!strLen: string	^ ( self cDeclFunctionNamed: #strlen ) invokeWith: string	! !!LibC6 methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName	^ self throwErrorForExternalFunctionNamed: functionName withMessage: (self strError: self errno).	! !!LibC6 methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName withMessage: aString	| error |	error := ExternalFunctionError functionName: functionName.	error messageText: aString.	^ error signal.	! !!LibC6 methodsFor: 'as yet unclassified'!valueForLSeekDirectiveNamed: aString	^ LSeekDirectives at: aString asSymbol.	! !!LibC6 methodsFor: 'as yet unclassified'!valueForOpenFlagNamed: aString	^ OpenFlags at: aString asSymbol.	! !!LibC6 methodsFor: 'as yet unclassified'!write: fd buffer: buffer size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #write ) invokeWith: fd with: buffer with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #write ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!write: fd string: aString size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #writeString ) invokeWith: fd with: aString with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #writeString ].	^ retValue.	! !!LibC6 class methodsFor: 'as yet unclassified'!initialize	self initializeOpenFlags.	self initializeLSeekDirectives.! !!LibC6 class methodsFor: 'as yet unclassified'!initializeLSeekDirectives	| lSeekDirectives |		lSeekDirectives := Dictionary new.	lSeekDirectives at: 'SEEK_SET' put: 0.	lSeekDirectives at: 'SEEK_CUR' put: 1.	lSeekDirectives at: 'SEEK_END' put: 2.	LSeekDirectives := lSeekDirectives! !!LibC6 class methodsFor: 'as yet unclassified'!initializeOpenFlags	| flagArray openFlags |		flagArray := #( 		('O_RDONLY'		0)		('O_WRONLY'		8r1)		('O_RDWR'		8r2)		('O_CREAT'		8r100)			('O_EXCL'			8r200)			('O_NOCTTY'		8r400)			('O_TRUNC'		8r1000)			('O_APPEND'		8r2000)		('O_NONBLOCK'	8r4000)		('O_SYNC'		8r10000)		('O_ASYNC'		8r20000)	).	openFlags := Dictionary new.	flagArray do: [ :i |		openFlags at: i first asSymbol put: i second	].	OpenFlags := openFlags! !!LibC6 class methodsFor: 'as yet unclassified'!moduleName	^ 'libc.so.6'.! !!LibExample methodsFor: 'as yet unclassified'!getpid	^ GETPID invoke! !!LibExample class methodsFor: 'as yet unclassified'!getpid	^ GETPID! !!LibExample class methodsFor: 'as yet unclassified'!initialize	GETPID := CDeclFunction name: 'getpid' libraryNamed: 'libc.so.6' returnType: #UnsignedInteger argTypes: #().! !!LibReadLine methodsFor: 'as yet unclassified'!addHistory: aString	( self cDeclFunctionNamed: 'add_history' asSymbol ) invokeWith: aString.! !!LibReadLine methodsFor: 'as yet unclassified'!initialize	super initialize.	self initializeCDeclFunctionNamed: #readline  returnType: #AsciiZ argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'add_history' asSymbol returnType: #Void argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'read_history' asSymbol returnType: #SignedInteger argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'write_history' asSymbol returnType: #SignedInteger argTypes: #( AsciiZ  ).! !!LibReadLine methodsFor: 'as yet unclassified'!readHistory: aFileName	| errno |	errno := ( self cDeclFunctionNamed: 'read_history' asSymbol ) invokeWith: aFileName.	errno = 0 ifFalse: [ self throwErrorForExternalFunctionNamed: 'read_history' asSymbol errno: errno ].	^ errno.! !!LibReadLine methodsFor: 'as yet unclassified'!readline: prompt	^ ( self cDeclFunctionNamed: #readline ) invokeWith: prompt.! !!LibReadLine methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName errno: errno	| error |	error := ExternalFunctionError functionName: functionName.	error messageText: (LibC6 default strError: errno).	^ error signal.! !!LibReadLine methodsFor: 'as yet unclassified'!writeHistory: aFileName	| errno |	errno := ( self cDeclFunctionNamed: 'write_history' asSymbol ) invokeWith: aFileName.	errno = 0 ifFalse: [ self throwErrorForExternalFunctionNamed: 'write_history' asSymbol errno: errno ].	^ errno.! !!LibReadLine class methodsFor: 'as yet unclassified'!moduleName	^ 'libreadline.so'.! !!LibraryData methodsFor: 'as yet unclassified'!primitiveGetValue: valueHandle	<primitive: 216>	^self primitiveFailed! !!LibraryData methodsFor: 'as yet unclassified'!primitiveSetValue: valueHandle	<primitive: 217>	^self primitiveFailed! !!LibraryData methodsFor: 'as yet unclassified'!type	^ type.! !!LibraryData methodsFor: 'as yet unclassified'!type: aType	type := aType.! !!LibraryData methodsFor: 'as yet unclassified'!value	| valueClass valueHandle |	valueClass := self classFromType: type.	valueHandle := valueClass defaultHandlerClass new.	handle isNull ifTrue: [ self bind ].	self primitiveGetValue: valueHandle.	^ valueClass objectFromHandle: valueHandle.! !!LibraryData methodsFor: 'as yet unclassified'!value: aValue	| argHandle argClass |	argClass := self classFromType: type.	argHandle := argClass handleFromObject: aValue.	handle isNull ifTrue: [ self bind ].	self primitiveSetValue: argHandle! !!LibraryData class methodsFor: 'as yet unclassified'!name: aName library: aLibrary type: type	^self new name: aName library: aLibrary;		type: type;		bind! !!Metaclass methodsFor: 'as yet unclassified'!addObsoleteSubclass: aClass	"Do nothing."! !!Metaclass methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return true if it is safe to zap the method dictionary on #obsolete"	thisClass == nil		ifTrue:[^true]		ifFalse:[^thisClass canZapMethodDictionary]! !!Metaclass methodsFor: 'as yet unclassified'!isSystemDefined	"Answer false if I am a UniClass (an instance-specific lightweight class)"	^ true! !!NativeFunction methodsFor: 'as yet unclassified'!callingConventionString	^ 'native'! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver	^self invokeReceiver: receiver withArguments: #()! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1	^self invokeReceiver: receiver withArguments: (Array with: arg1)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4 with: arg5	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver withArguments: argArray	handle isNull ifTrue: [ self bind ].	^ self primInvokeReceiver: receiver withArguments: argArray.! !!NativeFunction methodsFor: 'as yet unclassified'!primInvokeReceiver: receiver withArguments: argArray	"Manually invoke the receiver, representing an native function."	<primitive: 197>	^self primitiveFailed! !!ObjectTest methodsFor: 'as yet unclassified'!testBecome	"self debug: #testBecome"	"this test should that all the variables pointing to an object are pointing now to another one, and all      object pointing to the other are pointing to the object"	| pt1 pt2 pt3 |	pt1 := 0@0.	pt2 := pt1.	pt3 := 100@100.	pt1 become: pt3.	self assert: pt2 = (100@100).	self assert: pt3 = (0@0).	self assert: pt1 = (100@100).! !!ObjectTest methodsFor: 'as yet unclassified'!testBecomeForward	"self debug: #testBecomeForward"	"this test should that all the variables pointing to an object are pointing now to another one.	Not that this inverse is not true. This kind of become is called oneWayBecome in VW"	| pt1 pt2 pt3 |	pt1 := 0@0.	pt2 := pt1.	pt3 := 100@100.	pt1 becomeForward: pt3.	self assert: pt2 = (100@100).	self assert: pt3 == pt2.	self assert: pt1 = (100@100)! !!PrimitiveType class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalValue! !!PrimitiveType class methodsFor: 'as yet unclassified'!handleFromObject: anObject	^ self handleFromObject: anObject ifError: [ self throwTypeConvertionError ]! !!PrimitiveType class methodsFor: 'as yet unclassified'!handleFromObject: object ifError: aBlock	self subclassResponsibility.! !!PrimitiveType class methodsFor: 'as yet unclassified'!objectFromHandle: handle	^ self objectFromHandle: handle ifError: [  self throwTypeConvertionError ]! !!PrimitiveType class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock	self subclassResponsibility.! !!PrimitiveType class methodsFor: 'as yet unclassified'!throwTypeConvertionError	^ TypeConvertionError new signal! !!IntegerType class methodsFor: 'as yet unclassified'!handleFromObject: anInteger ifError: aBlock	| handle |		(self checkType: anInteger) ifFalse: [ ^ aBlock value ].	handle := ExternalValue new.	self store: anInteger in: handle.	^ handle.	! !!IntegerType class methodsFor: 'as yet unclassified'!isBigEndian	^  false! !!IntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	self subclassResponsibility.! !!IntegerType class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: errorBlock	| value |		value := self loadFrom: handle.	(value > self max ) ifTrue: [ ^ errorBlock value ].	^ value.! !!Process methodsFor: 'as yet unclassified'!primitiveBeInitialProcess	<primitive: 196>	self primitiveFailed! !!ProcessorScheduler methodsFor: 'as yet unclassified'!activeProcess	^ self primActiveProcess! !!ProcessorScheduler methodsFor: 'as yet unclassified'!primActiveProcess	<primitive: 195>	self primitiveFail.! !!ProcessorScheduler methodsFor: 'as yet unclassified'!startUp	| firstProcess |"	(processList isNil or: [ processList isEmpty not ]) ifTrue: [ self initialize ]."	self initialize.	firstProcess := Process new.	firstProcess name: 'Init'.	firstProcess priority: self userSchedulingPriority.	firstProcess state: #running."	firstProcess threadData: self activeThreadData."	firstProcess primitiveBeInitialProcess.! !!ReadOnlyAsciiZ methodsFor: 'as yet unclassified'!asString	^ handle toString.! !!ReadOnlyAsciiZ class methodsFor: 'as yet unclassified'!handleFromObject: aByteArray ifError: aBlock	"Can not be used as arguments"	aBlock value.! !!ReadOnlyAsciiZ class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; asString! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!addressRelativeTo: bytecodes	| functionAddress bytecodesAddress |	functionAddress := self function address asInteger.	bytecodesAddress := (ExternalAddress forArray: bytecodes ) asInteger.	^ functionAddress - bytecodesAddress - offset - 4! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!function	^ self library functionNamed: functionName.! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!functionName	^ functionName! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!functionName: aSymbol	^ functionName := aSymbol! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!library	^ Executable default! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!patch: bytecodes	self patch: bytecodes with: (self addressRelativeTo: bytecodes).! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!patch: bytecodes with: value	bytecodes longAt: (offset + 1) put: value bigEndian: false.! !!FunctionRelocation methodsFor: 'as yet unclassified'!addressRelativeTo: bytecodes	^ self primAddressRelativeTo: bytecodes! !!FunctionRelocation methodsFor: 'as yet unclassified'!primAddressRelativeTo: bytecodes	<primitive: 155>	self primitiveFail.! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!defaultLibraryClass	^ NativeLibrary! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!library 		^ self defaultLibraryClass named: libraryName! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!libraryName	^ libraryName! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!libraryName: aSymbol	^ libraryName := aSymbol! !!ExternalFunctionRelocation methodsFor: 'as yet unclassified'!defaultLibraryClass	^ ExternalLibrary2! !!SequenceableCollection methodsFor: 'as yet unclassified'!asTraitComposition	"For convenience the composition {T1. T2 ...} is the same as T1 + T2 + ..."	^self isEmpty		ifFalse: [			self size = 1				ifTrue: [self first asTraitComposition]				ifFalse: [					self copyWithoutFirst 						inject: self first						into: [:left :right | left + right]]]		ifTrue: [			TraitComposition new]! !!Array methodsFor: 'as yet unclassified'!elementsExchangeIdentityWith: otherArray	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsExchangeIdentityWith: otherArray.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!elementsForwardIdentityTo: otherArray	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsForwardIdentityTo: otherArray.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!elementsForwardIdentityTo: otherArray copyHash: copyHash	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsForwardIdentityTo: otherArray copyHash: copyHash.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!primElementsExchangeIdentityWith: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  At the same time, all pointers to the elements of otherArray are replaced by pointers to the corresponding elements of this array.  The identityHashes remain with the pointers rather than with the objects so that objects in hashed structures should still be properly indexed after the mutation."	<primitive: 128>	otherArray class == Array ifFalse: [^ self error: 'arg must be array'].	self size = otherArray size ifFalse: [^ self error: 'arrays must be same size'].	(self anySatisfy: [:obj | obj class == SmallInteger]) ifTrue: [^ self error: 'can''t become SmallIntegers'].	(otherArray anySatisfy: [:obj | obj class == SmallInteger]) ifTrue: [^ self error: 'can''t become SmallIntegers'].	"Must have failed because not enough space in forwarding table (see ObjectMemory-prepareForwardingTableForBecoming:with:twoWay:).  Do GC and try again only once"	(Smalltalk bytesLeft: true) = Smalltalk primitiveGarbageCollect		ifTrue: [^ self primitiveFailed].	^ self elementsExchangeIdentityWith: otherArray! !!Array methodsFor: 'as yet unclassified'!primElementsForwardIdentityTo: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  The identityHashes remain with the pointers rather than with the objects so that the objects in this array should still be properly indexed in any existing hashed structures after the mutation."	<primitive: 72>	self primitiveFailed! !!Array methodsFor: 'as yet unclassified'!primElementsForwardIdentityTo: otherArray copyHash: copyHash	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  The identityHashes remain with the pointers rather than with the objects so that the objects in this array should still be properly indexed in any existing hashed structures after the mutation."	<primitive: 249>	self primitiveFailed! !!ExternalValue methodsFor: 'as yet unclassified'!beNull	"Make the receiver a NULL pointer"	self atAllPut: 0.! !!ExternalValue methodsFor: 'as yet unclassified'!isNull	^(self basicAt: 1) = 0	and: (self basicAt: 2) = 0	and: (self basicAt: 3) = 0	and: (self basicAt: 4) = 0	! !!ExternalValue class methodsFor: 'as yet unclassified'!initialize	Smalltalk addToStartUpList: self.! !!ExternalValue class methodsFor: 'as yet unclassified'!new	"External addresses are always 4 bytes long"	^super new: 4! !!ExternalValue class methodsFor: 'as yet unclassified'!new: n	"You better don't try this..."	^self shouldNotImplement! !!ExternalValue class methodsFor: 'as yet unclassified'!startUp: resuming	resuming ifTrue: [		self allInstancesDo: [ :addr |			addr beNull		]	].! !!SharedPool class methodsFor: 'as yet unclassified'!bindingOf: varName	"Answer the binding of some variable resolved in the scope of the receiver"	| aSymbol binding |	aSymbol := varName asSymbol.	"First look in classVar dictionary."	binding := self classPool bindingOf: aSymbol.	binding ifNotNil:[^binding].	"Next look in shared pools."	self sharedPools do:[:pool | 		binding := pool bindingOf: aSymbol.		binding ifNotNil:[^binding].	].	"subclassing and environment are not preserved"	^nil! !!SharedPool class methodsFor: 'as yet unclassified'!bindingsDo: aBlock	^self classPool bindingsDo: aBlock! !!SharedPool class methodsFor: 'as yet unclassified'!classBindingOf: varName	"For initialization messages grant the regular scope"	^super bindingOf: varName! !!SharedPool class methodsFor: 'as yet unclassified'!hasBindingThatBeginsWith: aString	"Answer true if the receiver has a binding that begins with aString, false otherwise"	"First look in classVar dictionary."	(self classPool hasBindingThatBeginsWith: aString) ifTrue:[^true].	"Next look in shared pools."	self sharedPools do:[:pool | 		(pool hasBindingThatBeginsWith: aString) ifTrue: [^true]].	^false! !!SharedPool class methodsFor: 'as yet unclassified'!includesKey: aName	"does this pool include aName"	^(self bindingOf: aName) notNil! !!SharedPool class methodsFor: 'as yet unclassified'!keysDo: aBlock"A hopefully temporary fix for an issue arising from miss-spelled variable names in code being compiled. The correction code (see Class>possibleVariablesFor:continuedFrom: assumes that sharedPools are Dictionaries. The proper fix would involve making sure all pools are actually subclasses of SharedPool, which they are not currently."	self bindingsDo:[:b|		aBlock value: b key]! !!Shell methodsFor: 'as yet unclassified'!display: string	| buffer |		buffer := AsciiZ fromString: string.	^ FileDescriptor stdout writeBuffer: buffer size: buffer size.! !!Shell methodsFor: 'as yet unclassified'!input: prompt	^ LibReadLine default readline: prompt! !!Shell methodsFor: 'as yet unclassified'!main	| line value failed anotherLine buffer |	LibReadLine default readHistory: self historyFileName.	[		anotherLine := false.		buffer := ''.		[ 	| prompt |			prompt := anotherLine ifTrue: [ '' ] ifFalse: [ '> ' ].			line _ self input: prompt.			line isEmpty				ifTrue: [ true ] 				ifFalse: [					(line last = $\)						ifTrue: [							anotherLine := true.							line at: line size put: Character lf.						]						ifFalse: [ anotherLine := false ].					buffer := buffer, line.					anotherLine				]		] whileTrue. 		buffer = 'quit' or: [ buffer = 'save' ]	] whileFalse: [		self addToHistory: buffer.		failed _ false.		value _ Compiler new evaluate: buffer in: nil to: nil notifying: self ifFail: [ failed _ true].		failed ifFalse: [ self display: (value printString); lf ]	].	LibReadLine default writeHistory: self historyFileName.	buffer = 'save' ifTrue: [ Smalltalk snapshotAndQuit ].	^value.! !!SignedIntegerType class methodsFor: 'as yet unclassified'!checkType: value	^ value isInteger and: [ value >= self min and: [ value <= self max ] ]! !!SignedIntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	^ handle longAt: 1 bigEndian: self isBigEndian.! !!SignedIntegerType class methodsFor: 'as yet unclassified'!store: anInteger in: handle	handle longAt: 1 put: anInteger bigEndian: self isBigEndian.! !!SignedByte class methodsFor: 'as yet unclassified'!max			^ 127! !!SignedByte class methodsFor: 'as yet unclassified'!min			^ -128! !!SignedInteger class methodsFor: 'as yet unclassified'!max			^ 2147483647! !!SignedInteger class methodsFor: 'as yet unclassified'!min			^ -2147483648! !!SignedShortInteger class methodsFor: 'as yet unclassified'!max			^ 32767! !!SignedShortInteger class methodsFor: 'as yet unclassified'!min			^ -32768! !!SourceReference methodsFor: 'as yet unclassified'!sourceFrom: aString	self hasEmptySourceReference ifTrue: [ ^ '' ].	^ aString copyFrom: sourceStart to: sourceStop! !!StandardFileStream class methodsFor: 'as yet unclassified'!retryWithGC: execBlock until: testBlock forFileNamed: fullName	"Re-implemented to only force GC if a file with the given name exists"	| blockValue foundIt |	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	"See if we have a file with the given name"	foundIt := self registry keys "hold on strongly for now" 		anySatisfy:[:file| file name sameAs: fullName].	foundIt ifFalse:[^blockValue].	Smalltalk garbageCollectMost.	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollect.	^execBlock value.! !!SystemDictionary methodsFor: 'as yet unclassified'!forgetClass: aClass logged: aBool 	"Delete the class, aClass, from the system.	Note that this doesn't do everything required to dispose of a class - to do that use Class>>removeFromSystem."	aBool ifTrue: [SystemChangeNotifier uniqueInstance classRemoved: aClass fromCategory: aClass category].			SystemOrganization removeElement: aClass name.	self removeFromStartUpList: aClass.	self removeFromShutDownList: aClass.	self removeKey: aClass name ifAbsent: [].	self flushClassNameCache! !!SystemDictionary methodsFor: 'as yet unclassified'!removeClassNamed: aName	"Invoked from fileouts:  if there is currently a class in the system named aName, then remove it.  If anything untoward happens, report it in the Transcript.  "	| oldClass |	(oldClass _ self at: aName asSymbol ifAbsent: [nil]) == nil		ifTrue:			[Transcript cr; show: 'Removal of class named ', aName, ' ignored because ', aName, ' does not exist.'.			^ self].	oldClass removeFromSystem! !!SystemDictionary methodsFor: 'as yet unclassified'!startUp	Processor startUp.	ProcessorScheduler startUp.	self processStartUpList: true.	self installLowSpaceWatcher.! !!SystemTracer methodsFor: 'as yet unclassified'!getAligned: size	^ (( size + 3 ) bitShift: -2) bitShift: 2.! !!TraitBehavior methodsFor: 'as yet unclassified'!addUser: aClassOrTrait	users add: aClassOrTrait! !!TraitBehavior methodsFor: 'as yet unclassified'!classesComposedWithMe	^users gather: [:u | u classesComposedWithMe]! !!TraitBehavior methodsFor: 'as yet unclassified'!initialize	self methodDict: Dictionary new.	self traitComposition: nil.	users _ IdentitySet new.! !!TraitBehavior methodsFor: 'as yet unclassified'!removeUser: aClassOrTrait	users remove: aClassOrTrait ifAbsent: []! !!TraitBehavior methodsFor: 'as yet unclassified'!users	^users! !!TraitComposition methodsFor: 'as yet unclassified'!assertValidUser: aBehavior	"Assert that this trait composition set for aBehavior	does not introduce a cycle."		(self allTraits includes: aBehavior) ifTrue: [		TraitCompositionException signal: 'Cycle in compositions:  The composition (in)directly includes this trait!!']! !!TraitComposition methodsFor: 'as yet unclassified'!methodDescriptionsForSelector: aSymbol	"Return a collection of TraitMethodDescriptions for aSymbol and all the 	aliases of aSymbol."	| selectors collection |	selectors _ IdentitySet with: aSymbol.	self transformations do: [:each |		selectors addAll: (each aliasesForSelector: aSymbol)].	collection _ OrderedCollection new: selectors size.	selectors do: [:each |		collection add: (self methodDescriptionForSelector: each)].	^collection! !!TraitDescription methodsFor: 'as yet unclassified'!trait	"for compatibility with TraitTransformations"	^ self! !!TraitDescription methodsFor: 'as yet unclassified'!updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil	| currentCategory effectiveCategory sel changedCategories composition |	changedCategories _ IdentitySet new.	composition := self hasTraitComposition		ifTrue: [self traitComposition]		ifFalse: [TraitComposition new].	(composition methodDescriptionsForSelector: aSymbol) do: [:each |		sel _ each selector.		(self includesLocalSelector: sel) ifFalse: [			currentCategory _ self organization categoryOfElement: sel.			effectiveCategory _ each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.			effectiveCategory isNil ifTrue: [				currentCategory ifNotNil: [changedCategories add: currentCategory].				self organization removeElement: sel.			] ifFalse: [				((currentCategory isNil or: [currentCategory == ClassOrganizer ambiguous or: [currentCategory == oldCategoryOrNil]]) and: [currentCategory ~~ effectiveCategory]) ifTrue: [					currentCategory ifNotNil: [changedCategories add: currentCategory].					self organization 						classify: sel 						under: effectiveCategory						suppressIfDefault: false]]]].	^ changedCategories! !!TraitDescription methodsFor: 'as yet unclassified'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	(self includesSelector: aSelector)		ifTrue: [^ self organization categoryOfElement: aSelector]		ifFalse: [^nil]! !!Trait methodsFor: 'as yet unclassified'!initialize	super initialize.	classTrait _ ClassTrait for: self! !!TranscriptCodeView class methodsFor: 'as yet unclassified'!initialize	Smalltalk addToStartUpList: self.! !!TranscriptCodeView class methodsFor: 'as yet unclassified'!startUp: resuming	resuming ifTrue: [		TranscriptCodeBuffer := nil.	].! !!TranscriptStream methodsFor: 'as yet unclassified'!open	TranscriptCodeEditor open.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!atEnd	position ifNil: [ ^ nil ].	^ position >= readLimit! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!close	"Close this file."	fileID ifNotNil: [		fileID close.		fileID := nil.		position := nil.	].! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!open: fileName flags: flags	[ fileID := LibC6 default open: fileName flags: flags ]		on: ExternalFunctionError		do: [ ^ nil ].	name := fileName.	readLimit := fileID size.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!open: fileName forWrite: writeMode 	| flags |	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	flags := writeMode 		ifTrue: [ LibC6 default valueForOpenFlagNamed: 'O_RDWR' ]		ifFalse: [ LibC6 default valueForOpenFlagNamed: 'O_RDONLY' ].	rwmode := writeMode.	^ self open: fileName flags: flags.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!openForOverwrite: fileName	| flags |	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	flags := ((LibC6 default valueForOpenFlagNamed: 'O_RDWR') 			bitOr: ( LibC6 default valueForOpenFlagNamed: 'O_TRUNC' )) 			bitOr: ( LibC6 default valueForOpenFlagNamed: 'O_CREAT' ).	rwmode := true.	^ self open: fileName flags: flags.! !!BufferedFileStream methodsFor: 'as yet unclassified'!close	"Close this file."	self flush.	^ super close.! !!BufferedFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	self subclassResponsibility! !!BufferedFileStream methodsFor: 'as yet unclassified'!defaultBufferSize	^ DefaultBufferSize.! !!BufferedFileStream methodsFor: 'as yet unclassified'!flush	| bufferPosition bufferSize |	fileID ifNil: [ ^ nil ].	rwmode ifFalse: [ ^ nil ].	bufferPosition := position truncateTo: (collection size).	bufferSize := collection size min: ( readLimit - bufferPosition).	fileID position: bufferPosition.	bufferSize > 0 ifTrue: [ fileID writeString: collection size: bufferSize ].	 ! !!BufferedFileStream methodsFor: 'as yet unclassified'!initializeBuffer	| bufferSize |	position := 0.	collection := self defaultBufferClass new: self defaultBufferSize.	bufferSize := collection size min: readLimit.	bufferSize > 0 ifTrue: [ fileID readString: collection size: bufferSize ]. ! !!BufferedFileStream methodsFor: 'as yet unclassified'!next	| byte |	byte := self peek.	self position: position + 1.	^ byte! !!BufferedFileStream methodsFor: 'as yet unclassified'!nextPut: char	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	position ifNil: [ self position: 0 ].	collection at: (position \\ (collection size)) + 1put: char.	self position: position + 1.	^ char! !!BufferedFileStream methodsFor: 'as yet unclassified'!open: fileName flags: flags	(super open: fileName flags: flags) ifNotNil: [ self initializeBuffer ].! !!BufferedFileStream methodsFor: 'as yet unclassified'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	position ifNil: [ self position: 0 ].	self atEnd ifTrue: [^ nil ].	^ collection at: (position \\ (collection size)) + 1.! !!BufferedFileStream methodsFor: 'as yet unclassified'!position: newPosition	| oldBufferPosition newBufferPosition bufferSize |	fileID ifNil: [ ^nil ].	newPosition < 0 ifTrue: [ ^nil ]."	((newPosition > readLimit) and: [ rwmode not ])  ifTrue: [ ^nil ]."	newPosition > readLimit ifTrue: [		rwmode ifTrue: [ readLimit := newPosition ] ifFalse: [ ^nil ]	].	oldBufferPosition := position truncateTo: (collection size).	newBufferPosition := newPosition truncateTo: (collection size).	newBufferPosition = oldBufferPosition ifFalse: [ 		self flush.		fileID position: newBufferPosition.		bufferSize := collection size min: ( readLimit - newBufferPosition).		collection := self defaultBufferClass new: self defaultBufferSize.		bufferSize > 0 ifTrue: [ fileID readString: collection size: bufferSize ].	].	position := newPosition."	rwmode ifTrue: [ readLimit := newPosition ]."	^ position.! !!BinaryFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	^ ByteArray! !!TextFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	^ String! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!concreteStream	"Who should we really direct class queries to?  "	^ UnbufferedFileStream.! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!fileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new open: fileName forWrite: true! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!forceNewFileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new openForOverwrite: fileName! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!readOnlyFileNamed: fileName 	"Open an existing file with the given name for reading."	| f |	f := self new open: fileName forWrite: false.	^ f isNil		ifFalse: [f]		ifTrue: ["File does not exist..."			((FileDoesNotExistException fileName: fileName) readOnly: true) signal].	"StandardFileStream readOnlyFileNamed: 'kjsd.txt' "! !!BufferedFileStream class methodsFor: 'as yet unclassified'!initialize	self initializeDefaultBufferSize.! !!BufferedFileStream class methodsFor: 'as yet unclassified'!initializeDefaultBufferSize	DefaultBufferSize := 4096.! !!BufferedFileStream class methodsFor: 'as yet unclassified'!new	^ TextFileStream new.! !!UnhandledError methodsFor: 'as yet unclassified'!devDefaultAction	"The current computation is terminated. The cause of the error should be logged or reported to the user. If the program is operating in an interactive debugging environment the computation should be suspended and the debugger activated."	(GtkMessageDialog question: exception messageText, ', debug it?' ) = #yes		ifTrue: [ ^Processor activeProcess debugError: exception ]."	^ Processor activeProcess terminate."! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!checkType: value	^ value isInteger and: [ value >= 0 and: [ value <= self max ] ]! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	^ handle unsignedLongAt: 1 bigEndian: self isBigEndian.! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!min	^ 0! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!store: anInteger in: handle	handle unsignedLongAt: 1 put: anInteger bigEndian: self isBigEndian.! !!UnsignedByte class methodsFor: 'as yet unclassified'!max			^ 255! !!UnsignedInteger class methodsFor: 'as yet unclassified'!max			^ 4294967295! !!UnsignedShortInteger class methodsFor: 'as yet unclassified'!max			^ 65535! !!Workspace methodsFor: 'as yet unclassified'!buildMenuBar	| menu  edit  |	menu := GtkMenuBar new.	edit := GtkMenu new.	menu		append: AppLauncher fileMenu;		append: (edit createMenuItem: '_Edit');		append: workspaceView menu;		append: AppLauncher toolsMenu;		append: AppLauncher helpMenu.					^ menu.! !!Workspace methodsFor: 'as yet unclassified'!buildToolBar	| toolBar |	^ GtkToolbar new		appendItems: workspaceView toolBar;		yourself! !!Workspace methodsFor: 'as yet unclassified'!defaultCodeViewClass	^ WorkspaceView! !!Workspace methodsFor: 'as yet unclassified'!initialize	workspaceView := self defaultCodeViewClass new.	self container: (GtkVBox new		packStart: (self buildMenuBar) expand: false;		packStart: (self buildToolBar) expand: false;		packStart: (workspaceView view);		packStart: (GtkStatusbar new) expand: false	).! !!Workspace methodsFor: 'as yet unclassified'!inspectedVar: anObject	workspaceView inspectedVar: anObject.! !!TranscriptCodeEditor methodsFor: 'as yet unclassified'!defaultCodeViewClass	^ TranscriptCodeView! !!Workspace class methodsFor: 'as yet unclassified'!defaultSize	^ 640@480.! !!Workspace class methodsFor: 'as yet unclassified'!title	^'Workspace'! !!TranscriptCodeEditor class methodsFor: 'as yet unclassified'!title	^'Transcript'! !BufferedFileStream initialize!TranscriptCodeView initialize!TraitBehavior removeSelector: #initializeUsers!Application subclass: #Shell	instanceVariableNames: 'bindings'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!ExternalValue initialize!NativeFunctionRelocation removeSelector: #addressRelativeTo:!NativeFunctionRelocation removeSelector: #function!NativeFunctionRelocation removeSelector: #functionName!NativeFunctionRelocation removeSelector: #functionName:!NativeFunctionRelocation removeSelector: #patch:!NativeFunctionRelocation removeSelector: #patch:with:!ReadOnlyAsciiZ class removeSelector: #objectFromHandle:!ProcessorScheduler removeSelector: #activeProcess2!ProcessorScheduler removeSelector: #activeThreadData!ProcessorScheduler removeSelector: #primActiveThreadData!Process removeSelector: #threadData:!PrimitiveType class removeSelector: #defaultHandlerType!PrimitiveType class removeSelector: #instantiateHandler!NativeFunction removeSelector: #address!NativeFunction removeSelector: #bind!NativeFunction removeSelector: #invoke!NativeFunction removeSelector: #invokeAnswering:!NativeFunction removeSelector: #invokeAnswering:with:!NativeFunction removeSelector: #invokeAnswering:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:withArguments:!NativeFunction removeSelector: #invokeWith:!NativeFunction removeSelector: #invokeWith:with:!NativeFunction removeSelector: #invokeWith:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:with:with:!NativeFunction removeSelector: #invokeWithArguments:!NativeFunction removeSelector: #name!NativeFunction removeSelector: #name:!NativeFunction removeSelector: #throwNotKnownError!LibraryData removeSelector: #primitiveGetValue!LibExample initialize!LibC6 initialize!LibC6 removeSelector: #initializeUnistd!LibC6 removeSelector: #openPath:flags:!LibC6 removeSelector: #write2:buffer:size:!LibC removeSelector: #close!GPointer class removeSelector: #instantiateHandler!FileStream removeSelector: #position!FileDescriptor initialize!FileDescriptor removeSelector: #movePositionTo:!FileDescriptor removeSelector: #name!FileDescriptor removeSelector: #name:!FileDescriptor removeSelector: #positionFromEns:!FileDescriptor removeSelector: #setPositionAt:!FileDescriptor removeSelector: #setPositionFromEndAt:!CDeclFunction class removeSelector: #name:libraryNamed:returnType:argTypes:!ExecutableFunction class removeSelector: #name:library:!ExecutableFunction class removeSelector: #name:libraryNamed:!CDeclFunction removeSelector: #classFromType:!CDeclFunction removeSelector: #throwExternalFunctionError!ExecutableFunction removeSelector: #address!ExecutableFunction removeSelector: #bind!ExecutableFunction removeSelector: #invoke!ExecutableFunction removeSelector: #invokeWith:!ExecutableFunction removeSelector: #invokeWith:with:!ExecutableFunction removeSelector: #invokeWith:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithArguments:!ExecutableFunction removeSelector: #invokeWithReceiver:!ExecutableFunction removeSelector: #invokeWithReceiver:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:withArguments:!ExecutableFunction removeSelector: #library!ExecutableFunction removeSelector: #library:!ExecutableFunction removeSelector: #libraryName!ExecutableFunction removeSelector: #libraryNamed:!ExecutableFunction removeSelector: #name!ExecutableFunction removeSelector: #name:!ExecutableFunction removeSelector: #name:library:!ExecutableFunction removeSelector: #name:libraryNamed:!ExecutableFunction removeSelector: #primInvokeReceiver:withArguments:!ExecutableFunction removeSelector: #primInvokeWithArguments:!ExecutableFunction removeSelector: #primInvokeWithReceiver:withArguments:!ExecutableFunction removeSelector: #throwNotKnownError!ExternalSymbol removeSelector: #callingConventionString!ExternalObjectProxy removeSelector: #register!ExternalObjectProxy removeSelector: #unregister!AsciiZ class removeSelector: #objectFromHandle:!Executable class removeSelector: #huenul!DynamicLibrary class removeSelector: #addLibrary:named:!DynamicLibrary class removeSelector: #huemul!DynamicLibrary initialize!DynamicLibrary class removeSelector: #name:!DynamicLibrary class removeSelector: #named:!ExternalObject class removeSelector: #handle:!ExternalObject initialize!ExternalObject class removeSelector: #registry!ExternalObject class removeSelector: #registry:!AsciiZ removeSelector: #setFrom:!ExternalBuffer removeSelector: #finalize!ExternalBuffer removeSelector: #selfCheck!ExternalBuffer removeSelector: #setFrom:!ExternalBuffer removeSelector: #storeInto:size:!Executable removeSelector: #initialize!Executable removeSelector: #instantiateFunctionClass:!Executable removeSelector: #name:!Executable removeSelector: #nativeFunctionNamed:!Executable removeSelector: #primitiveOpen!DynamicLibrary removeSelector: #addExternal:!DynamicLibrary removeSelector: #basicName!DynamicLibrary removeSelector: #bind:!DynamicLibrary removeSelector: #bindFunction:!DynamicLibrary removeSelector: #cDeclFunctionNamed:returnType:argTypes:!DynamicLibrary removeSelector: #primitiveBind:!DynamicLibrary removeSelector: #primitiveBindFunction:!ExternalObject removeSelector: #isNullPointer!Object subclass: #ExternalObject	instanceVariableNames: 'handle'	classVariableNames: 'Registry'	poolDictionaries: ''	category: 'FFI-Types'!ExternalFunctionError class removeSelector: #function:!ExternalFunctionError removeSelector: #function!ExternalFunctionError removeSelector: #function:!ExternalFunctionError removeSelector: #isResumable!Error subclass: #ExternalFunctionError	instanceVariableNames: 'functionName'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!Application class removeSelector: #start!Application class removeSelector: #startWithArguments:!Class removeSelector: #superclass:methodDict:format:name:organization:instVarNames:classPool:sharedPools:!ClassBuilder removeSelector: #computeFormat:instSize:forSuper:ccIndex:!ClassBuilder removeSelector: #format:variable:words:pointers:weak:!Smalltalk removeClassNamed: #SystemChangeNotifierTest!RBProgramNodeVisitor subclass: #ASTChecker	instanceVariableNames: 'scope varsChangedInSend'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!RBProgramNodeVisitor subclass: #ASTTranslator	instanceVariableNames: 'methodBuilder receiverForCascade'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #Application	instanceVariableNames: 'arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!AssembleInstruction subclass: #AssembleCMov	instanceVariableNames: ''	classVariableNames: 'Condition'	poolDictionaries: ''	category: 'Exupery'!Object subclass: #AssemblerExupery	instanceVariableNames: 'stream blockAddresses jumpOffsets bytecodes instructionEncoders plugin relocator picEntries debugCollector source'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #BlockClosure	instanceVariableNames: 'method environment'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Contexts'!PluggableGtkSimpleApplication subclass: #ClassFinder	instanceVariableNames: 'classTrait'	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!Object subclass: #ColouringRegisterAllocator	instanceVariableNames: 'source result machine interferenceGraph registerStack registerFile registerTable spiltRegisters hasSpilt coloursUsed simplifyWorklist spillWorklist moveWorklist coalescedMoves isValidating deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #DebugInfo	instanceVariableNames: 'codeSourceReferences argVarsReferences tempVarsReferences capturedVarsReferences'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!Object subclass: #EventManager	instanceVariableNames: 'actionMap'	classVariableNames: 'ActionMaps'	poolDictionaries: ''	category: 'System-Object'!Error subclass: #ExternalFunctionError	instanceVariableNames: 'functionName '	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!Object subclass: #ExternalObject	instanceVariableNames: 'handle '	classVariableNames: 'Registry '	poolDictionaries: ''	category: 'FFI-Types'!ExternalObject subclass: #DynamicLibrary	instanceVariableNames: 'name symbolCache'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!DynamicLibrary subclass: #Executable	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!ExternalObject subclass: #ExternalBuffer	instanceVariableNames: 'size'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalBuffer subclass: #AsciiZ	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!DynamicLibrary class	instanceVariableNames: 'default'!ExternalObject subclass: #ExternalObjectProxy	instanceVariableNames: 'object'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalObjectProxy subclass: #ExternalArrayProxy	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalObject subclass: #ExternalSymbol	instanceVariableNames: 'name library'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!ExternalSymbol subclass: #ExecutableFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!ExecutableFunction subclass: #CDeclFunction	instanceVariableNames: 'returnType argTypes'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Error subclass: #ExternalSymbolError	instanceVariableNames: 'symbolName'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!ExternalObject subclass: #FileDescriptor	instanceVariableNames: ''	classVariableNames: 'StandardDescriptors'	poolDictionaries: ''	category: 'FFI-Types'!Error subclass: #FileStreamException	instanceVariableNames: 'fileName'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #CannotDeleteFileException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #FileDoesNotExistException	instanceVariableNames: 'readOnly'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #FileExistsException	instanceVariableNames: 'fileClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!AssemblyCopier subclass: #FinalCopier	instanceVariableNames: 'deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!LexicalScope subclass: #FunctionScope	instanceVariableNames: 'thisContextVar thisEnvVar tempVars capturedVars isHome hasInnerFreeVars hideTemps argVars uninitializedTemps capturedParentEnv'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #GIRBuilder	instanceVariableNames: 'ir currentBlock machine relocationInfo primitiveNode literals thisEnvVar cacheMap literalTemp source start stop debugInfo'	classVariableNames: 'InlinedSelectors SpecialConstants SpecialSelectors'	poolDictionaries: ''	category: 'Compiler-IR'!LexicalScope subclass: #InstanceScope	instanceVariableNames: 'vars'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!DynamicLibrary subclass: #LibC6	instanceVariableNames: ''	classVariableNames: 'LSeekDirectives OpenFlags'	poolDictionaries: ''	category: 'FFI-Libraries'!Object subclass: #LibExample	instanceVariableNames: ''	classVariableNames: 'GETPID'	poolDictionaries: ''	category: 'Guille-Test'!DynamicLibrary subclass: #LibReadLine	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!ExternalSymbol subclass: #LibraryData	instanceVariableNames: 'type'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Object subclass: #LivenessAnalyser	instanceVariableNames: 'source hasUpdated isValidating deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #MedLanguage	instanceVariableNames: 'in out start stop'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedCMov	instanceVariableNames: 'type from to'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedEnter	instanceVariableNames: 'argument'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedLeave	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedLiteral	instanceVariableNames: 'literal'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLiteral subclass: #MedFunction	instanceVariableNames: 'block byteCodeAddress'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!ExecutableFunction subclass: #NativeFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Object subclass: #PrimitiveType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!PrimitiveType subclass: #IntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!RBProgramNode subclass: #RBReturnNode	instanceVariableNames: 'return value homeBinding frameBinding'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Nodes'!ExternalObject subclass: #ReadOnlyAsciiZ	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SemanticWarning subclass: #RedeclaredVariableWarning	instanceVariableNames: 'variableNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #RelocationInfo	instanceVariableNames: 'offset'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #ExecutableFunctionRelocation	instanceVariableNames: 'functionName'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #FunctionRelocation	instanceVariableNames: 'function'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #LiteralRelocation	instanceVariableNames: 'literals'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!ExecutableFunctionRelocation subclass: #NativeFunctionRelocation	instanceVariableNames: 'libraryName'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!NativeFunctionRelocation subclass: #ExternalFunctionRelocation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #PrimitiveRelocation	instanceVariableNames: 'number'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!Object subclass: #ScopeVar	instanceVariableNames: 'scope usage'	classVariableNames: 'UsageAutomaton'	poolDictionaries: ''	category: 'Compiler-Semantics'!ScopeVar subclass: #GlobalVar	instanceVariableNames: 'assoc'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!ScopeVar subclass: #LocalVar	instanceVariableNames: 'name index'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!LocalVar subclass: #ArgVar	instanceVariableNames: 'isArg'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!LocalVar subclass: #CapturedVar	instanceVariableNames: 'sourceTemp'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!ByteArray variableByteSubclass: #ExternalValue	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!Object subclass: #SharedPool	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Pools'!Application subclass: #Shell	instanceVariableNames: 'bindings '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!IntegerType subclass: #SignedIntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedByte	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedShortInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!Object subclass: #SourceReference	instanceVariableNames: 'sourceStart sourceStop codeStop'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!RelocationInfo subclass: #SpecialSelectorRelocation	instanceVariableNames: 'specialSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!Model subclass: #StringHolder	instanceVariableNames: 'contents'	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Kernel-Remnants'!Object subclass: #SystemTracer	instanceVariableNames: 'byteStream traceQueue oopMap nextChunk nilOop count'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Tracer'!LocalVar subclass: #TempVar	instanceVariableNames: 'isArg'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Error subclass: #TraitException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Kernel'!TraitException subclass: #TraitCompositionException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Composition'!Error subclass: #TypeConvertionError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!FileStream subclass: #UnbufferedFileStream	instanceVariableNames: 'name fileID'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!Smalltalk renameClassNamed: #BufferedFileStream2 as: #BufferedFileStream!UnbufferedFileStream subclass: #BufferedFileStream	instanceVariableNames: ''	classVariableNames: 'DefaultBufferSize'	poolDictionaries: ''	category: 'Files-Kernel'!BufferedFileStream subclass: #BinaryFileStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!BufferedFileStream subclass: #TextFileStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!IntegerType subclass: #UnsignedIntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedByte	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedShortInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SemanticWarning subclass: #UnusedVariableWarning	instanceVariableNames: 'variableNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #VarReference	instanceVariableNames: 'name'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!RelocationInfo subclass: #VariableRelocation	instanceVariableNames: 'variable'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!PluggableGtkSimpleApplication subclass: #Workspace	instanceVariableNames: 'workspaceView'	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!Workspace subclass: #TranscriptCodeEditor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!!Object methodsFor: 'as yet unclassified'!errorSubscriptBounds: index 	"Create an error notification that an improper integer was used as an index."	self error: 'subscript is out of bounds: ' , index printString! !!Object methodsFor: 'as yet unclassified'!executeMethod: compiledMethod withArgs: argArray	"Execute compiledMethod against the receiver and args in argArray"	| selector |	<primitive: 188>	selector _ Symbol new.	self class addSelectorSilently: selector withMethod: compiledMethod.	^ [self perform: selector withArguments: argArray]		ensure: [self class basicRemoveSelector: selector]! !!Object methodsFor: 'as yet unclassified'!withArgs: argArray executeMethod: compiledMethod	"For compatibility with Aqueak"	self executeMethod: compiledMethod withArgs: argArray! !!Application methodsFor: 'as yet unclassified'!arguments	^ arguments.! !!Application methodsFor: 'as yet unclassified'!arguments: anArray	arguments := anArray.! !!Application methodsFor: 'as yet unclassified'!main	self subclassResponsibility.! !!Application methodsFor: 'as yet unclassified'!startUp	Smalltalk startUp.	^ self main.! !!Behavior methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return true if it is safe to zap the method dictionary on #obsolete"	^true! !!Behavior methodsFor: 'as yet unclassified'!isWeak	^ (format bitAnd: 4) = 1.! !!Behavior methodsFor: 'as yet unclassified'!obsolete	"Invalidate and recycle local methods,	e.g., zap the method dictionary if can be done safely."	self canZapMethodDictionary		ifTrue: [self methodDict: self emptyMethodDictionary].! !!Behavior methodsFor: 'as yet unclassified'!removeSelector: selector	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method."	| oldMethod |		oldMethod _ self methodDict at: selector ifAbsent: [^ self].	self methodDict removeKey: selector.	"Now flush Squeak's method cache, either by selector or by method"	oldMethod flushCache.	selector flushCache! !!Behavior methodsFor: 'as yet unclassified'!selectorsAndMethodsDo: aBlock	"Evaluate selectorBlock for all the message selectors in my method dictionary."	^ self methodDict keysAndValuesDo: aBlock! !!Behavior methodsFor: 'as yet unclassified'!setTraitComposition: aTraitComposition	| oldComposition |	(self hasTraitComposition not and: [aTraitComposition isEmpty]) ifTrue: [^self].	aTraitComposition assertValidUser: self.	oldComposition _ self traitComposition.	self traitComposition: aTraitComposition."	self applyChangesOfNewTraitCompositionReplacing: oldComposition."		oldComposition traits do: [:each | each removeUser: self].	aTraitComposition traits do: [:each | each addUser: self]! !!Behavior methodsFor: 'as yet unclassified'!traitCompositionString	^self hasTraitComposition		ifTrue: [self traitComposition asString]		ifFalse: ['{}']! !!Behavior methodsFor: 'as yet unclassified'!typeOfClass	"Answer a symbol uniquely describing the type of the receiver"	self isWeak ifTrue: [ ^ #weak ].	^ (format bitAnd: 3) caseOf: {		[ 0 ] -> [ #normal ].		[ 1 ] -> [ #variable ].		[ 2 ] -> [ #bytes ].		[ 3 ] -> [ #words ]	}! !!Behavior methodsFor: 'as yet unclassified'!whichSelectorsReferTo: literal	"Answer a set of selectors whose methods access the argument as a literal."	| who |	who _ IdentitySet new.	self selectorsAndMethodsDo: 		[:sel :method |		(method hasLiteral: literal)			ifTrue:				[((literal isVariableBinding) not					or: [method literals allButLast includes: literal])						ifTrue: [who add: sel]]].	^ who! !!BehaviorTest methodsFor: 'as yet unclassified'!testBehaviorSubclasses	"self run: #testBehaviorSubclasses"		| b b2 |"	b := Behavior new.	b superclass: OrderedCollection.	b methodDictionary: Dictionary new.	self shouldnt: [b subclasses ] raise: Error.	self shouldnt: [b withAllSubclasses] raise: Error.	self shouldnt: [b allSubclasses] raise: Error.	b2 := Behavior new.	b2 superclass: b.	b2 methodDictionary: Dictionary new.	self assert: (b subclasses includes: b2).	self assert: (b withAllSubclasses includes: b)."! !!BlockClosure methodsFor: 'as yet unclassified'!valueWithArguments: anArray 	"Evaluate the block with given args. Fail if the block expects other than the given number of arguments."	^ environment executeMethod: method withArgs: anArray ! !!ClassBrowser methodsFor: 'as yet unclassified'!buildClassCategoriesView	| model tree col cell |	tree := nil->nil.	SystemOrganization categories do: [ :each |		| category |		category := tree.		(each subStrings: '-') do: [ :cat |			category value ifNil: [ category value: Dictionary new].			category := category value associationAt: cat ifAbsent: [ category value at: cat put: nil. category value associationAt: cat ]		]	].	model := GtkTreeStore new: {String. String}.	[ self addSubcategoriesFrom: tree fromIter: nil inModel: model ] fork.	classCategoriesTree := GtkTreeView model: model.	col := GtkTreeViewColumn title: 'Class categories'.	cell := GtkCellRendererPixbuf new.	col		packStart: cell expand: false;		addAttribute: #stockId column: 1 on: cell.	cell := GtkCellRendererText new.	col		packStart: cell;		addAttribute: #text column: 0 on: cell.		classCategoriesTree appendColumn: col.	classCategoriesTree selection when: #changed send: #onClassCategoryChanged to: self.	classCategoriesTree enableTreeLines: true.	^ GtkScrolledWindow withChild: classCategoriesTree! !!ClassBrowser methodsFor: 'as yet unclassified'!loadClassMethodsOf: aClassClass	| iter |	classMethodsTree model clear.	aClassClass organization categories do: [ :cat |		iter := classMethodsTree model append: nil->{cat asString. true. 'grey'. 'gtk-info'}.		(aClassClass organization listAtCategoryNamed: cat) asSortedCollection do: [ :sel |			classMethodsTree model append: iter->{sel asString. false. 'grey'. 'gtk-execute'}		]	].	classMethodsTree expandAll.! !!ClassBrowser methodsFor: 'as yet unclassified'!loadInstanceMethodsOf: aClass	| iter |	instanceMethodsTree model clear.	aClass organization categories do: [ :cat |		iter := instanceMethodsTree model append: nil->{cat asString. true. 'grey'. 'gtk-info'}.		(aClass organization listAtCategoryNamed: cat) asSortedCollection do: [ :sel |			instanceMethodsTree model append: iter->{sel asString. false. 'grey'. 'gtk-execute'}		]	].	instanceMethodsTree expandAll.! !!ClassBrowser methodsFor: 'as yet unclassified'!onClassHierarchyChanged	| class iter path newIter aCategory classHierarchySelectedRow classesTreeSelectedRow |	classHierarchySelectedRow := classHierarchyTree selectedRow.	classHierarchySelectedRow ifNotNil: [		class := Smalltalk at: (classHierarchySelectedRow first asSymbol).							aCategory := class category.		( aCategory isNotNil and: [ aCategory ~= selectedClassCategory ] ) ifTrue: [			selectedClassCategory := aCategory.			iter := classCategoriesTree model firstIter.			newIter := nil.			(aCategory subStrings: '-') do: [ :cat |				newIter ifNotNil: [ iter := newIter ].				iter := self classCategoryFor: cat firstIter: iter.				newIter := classCategoriesTree model firstChildAt: iter.			].			path := classCategoriesTree model pathFromIter: iter.			classCategoriesTree expandRowsUpTo: path.			classCategoriesTree moveCursorAt: path.					classesTree model clear.			(SystemOrganization listAtCategoryNamed: aCategory) sort do: [ :ea |				classesTree model append: {ea asString. 'gtk-execute'}			]		].							self selectClass: class.	]! !!ClassBuilder methodsFor: 'as yet unclassified'!formatForType: type	^ type caseOf: {		[ #normal ] -> [ 0 ].		[ #variable ] -> [ 1 ].		[ #bytes ] -> [ 2 ].		[ #words ] -> [ 3 ].		[ #weak ] -> [ 5 "binary: 4 + 0 + 0 + 1" ]	} otherwise: [ self error: 'Unknown class type' ].! !!ClassBuilder methodsFor: 'as yet unclassified'!needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Answer whether we need a new subclass to conform to the requested changes"	"Check if we really need a new subclass"	oldClass ifNil:[^true]. "yes, it's a new class"	newSuper == oldClass superclass ifFalse:[^true]. "yes, it's a superclass change"	type = oldClass typeOfClass ifFalse:[^true]. "yes, it's a format change"	instVars = oldClass instVarNames ifFalse:[^true]. "yes, it's an iVar change"	^false! !!ClassBuilder methodsFor: 'as yet unclassified'!newSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Create a new subclass of the given superclass with the given specification."	| newClass |	(oldClass == nil or:[oldClass isMeta not]) 		ifTrue:[newClass := self privateNewSubclassOf: newSuper from: oldClass]		ifFalse:[newClass := oldClass clone].	newClass 		superclass: newSuper		methodDictionary: "Method"Dictionary new		instanceSize: (newSuper instSize + instVars size)		format: (self formatForType: type);		setInstVarNames: instVars.	oldClass ifNotNil:[		newClass organization: oldClass organization.		"Recompile the new class"		oldClass hasMethods 			ifTrue:[newClass compileAllFrom: oldClass].		oldClass hasTraitComposition ifTrue: [			newClass setTraitComposition: oldClass traitComposition copyTraitExpression ].		oldClass class hasTraitComposition ifTrue: [			newClass class setTraitComposition: oldClass class traitComposition copyTraitExpression ].				self recordClass: oldClass replacedBy: newClass.	].	(oldClass == nil or:[oldClass isObsolete not]) 		ifTrue:[newSuper addSubclass: newClass]		ifFalse:[newSuper addObsoleteSubclass: newClass].	^newClass! !!ClassBuilder methodsFor: 'as yet unclassified'!privateNewSubclassOf: newSuper from: oldClass	"Create a new meta and non-meta subclass of newSuper using oldClass as template"	"WARNING: This method does not preserve the superclass/subclass invariant!!"	| newSuperMeta oldMeta newMeta |	oldClass ifNil:[^self privateNewSubclassOf: newSuper].	newSuperMeta _ newSuper ifNil:[Class] ifNotNil:[newSuper class].	oldMeta _ oldClass class.	newMeta _ oldMeta clone.	newMeta 		superclass: newSuperMeta		methodDictionary: "Method"Dictionary new		instanceSize: oldMeta instSize		format: oldMeta format;		setInstVarNames: oldMeta instVarNames;		organization: oldMeta organization.	"Recompile the meta class"	oldMeta hasMethods 		ifTrue:[newMeta compileAllFrom: oldMeta].	"Record the meta class change"	self recordClass: oldMeta replacedBy: newMeta.	"And create a new instance"	^newMeta adoptInstance: oldClass from: oldMeta! !!ClassBuilder methodsFor: 'as yet unclassified'!reshapeClass: oldClass toSuper: newSuper	"Reshape the given class to the new super class. Recompile all the methods in the newly created class. Answer the new class."	| instVars |	instVars _ instVarMap at: oldClass name ifAbsent:[oldClass instVarNames].	^self newSubclassOf: newSuper 			type: oldClass typeOfClass 			instanceVariables: instVars 			from: oldClass! !!ClassDescription methodsFor: 'as yet unclassified'!classVersion	"Default.  Any class may return a later version to inform readers that use ReferenceStream.  8/17/96 tk"	"This method allows you to distinguish between class versions when the shape of the class 	hasn't changed (when there's no change in the instVar names).	In the conversion methods you usually can tell by the inst var names 	what old version you have. In a few cases, though, the same inst var 	names were kept but their interpretation changed (like in the layoutFrame).	By changing the class version when you keep the same instVars you can 	warn older and newer images that they have to convert."	^ 0! !!ClassDescription methodsFor: 'as yet unclassified'!obsolete	"Make the receiver obsolete."	superclass removeSubclass: self.	self organization: nil.	super obsolete.! !!ClassDescription methodsFor: 'as yet unclassified'!removeSelector: selector 	"Remove the message whose selector is given from the method 	dictionary of the receiver, if it is there. Answer nil otherwise."		| priorMethod priorProtocol | 	priorMethod _ self compiledMethodAt: selector ifAbsent: [^ nil].	priorProtocol _ self whichCategoryIncludesSelector: selector.	SystemChangeNotifier uniqueInstance		doSilently: [self organization removeElement: selector ].	super removeSelector: selector.	SystemChangeNotifier uniqueInstance 			methodRemoved: priorMethod selector: selector inProtocol: priorProtocol class: self.! !!ClassDescription methodsFor: 'as yet unclassified'!updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil	| currentCategory effectiveCategory sel changedCategories composition |	changedCategories _ IdentitySet new.	composition := self hasTraitComposition		ifTrue: [self traitComposition]		ifFalse: [TraitComposition new].	(composition methodDescriptionsForSelector: aSymbol) do: [:each |		sel _ each selector.		(self includesLocalSelector: sel) ifFalse: [			currentCategory _ self organization categoryOfElement: sel.			effectiveCategory _ each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.			effectiveCategory isNil ifTrue: [				currentCategory ifNotNil: [changedCategories add: currentCategory].				self organization removeElement: sel.			] ifFalse: [				((currentCategory isNil or: [currentCategory == ClassOrganizer ambiguous or: [currentCategory == oldCategoryOrNil]]) and: [currentCategory ~~ effectiveCategory]) ifTrue: [					currentCategory ifNotNil: [changedCategories add: currentCategory].					self organization 						classify: sel 						under: effectiveCategory						suppressIfDefault: false]]]].	^ changedCategories! !!ClassDescription methodsFor: 'as yet unclassified'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	(self includesSelector: aSelector)		ifTrue: [^ self organization categoryOfElement: aSelector]		ifFalse: [^nil]! !!Class methodsFor: 'as yet unclassified'!classPool: aDictionary	classPool _ aDictionary! !!Class methodsFor: 'as yet unclassified'!copy 	| newClass |	newClass _ self class copy new		superclass: superclass		methodDict: self methodDict copy		instanceSize: self instSize		format: format		name: name		organization: self organization copy		instVarNames: instanceVariables copy		classPool: classPool copy		sharedPools: sharedPools.	Class instSize+1 to: self class instSize do:		[:offset | newClass instVarAt: offset put: (self instVarAt: offset)].	^ newClass! !!Class methodsFor: 'as yet unclassified'!deactivate	"A remnant from the 3.3a modules work, retained . Does nothing, but may be overridden in Metaclasses."! !!Class methodsFor: 'as yet unclassified'!isSystemDefined	"Answer true if the receiver is a system-defined class, and not a UniClass (an instance-specific lightweight class)"	^ self == self officialClass! !!Class methodsFor: 'as yet unclassified'!obsolete	"Change the receiver and all of its subclasses to an obsolete class."	self == Object 		ifTrue: [^self error: 'Object is NOT obsolete'].	self setName: 'AnObsolete' , self name.	Object class instSize + 1 to: self class instSize do:		[:i | self instVarAt: i put: nil]. "Store nil over class instVars."	self classPool: nil.	self sharedPools: nil.	self class obsolete.	super obsolete.! !!Class methodsFor: 'as yet unclassified'!officialClass	"I am not a UniClass.  (See Player officialClass).  Return the class you use to make new subclasses."	^ self! !!Class methodsFor: 'as yet unclassified'!removeFromSystem	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."	self removeFromSystem: true.! !!Class methodsFor: 'as yet unclassified'!removeFromSystem: logged	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."		"keep the class name and category for triggering the system change message. If we wait to long, then we get obsolete information which is not what we want."	"tell class to deactivate and unload itself-- two separate events in the module system"	self deactivate; unload.	self superclass ifNotNil:		["If we have no superclass there's nothing to be remembered"		self superclass addObsoleteSubclass: self].	self environment forgetClass: self logged: logged.	self obsolete.! !!Class methodsFor: 'as yet unclassified'!sharedPools: aCollection	sharedPools _ aCollection! !!Class methodsFor: 'as yet unclassified'!superclass: sup methodDict: md instanceSize: is format: ft name: nm organization: org instVarNames: nilOrArray classPool: pool sharedPools: poolSet 	"Answer an instance of me, a new class, using the arguments of the 	message as the needed information.	Must only be sent to a new instance; else we would need Object flushCache."	superclass := sup.	methodDict := md.	instanceSize := is.	format := ft.	name := nm.	instanceVariables := nilOrArray.	classPool := pool.	sharedPools := poolSet.	self organization: org.! !!Class methodsFor: 'as yet unclassified'!unload	"Sent when a the class is removed.  Does nothing, but may be overridden by (class-side) subclasses."! !!Class methodsFor: 'as yet unclassified'!variableByteSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable byte-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableByteSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!variableSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable pointer variables."	^(ClassBuilder new)		superclass: self		variableSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!variableWordSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable word-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableWordSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!weakSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have weak indexable pointer variables."	^(ClassBuilder new)		superclass: self		weakSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!AppLauncher class methodsFor: 'as yet unclassified'!openAboutHuemul	| dlg logo |	logo := GdkPixbuf fromFile: 'Huemul.jpg'.	dlg := GtkAboutDialog new.	dlg		aboutDialogName: 'Huemul Smalltalk';		version: '0.8';		license: (StandardFileStream readOnlyFileNamed: 'LICENSE') upToEnd;		website: 'http://www.guillermomolina.com.ar/huemul';		comments: 'This is Huemul Smalltalk';		authors: {'Guillermo Adrian Molina'};		logo: logo.	dlg runAndDestroy! !!AppLauncher class methodsFor: 'as yet unclassified'!openWorkspace	^ Workspace open! !!Application class methodsFor: 'as yet unclassified'!startUp	^ self new startUp.! !!Application class methodsFor: 'as yet unclassified'!startUpWithArguments: arguments	| application |	application := self new.	application arguments: arguments.	^ application startUp.! !!Behavior class methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return false since zapping the method dictionary of Behavior class or its subclasses will cause the system to fail."	^false! !!ClassBrowser class methodsFor: 'as yet unclassified'!defaultSize	^ 640@480.! !!ClassBrowser class methodsFor: 'as yet unclassified'!title	^'Class browser'! !!ClassFinder class methodsFor: 'as yet unclassified'!defaultSize	^ 200@300.! !!ClassFinder class methodsFor: 'as yet unclassified'!title	^'Class finder'! !!CompiledMethod methodsFor: 'as yet unclassified'!hasLiteral: literal	"Answer whether the receiver references the argument, literal."	literals ifNil: [ ^false ].	^ literals hasLiteral: literal.! !!CompiledMethod methodsFor: 'as yet unclassified'!sourcePointer	"Answer the integer which can be used to find the source file and position for this method.	Not sources yet"	^ 0! !!CompiledMethodWithNode class methodsFor: 'as yet unclassified'!method: aCompiledMethod node: aMethodNode	^ self new method: aCompiledMethod; node: aMethodNode.! !!Compiler methodsFor: 'as yet unclassified'!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into a method. In other words, if receiver is not nil, then the text can refer to instance variables of that receiver (the Inspector uses this). If aContext is not nil, the text can refer to temporaries in that context (the Debugger uses this). If aRequestor is not nil, then it will receive a notify:at: message before the attempt to evaluate is aborted. Finally, the compiled method is directly invoked without modifying the receiving-class."	"| methodNode method value |	  	(Preferences compileUseNewCompiler or: 			[aContext ifNotNil: [aContext method isClosureCompiled] ifNil: [false]]) ifTrue: 				[^ self evaluate2: textOrStream 					    in: aContext 					    to: receiver 					    notifying: aRequestor 					    ifFail: failBlock 					    logged: logFlag].		class := (aContext isNil 		ifTrue: [ receiver ] 		ifFalse: [ aContext receiver ])			class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode := self 		translate: sourceStream		noPattern: true 		ifFail: [ ^ failBlock value ].	method := methodNode generate.	self interactive		ifTrue: [ method := method copyWithTempNames: methodNode tempNames ].	value := receiver		executeMethod: method 		withArgs: (context isNil			ifTrue: [ #() ]			ifFalse: [ Array with: aContext ]).	logFlag 		ifTrue: [ SystemChangeNotifier uniqueInstance evaluated: sourceStream contents context: aContext ].	^ value."	| string block |	string _ textOrStream readStream upToEnd.	block := self compileDoIt: string in: aContext to: receiver notifying: aRequestor ifFail: [^ failBlock value] log: logFlag.	^ block value! !!Exception methodsFor: 'as yet unclassified'!messageText	messageText ifNil: [ ^ self class name asString ].	^messageText! !!Exception methodsFor: 'as yet unclassified'!receiver	^ self signalerContext receiver! !!ExternalFunctionError methodsFor: 'as yet unclassified'!functionName	"Answer the function name that was beiing used."	^functionName! !!ExternalFunctionError methodsFor: 'as yet unclassified'!functionName: argument	"Specify the function name that was beiing used."	functionName := argument! !!ExternalFunctionError class methodsFor: 'as yet unclassified'!functionName: argument	^self new functionName: argument; yourself! !!ExternalObject methodsFor: 'as yet unclassified'!= anObject 	(anObject isKindOf: self class)		ifTrue: [^ anObject handle = self handle]		ifFalse: [^ false]! !!ExternalObject methodsFor: 'as yet unclassified'!beNull	^ handle beNull.! !!ExternalObject methodsFor: 'as yet unclassified'!finalize		self free.	self unregister.! !!ExternalObject methodsFor: 'as yet unclassified'!free	"Should override this"! !!ExternalObject methodsFor: 'as yet unclassified'!initialize	handle := self class defaultHandlerClass new.	self register.! !!ExternalObject methodsFor: 'as yet unclassified'!isNull	^ self handle isNull.! !!ExternalObject methodsFor: 'as yet unclassified'!register	Registry add: self.! !!ExternalObject methodsFor: 'as yet unclassified'!unregister		Registry remove: self ifAbsent:[  ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!addSymbol: anExternalSymbol	^ symbolCache at: anExternalSymbol name put: anExternalSymbol.! !!DynamicLibrary methodsFor: 'as yet unclassified'!bindSymbol: anExternalSymbol	^ self primitiveBindSymbol: anExternalSymbol.! !!DynamicLibrary methodsFor: 'as yet unclassified'!cDeclFunctionNamed: functionName	^ symbolCache at: functionName ifAbsent: [ self error: 'You must initialize the function before using it' ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!close		handle isNull ifFalse: [ 		self primitiveClose		handle beNull.	].! !!DynamicLibrary methodsFor: 'as yet unclassified'!initialize	super initialize.	symbolCache := Dictionary new.! !!DynamicLibrary methodsFor: 'as yet unclassified'!initializeCDeclFunctionNamed: functionName returnType: retType argTypes: argTypesArray	^ symbolCache at: functionName put: 			(CDeclFunction name: functionName library: self  returnType: retType argTypes: argTypesArray)! !!DynamicLibrary methodsFor: 'as yet unclassified'!initializeLibraryDataNamed: symbolName type: type	^ symbolCache at: symbolName put: (LibraryData name: symbolName library: self  type: type)! !!DynamicLibrary methodsFor: 'as yet unclassified'!libraryDataNamed: symbolName	^ symbolCache at: symbolName ifAbsent: [ self error: 'You must initialize the symbol before using it' ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!name	^name! !!DynamicLibrary methodsFor: 'as yet unclassified'!name: aName	name := aName.! !!DynamicLibrary methodsFor: 'as yet unclassified'!nativeFunctionNamed: functionName	^ symbolCache at: functionName ifAbsent: [ 		symbolCache at: functionName put: (NativeFunction name: functionName library: self)	].! !!DynamicLibrary methodsFor: 'as yet unclassified'!open		handle isNull ifTrue: [ self primitiveOpen ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveBindSymbol: anExternalSymbol	"Primitive. Find the given symbol in the library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 203>	^ anExternalSymbol throwNotKnownError.! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveClose	"Primitive. Close the given library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 202>! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveOpen	"Primitive. Open the given library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 198>	self primitiveFailed.! !!DynamicLibrary methodsFor: 'as yet unclassified'!printOn: aStream	aStream nextPutAll: self name.! !!DynamicLibrary methodsFor: 'as yet unclassified'!symbolNamed: symbolName	^ symbolCache at: symbolName ifAbsent: [ self error: 'You must initialize the symbol before using it' ]! !!Executable methodsFor: 'as yet unclassified'!name	^ Utilities executableName ! !!Executable methodsFor: 'as yet unclassified'!primitiveSmallIntegerAdd: receiver with: argument	^ (self nativeFunctionNamed: #primitiveSmallIntegerAdd) invokeReceiver: receiver with: argument.! !!ExternalBuffer methodsFor: 'as yet unclassified'!asByteArray	| array |	size ifNil: [ ^ self class throwTypeConvertionError ].	array := ByteArray new: self basicSize.	self storeInto: array.	^ array	! !!ExternalBuffer methodsFor: 'as yet unclassified'!atAllPut: constant	^ LibC6 default memSet: self constant: constant count: self size.! !!ExternalBuffer methodsFor: 'as yet unclassified'!atAllPutZero	^ self atAllPut: 0.! !!ExternalBuffer methodsFor: 'as yet unclassified'!basicSize	^ size.! !!ExternalBuffer methodsFor: 'as yet unclassified'!byteAt: index	<primitive: 190>	index isNumber		ifTrue: [self errorSubscriptBounds: index]		ifFalse: [self errorNonIntegerIndex].! !!ExternalBuffer methodsFor: 'as yet unclassified'!byteAt: index put: value	<primitive: 191>	index isNumber		ifTrue: [self errorSubscriptBounds: index]		ifFalse: [self errorNonIntegerIndex].! !!ExternalBuffer methodsFor: 'as yet unclassified'!free		handle isNull ifFalse: [ 		LibC6 default free: self.		self beNull.	]! !!ExternalBuffer methodsFor: 'as yet unclassified'!loadFrom: aByteArray	<primitive: 199>	self primitiveFailed.! !!ExternalBuffer methodsFor: 'as yet unclassified'!size	^ self basicSize.! !!ExternalBuffer methodsFor: 'as yet unclassified'!size: anInteger	size := anInteger.! !!ExternalBuffer methodsFor: 'as yet unclassified'!storeInto: aByteArray	<primitive: 218>	^ self class throwTypeConvertionError.! !!AsciiZ methodsFor: 'as yet unclassified'!asString	^ handle toString.! !!AsciiZ methodsFor: 'as yet unclassified'!asString2	| calcSize string |	size ifNil: [ ^ self class throwTypeConvertionError ].	calcSize := self strlen.	calcSize >= self size ifTrue: [ ^ self class throwTypeConvertionError ].	string := String new: calcSize.	self storeInto: string.	^ string! !!AsciiZ methodsFor: 'as yet unclassified'!loadFrom: aString		super loadFrom: aString.	self byteAt: (aString size + 1) put: 0.! !!AsciiZ methodsFor: 'as yet unclassified'!strlen	^ LibC6 default strLen: self.! !!ExternalFunction methodsFor: 'as yet unclassified'!library	^ library! !!ExternalFunction methodsFor: 'as yet unclassified'!library: aLibrary	library := aLibrary! !!ExternalFunction methodsFor: 'as yet unclassified'!name	^name! !!ExternalFunction methodsFor: 'as yet unclassified'!name: aName	name := aName! !!ExternalFunction methodsFor: 'as yet unclassified'!name: aName library: aLibrary	self name: aName.	self library: aLibrary! !!ExternalFunction methodsFor: 'as yet unclassified'!reload	library ifNil: [ ^ self throwNotKnownError ].	self handle: (library findFunction: self)! !!ExternalLibrary methodsFor: 'as yet unclassified'!bindFunction: function	| answer |	answer := self primitiveBindFunction: function.	answer ifNotNil: [ ^ answer ].	self open. "Library may be closed, open it and retry"	answer := self primitiveBindFunction: answer.	answer ifNotNil: [ ^ answer ].	^ function throwNotKnownError.		! !!ExternalLibrary methodsFor: 'as yet unclassified'!closeLibrary		(handle isNotNil and: [ handle isNull not ]) ifTrue: [ self primitiveClose ].	self handle: nil.	functionCache := nil.! !!ExternalLibrary methodsFor: 'as yet unclassified'!openLibrary		self primitiveOpen.	self initializeFunctionCache.! !!ExternalLibrary methodsFor: 'as yet unclassified'!primitiveBindFunction: function	"Primitive. Find the given symbol in the library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 203>	^ nil.! !!ExternalObject class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: self! !!ExternalObject class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalAddress! !!ExternalObject class methodsFor: 'as yet unclassified'!handleFromObject: anObject	^ self handleFromObject: anObject ifError: [ self throwTypeConvertionError ]! !!ExternalObject class methodsFor: 'as yet unclassified'!handleFromObject: anObject ifError: aBlock		(anObject isKindOf: ExternalObject) ifFalse: [ ^ aBlock value ].	^ anObject handle.	! !!ExternalObject class methodsFor: 'as yet unclassified'!initialize	Registry := WeakRegistry new.	Smalltalk addToShutDownList: self.! !!ExternalObject class methodsFor: 'as yet unclassified'!objectFromHandle: handle	^self objectFromHandle: handle ifError: [ self throwTypeConvertionError ]! !!ExternalObject class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; yourself! !!ExternalObject class methodsFor: 'as yet unclassified'!quit	Registry do: [ :each | each free ].	self allSubclassesDo: [ :ea | ea quit ]! !!ExternalObject class methodsFor: 'as yet unclassified'!shutDown: quitting	quitting ifTrue: [ self quit ].! !!ExternalObject class methodsFor: 'as yet unclassified'!throwTypeConvertionError	^ TypeConvertionError new signal! !!DynamicLibrary class methodsFor: 'as yet unclassified'!default	self = DynamicLibrary ifTrue: [ self error: 'Create a class to create its singleton' ].	default ifNil: [	"Represents the executable itself"		default := self new.		default name: self moduleName.		default open.	].	^ default.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!initialize	self = DynamicLibrary ifFalse: [ 		Smalltalk addToShutDownList: self	].! !!DynamicLibrary class methodsFor: 'as yet unclassified'!moduleName	self subClassResponsibility.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!resetLibrary	default := nil.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!shutDown: aBool	default ifNotNil: [ default close ].! !!Executable class methodsFor: 'as yet unclassified'!huemul	^ self default! !!Executable class methodsFor: 'as yet unclassified'!moduleName	^nil.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: ByteArray! !!ExternalBuffer class methodsFor: 'as yet unclassified'!fromByteArray: aByteArray	| anExternalBuffer |		anExternalBuffer := ExternalBuffer new: aByteArray size.	anExternalBuffer setFrom: aByteArray.	^ anExternalBuffer.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!handleFromObject: aByteArray ifError: aBlock		(aByteArray isKindOf: ByteArray) ifFalse: [ 		^ super handleFromObject: aByteArray ifError: aBlock	].	^ ( self fromByteArray: aByteArray ) handle.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!new: size	| anExternalBuffer |	"This space is allocated from the system not 	from Object Memory, you will have to give it back, 	as it is not garbage collected"	anExternalBuffer := LibC6 default malloc: (size +  10).	anExternalBuffer size: size.	^ anExternalBuffer! !!AsciiZ class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: String! !!AsciiZ class methodsFor: 'as yet unclassified'!fromString: aString	| anAsciiZ |		anAsciiZ := AsciiZ new: aString size + 1.	anAsciiZ loadFrom: aString.	^ anAsciiZ.! !!AsciiZ class methodsFor: 'as yet unclassified'!handleFromObject: aString ifError: aBlock		(aString isKindOf: String) ifFalse: [ 		^ super handleFromObject: aString ifError: aBlock	].	^ ( self fromString: aString ) handle.! !!AsciiZ class methodsFor: 'as yet unclassified'!new: size	| buffer asciiZ |	buffer := super new: size.	asciiZ := AsciiZ new handle: buffer handle.	asciiZ size: size.	asciiZ atAllPutZero.	buffer handle: ExternalAddress nullPointer.	^ asciiZ! !!AsciiZ class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; asString! !!ExternalFunction class methodsFor: 'as yet unclassified'!name: aName library: aLibrary	^self new name: aName library: aLibrary! !!ExternalLibrary class methodsFor: 'as yet unclassified'!huemul	Huemul ifNil: [	"Represents the executable itself"		Huemul := self new.		Huemul open.	].	^ Huemul.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!handle	self object ifNil: [ handle beNull ].	^ handle.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!initialize	super initialize.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!initializePointer	self handle forObject: self object.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!object	^ self objectPointer at: 1! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!object: anObject	self objectPointer at: 1 put: anObject.	self initializePointer.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!objectPointer	object ifNil: [ object := WeakArray new: 1 ].	^ object! !!ExternalArrayProxy methodsFor: 'as yet unclassified'!initializePointer	self handle forArray: self object.! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!fromObject: anObject		^ self new object: anObject; yourself! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!handleFromObject: anObject ifError: aBlock		^ ( self fromObject: anObject ) handle.! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		^ aBlock value! !!ExternalSymbol methodsFor: 'as yet unclassified'!address	handle isNull ifTrue: [ self bind ].	^ handle.! !!ExternalSymbol methodsFor: 'as yet unclassified'!bind	^ library bindSymbol: self.! !!ExternalSymbol methodsFor: 'as yet unclassified'!classFromType: aType	^ Smalltalk at: aType ifAbsent: [ self throwExternalSymbolError ].! !!ExternalSymbol methodsFor: 'as yet unclassified'!library	^ library! !!ExternalSymbol methodsFor: 'as yet unclassified'!library: aLibrary	library := aLibrary! !!ExternalSymbol methodsFor: 'as yet unclassified'!libraryName	^ library name.! !!ExternalSymbol methodsFor: 'as yet unclassified'!name	^name! !!ExternalSymbol methodsFor: 'as yet unclassified'!name: aName	name := aName! !!ExternalSymbol methodsFor: 'as yet unclassified'!name: aName library: aLibrary	self name: aName.	self library: aLibrary! !!ExternalSymbol methodsFor: 'as yet unclassified'!throwExternalSymbolError	^(ExternalSymbolError symbolName: name) signal.! !!ExternalSymbol methodsFor: 'as yet unclassified'!throwNotKnownError	^(ExternalSymbolError symbolName: name) signal.! !!ExecutableFunction methodsFor: 'as yet unclassified'!callingConventionString	self subclassResponsibility.! !!CDeclFunction methodsFor: 'as yet unclassified'!argTypes: anArrayOfTypes	argTypes := anArrayOfTypes.! !!CDeclFunction methodsFor: 'as yet unclassified'!callingConventionString	^ 'cdecl'! !!CDeclFunction methodsFor: 'as yet unclassified'!invoke	^self invokeWithArguments: #()! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1	^self invokeWithArguments: (Array with: arg1)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2	^self invokeWithArguments: (Array with: arg1 with: arg2)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4 with: arg5	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWithArguments: argArray	| argSize argHandleArray returnClass returnHandle |	argSize := argArray size.	argSize = argTypes size ifFalse: [ self throwExternalFunctionError ].	argHandleArray := Array new: argSize.	1 to: argSize do: [ :i |		| argType argClass argHandle arg |		argType := argTypes at: i.		argClass := self classFromType: argType.		arg := argArray at: i.		argHandle := argClass handleFromObject: arg.		argHandleArray at: i put: argHandle.	].	returnHandle := nil.	returnType = #Void ifFalse: [		returnClass := self classFromType: returnType.		returnHandle := returnClass defaultHandlerClass new.	].	handle isNull ifTrue: [ self bind ].	self primInvokeAnswering: returnHandle withArguments: argHandleArray.	returnType = #Void ifTrue: [ ^ nil ].	^ returnClass objectFromHandle: returnHandle.! !!CDeclFunction methodsFor: 'as yet unclassified'!primInvokeAnswering: aReturnValue withArguments: argArray	"Manually invoke the receiver, representing an external function."	<primitive: 204>	^self primitiveFailed! !!CDeclFunction methodsFor: 'as yet unclassified'!returnType: aType	returnType := aType.! !!CDeclFunction methodsFor: 'as yet unclassified'!returnType: aType argTypes: anArrayOfTypes	self returnType: aType.	self argTypes: anArrayOfTypes.! !!ExternalSymbol class methodsFor: 'as yet unclassified'!name: aName library: aLibrary	^self new name: aName library: aLibrary; bind! !!CDeclFunction class methodsFor: 'as yet unclassified'!name: aName library: aLibrary returnType: retType argTypes: argTypesArray	^self new name: aName library: aLibrary;		 returnType: retType argTypes: argTypesArray;		bind! !!ExternalSymbolError methodsFor: 'as yet unclassified'!isResumable	"Determine whether an exception is resumable."	^true! !!ExternalSymbolError methodsFor: 'as yet unclassified'!symbolName	^ symbolName! !!ExternalSymbolError methodsFor: 'as yet unclassified'!symbolName: argument	"Specify the function name that was beiing used."	symbolName := argument! !!ExternalSymbolError class methodsFor: 'as yet unclassified'!symbolName: argument	^self new symbolName: argument; yourself! !!FileDescriptor methodsFor: 'as yet unclassified'!close		self fileDescriptor > 2 ifTrue: [ 		LibC6 default close: self.		self fileDescriptor: -1.	]! !!FileDescriptor methodsFor: 'as yet unclassified'!fileDescriptor	^ SignedInteger objectFromHandle: handle. ! !!FileDescriptor methodsFor: 'as yet unclassified'!fileDescriptor: anInteger	handle := SignedInteger handleFromObject: anInteger. ! !!FileDescriptor methodsFor: 'as yet unclassified'!free		self close.! !!FileDescriptor methodsFor: 'as yet unclassified'!movePosition: offset"relative to actual position"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_CUR' ).	! !!FileDescriptor methodsFor: 'as yet unclassified'!position	^ self movePosition: 0.	! !!FileDescriptor methodsFor: 'as yet unclassified'!position: offset"absolute position"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_SET' ).! !!FileDescriptor methodsFor: 'as yet unclassified'!positionFromEnd: offset"relative to end of file"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_END' ).	! !!FileDescriptor methodsFor: 'as yet unclassified'!read: size	| retValue buffer |	buffer := ExternalBuffer new: size.	retValue := self readBuffer: buffer size: size.	! !!FileDescriptor methodsFor: 'as yet unclassified'!readBuffer: buffer size: size	^ LibC6 default read: self buffer: buffer size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!readString: aString	^ LibC6 default read: self string: aString size: aString size! !!FileDescriptor methodsFor: 'as yet unclassified'!readString: aString size: size	| internalSize |	internalSize := size.	aString size < size ifTrue: [ internalSize := aString size ].	^ LibC6 default read: self string: aString size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!size	| position size |	position := self position.	size := self positionFromEnd: 0.	self position: position.	^ size	! !!FileDescriptor methodsFor: 'as yet unclassified'!writeBuffer: buffer size: size	^ LibC6 default write: self buffer: buffer size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!writeString: aString	^ LibC6 default write: self string: aString size: aString size! !!FileDescriptor methodsFor: 'as yet unclassified'!writeString: aString size: size	| internalSize |	internalSize := size.	aString size < size ifTrue: [ internalSize := aString size ].	^ LibC6 default write: self string: aString size: size! !!FileDescriptor class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalValue! !!FileDescriptor class methodsFor: 'as yet unclassified'!initialize	self initializeStandardDescriptors! !!FileDescriptor class methodsFor: 'as yet unclassified'!initializeStandardDescriptors	StandardDescriptors := Dictionary new.	StandardDescriptors at: #stdout put: (self newFileDescriptor: 0).	StandardDescriptors at: #stdin put: (self newFileDescriptor: 1).	StandardDescriptors at: #stderr put: (self newFileDescriptor: 2).! !!FileDescriptor class methodsFor: 'as yet unclassified'!newFileDescriptor: anInteger	^ self new fileDescriptor: anInteger; yourself.! !!FileDescriptor class methodsFor: 'as yet unclassified'!standardDescriptors	^ StandardDescriptors! !!FileDescriptor class methodsFor: 'as yet unclassified'!stderr	^ StandardDescriptors at: #stderr.! !!FileDescriptor class methodsFor: 'as yet unclassified'!stdin	^ StandardDescriptors at: #stdin.! !!FileDescriptor class methodsFor: 'as yet unclassified'!stdout	^ StandardDescriptors at: #stdout.! !!FileStream methodsFor: 'as yet unclassified'!atEnd	"Answer true if the current position is >= the end of file position.	 1/31/96 sw: subclassResponsibility"	self subclassResponsibility! !!FileStream class methodsFor: 'as yet unclassified'!fileDoesNotExistUserHandling: fullFileName	(GtkMessageDialog question: fullFileName, ' does not exist, create it?') = #yes		ifTrue: [ ^ self new open: fullFileName forWrite: true ].! !!FileStream class methodsFor: 'as yet unclassified'!fileExistsUserHandling: fullFileName	(GtkMessageDialog question: fullFileName, ' exist, overwrite it?') = #yes		ifTrue: [ ^ self new openForOverwrite: fullFileName ].! !!FileStream class methodsFor: 'as yet unclassified'!readOnlyFileDoesNotExistUserHandling: fullFileName	GtkMessageDialog error: fullFileName, ' does not exist'! !!FileDoesNotExistException methodsFor: 'as yet unclassified'!defaultAction	"The default action taken if the exception is signaled."	^self readOnly		ifTrue: [FileStream readOnlyFileDoesNotExistUserHandling: self fileName]		ifFalse: [FileStream fileDoesNotExistUserHandling: self fileName]! !!GIRBuilder methodsFor: 'as yet unclassified'!compiledMethod	| bytecodes |	bytecodes := self bytecodes.	bytecodes ifNil: [ ^ nil ].	^ CompiledMethod new		primitive: 0;		numArgs: self numArgs;		numTemps: self numTemps;		literals: self literals;		relocationInfo: self relocationInfo;		bytecodes: bytecodes;		debugInfo: debugInfo;		source: source;		relocate.! !!GPointer methodsFor: 'as yet unclassified'!initialize	handle := self class defaultHandlerClass new.! !!GPointer class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalAddress! !!GPointer class methodsFor: 'as yet unclassified'!handle: aByteArray	^self basicNew handle: aByteArray; yourself! !!GObject class methodsFor: 'as yet unclassified'!handleFromObject: object	^ object handle.	! !!Gtk methodsFor: 'as yet unclassified'!initialize	self initializeGtkLibrary.	self startMainLoop.! !!Gtk class methodsFor: 'as yet unclassified'!shutDown: quiting	"Quits the Gtk main loop"	Default ifNotNil: [		Default quitMainLoop.		Default close.		Default := nil.	].! !!GtkDemoStockIds methodsFor: 'as yet unclassified'!initialize	| model tree |	model := GtkListStore new: {String. String. String. String}.	GtkStockItem allStocks do: [ :ea |		ea ifNotNil: [			model append: {				ea stockId asGtkStockId.				ea stockId.				ea label.				Gtk acceleratorName: ea keyval asCharacter modifier: ea modifier}]].	tree := GtkTreeView model: model.	self createFirstColumn: tree.	tree appendColumns: {		GtkTreeViewColumn title: 'Label' text: 2.		GtkTreeViewColumn title: 'Accel' text: 3.		GtkTreeViewColumn title: 'ID' text: 0}.	tree selection when: #changed send: #onItemChanged: to: self withArgumentsFirst: {tree}.			self container: (GtkHBox spacing: 5).	self container		packStart: (GtkScrolledWindow withChild: tree);		packEnd: self createInfoFrame expand: false fill: false! !!GtkDemoStockIds methodsFor: 'as yet unclassified'!onItemChanged: aTreeView	aTreeView selectedRow in: [:row |		idLabel label: row first.		nameLabel label: '#', row second.		accelLabel label: row third.		iconImage stock: row second iconSize: #dialog]! !!InMidstOfFileinNotification methodsFor: 'as yet unclassified'!defaultAction	^ self resume: false! !!LibC methodsFor: 'as yet unclassified'!closeLibrary	cLibrary closeLibrary.	cLibrary := nil.! !!LibC methodsFor: 'as yet unclassified'!initializeCLibrary	cLibrary := ExternalLibrary new.	cLibrary name: 'libc.so.6'.	cLibrary openLibrary.! !!LibC class methodsFor: 'as yet unclassified'!shutDown: quiting	"Quits the Gtk main loop"	self default closeLibrary.	Default := nil.! !!LibC6 methodsFor: 'as yet unclassified'!close: fd	| retValue |	retValue := ( self cDeclFunctionNamed: #close ) invokeWith: fd.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #close ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!errno	^ (self libraryDataNamed: #errno) value.	! !!LibC6 methodsFor: 'as yet unclassified'!errno: errno	(self libraryDataNamed: #errno) value: errno.	! !!LibC6 methodsFor: 'as yet unclassified'!free: anExternalBuffer	( self cDeclFunctionNamed: #free ) invokeWith: anExternalBuffer.	! !!LibC6 methodsFor: 'as yet unclassified'!getCurrentDirName	| retValue |	[ retValue := ( self cDeclFunctionNamed: 'get_current_dir_name' asSymbol ) invoke ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: 'get_current_dir_name' asSymbol ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!getEnv: envVariable	^ ( self cDeclFunctionNamed: #getenv ) invokeWith: envVariable.! !!LibC6 methodsFor: 'as yet unclassified'!getpid	^ (self cDeclFunctionNamed: #getpid) invoke.	! !!LibC6 methodsFor: 'as yet unclassified'!initialize	super initialize.	self initializeUniStd.	self initializeStdLib.	self initializeString.	self initializeFCntl.	self initializeStdIO.	self initializeErrNO.! !!LibC6 methodsFor: 'as yet unclassified'!initializeErrNO	self initializeLibraryDataNamed: #errno type: #SignedInteger.! !!LibC6 methodsFor: 'as yet unclassified'!initializeFCntl	self initializeCDeclFunctionNamed: #open returnType: #FileDescriptor argTypes: #( AsciiZ SignedInteger UnsignedInteger ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeStdIO	self initializeCDeclFunctionNamed: #printf  returnType: #SignedInteger argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: #perror  returnType: #Void argTypes: #( AsciiZ  ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeStdLib	self initializeCDeclFunctionNamed: #malloc  returnType: #ExternalBuffer argTypes: #( UnsignedInteger  ).	self initializeCDeclFunctionNamed: #free  returnType: #Void argTypes: #( ExternalBuffer  ).	self initializeCDeclFunctionNamed: #getenv  returnType: #AsciiZ argTypes: #( AsciiZ ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeString	self initializeCDeclFunctionNamed: #strlen returnType: #UnsignedInteger argTypes: #( AsciiZ ).	self initializeCDeclFunctionNamed: #strcat returnType: #AsciiZ argTypes: #( AsciiZ AsciiZ ).	self initializeCDeclFunctionNamed: #strcpy returnType: #AsciiZ argTypes: #( AsciiZ AsciiZ ).	self initializeCDeclFunctionNamed: #strerror returnType: #ReadOnlyAsciiZ argTypes: #( SignedInteger ).	self initializeCDeclFunctionNamed: #memset returnType: #ExternalBuffer argTypes: #( ExternalBuffer SignedInteger  UnsignedInteger ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeUniStd	self initializeCDeclFunctionNamed: #getpid  returnType: #UnsignedInteger argTypes: #().	self initializeCDeclFunctionNamed: 'get_current_dir_name' asSymbol  returnType: #AsciiZ argTypes: #().	self initializeCDeclFunctionNamed: #close  returnType: #SignedInteger argTypes: #( FileDescriptor ).	self initializeCDeclFunctionNamed: #lseek  returnType: #UnsignedInteger argTypes: #( FileDescriptor UnsignedInteger SignedInteger ).	self initializeCDeclFunctionNamed: #read  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalBuffer UnsignedInteger ).	self initializeCDeclFunctionNamed: #write  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalBuffer UnsignedInteger )."Redefinition of read for Strings"	symbolCache at: #readString put: (CDeclFunction name: #read library: self  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalArrayProxy UnsignedInteger ) )."Redefinition of write for Strings"	symbolCache at: #writeString put: (CDeclFunction name: #write library: self  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalArrayProxy UnsignedInteger ) ).! !!LibC6 methodsFor: 'as yet unclassified'!lseek: fileDescriptor offset: offset whence: whence	| returnValue |	returnValue := (self cDeclFunctionNamed: #lseek) invokeWith: fileDescriptor with: offset with: whence.	returnValue < 0 ifTrue: [		self throwErrorForExternalFunctionNamed: #lseek.		^ nil.	].	^ returnValue.	! !!LibC6 methodsFor: 'as yet unclassified'!malloc: size	| retValue |	[ retValue := ( self cDeclFunctionNamed: #malloc ) invokeWith: size ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: #malloc withMessage: 'can not allocate memory' ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!memSet: buffer constant: c count: n	^ (self cDeclFunctionNamed: #memset) invokeWith: buffer with: c with: n.	! !!LibC6 methodsFor: 'as yet unclassified'!open: path flags: flags	^ self open: path flags: flags mode: 8r644	! !!LibC6 methodsFor: 'as yet unclassified'!open: path flags: flags mode: mode	| fileDescriptor |	fileDescriptor := (self cDeclFunctionNamed: #open) invokeWith: path with: flags with: mode.	fileDescriptor fileDescriptor < 0 ifTrue: [		self throwErrorForExternalFunctionNamed: #open.		^ nil.	].	^ fileDescriptor.	! !!LibC6 methodsFor: 'as yet unclassified'!perror: aString	( self cDeclFunctionNamed: #perror ) invokeWith: aString.	! !!LibC6 methodsFor: 'as yet unclassified'!printf: aString	^ ( self cDeclFunctionNamed: #printf ) invokeWith: aString.	! !!LibC6 methodsFor: 'as yet unclassified'!read: fd buffer: buffer size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #read ) invokeWith: fd with: buffer with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #read ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!read: fd string: aString size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #readString ) invokeWith: fd with: aString with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #readString ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!strCat: destString with: sourceString	^ ( self cDeclFunctionNamed: #strcat ) invokeWith: destString with: sourceString.	! !!LibC6 methodsFor: 'as yet unclassified'!strCpy: destString with: sourceString	^ ( self cDeclFunctionNamed: #strcpy ) invokeWith: destString with: sourceString.	! !!LibC6 methodsFor: 'as yet unclassified'!strError: errno	| retValue |	[ retValue := ( self cDeclFunctionNamed: #strerror ) invokeWith: errno ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: #strerror ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!strLen: string	^ ( self cDeclFunctionNamed: #strlen ) invokeWith: string	! !!LibC6 methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName	^ self throwErrorForExternalFunctionNamed: functionName withMessage: (self strError: self errno).	! !!LibC6 methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName withMessage: aString	| error |	error := ExternalFunctionError functionName: functionName.	error messageText: aString.	^ error signal.	! !!LibC6 methodsFor: 'as yet unclassified'!valueForLSeekDirectiveNamed: aString	^ LSeekDirectives at: aString asSymbol.	! !!LibC6 methodsFor: 'as yet unclassified'!valueForOpenFlagNamed: aString	^ OpenFlags at: aString asSymbol.	! !!LibC6 methodsFor: 'as yet unclassified'!write: fd buffer: buffer size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #write ) invokeWith: fd with: buffer with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #write ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!write: fd string: aString size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #writeString ) invokeWith: fd with: aString with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #writeString ].	^ retValue.	! !!LibC6 class methodsFor: 'as yet unclassified'!initialize	self initializeOpenFlags.	self initializeLSeekDirectives.! !!LibC6 class methodsFor: 'as yet unclassified'!initializeLSeekDirectives	| lSeekDirectives |		lSeekDirectives := Dictionary new.	lSeekDirectives at: 'SEEK_SET' put: 0.	lSeekDirectives at: 'SEEK_CUR' put: 1.	lSeekDirectives at: 'SEEK_END' put: 2.	LSeekDirectives := lSeekDirectives! !!LibC6 class methodsFor: 'as yet unclassified'!initializeOpenFlags	| flagArray openFlags |		flagArray := #( 		('O_RDONLY'		0)		('O_WRONLY'		8r1)		('O_RDWR'		8r2)		('O_CREAT'		8r100)			('O_EXCL'			8r200)			('O_NOCTTY'		8r400)			('O_TRUNC'		8r1000)			('O_APPEND'		8r2000)		('O_NONBLOCK'	8r4000)		('O_SYNC'		8r10000)		('O_ASYNC'		8r20000)	).	openFlags := Dictionary new.	flagArray do: [ :i |		openFlags at: i first asSymbol put: i second	].	OpenFlags := openFlags! !!LibC6 class methodsFor: 'as yet unclassified'!moduleName	^ 'libc.so.6'.! !!LibExample methodsFor: 'as yet unclassified'!getpid	^ GETPID invoke! !!LibExample class methodsFor: 'as yet unclassified'!getpid	^ GETPID! !!LibExample class methodsFor: 'as yet unclassified'!initialize	GETPID := CDeclFunction name: 'getpid' libraryNamed: 'libc.so.6' returnType: #UnsignedInteger argTypes: #().! !!LibReadLine methodsFor: 'as yet unclassified'!addHistory: aString	( self cDeclFunctionNamed: 'add_history' asSymbol ) invokeWith: aString.! !!LibReadLine methodsFor: 'as yet unclassified'!initialize	super initialize.	self initializeCDeclFunctionNamed: #readline  returnType: #AsciiZ argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'add_history' asSymbol returnType: #Void argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'read_history' asSymbol returnType: #SignedInteger argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'write_history' asSymbol returnType: #SignedInteger argTypes: #( AsciiZ  ).! !!LibReadLine methodsFor: 'as yet unclassified'!readHistory: aFileName	| errno |	errno := ( self cDeclFunctionNamed: 'read_history' asSymbol ) invokeWith: aFileName.	errno = 0 ifFalse: [ self throwErrorForExternalFunctionNamed: 'read_history' asSymbol errno: errno ].	^ errno.! !!LibReadLine methodsFor: 'as yet unclassified'!readline: prompt	^ ( self cDeclFunctionNamed: #readline ) invokeWith: prompt.! !!LibReadLine methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName errno: errno	| error |	error := ExternalFunctionError functionName: functionName.	error messageText: (LibC6 default strError: errno).	^ error signal.! !!LibReadLine methodsFor: 'as yet unclassified'!writeHistory: aFileName	| errno |	errno := ( self cDeclFunctionNamed: 'write_history' asSymbol ) invokeWith: aFileName.	errno = 0 ifFalse: [ self throwErrorForExternalFunctionNamed: 'write_history' asSymbol errno: errno ].	^ errno.! !!LibReadLine class methodsFor: 'as yet unclassified'!moduleName	^ 'libreadline.so'.! !!LibraryData methodsFor: 'as yet unclassified'!primitiveGetValue: valueHandle	<primitive: 216>	^self primitiveFailed! !!LibraryData methodsFor: 'as yet unclassified'!primitiveSetValue: valueHandle	<primitive: 217>	^self primitiveFailed! !!LibraryData methodsFor: 'as yet unclassified'!type	^ type.! !!LibraryData methodsFor: 'as yet unclassified'!type: aType	type := aType.! !!LibraryData methodsFor: 'as yet unclassified'!value	| valueClass valueHandle |	valueClass := self classFromType: type.	valueHandle := valueClass defaultHandlerClass new.	handle isNull ifTrue: [ self bind ].	self primitiveGetValue: valueHandle.	^ valueClass objectFromHandle: valueHandle.! !!LibraryData methodsFor: 'as yet unclassified'!value: aValue	| argHandle argClass |	argClass := self classFromType: type.	argHandle := argClass handleFromObject: aValue.	handle isNull ifTrue: [ self bind ].	self primitiveSetValue: argHandle! !!LibraryData class methodsFor: 'as yet unclassified'!name: aName library: aLibrary type: type	^self new name: aName library: aLibrary;		type: type;		bind! !!Metaclass methodsFor: 'as yet unclassified'!addObsoleteSubclass: aClass	"Do nothing."! !!Metaclass methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return true if it is safe to zap the method dictionary on #obsolete"	thisClass == nil		ifTrue:[^true]		ifFalse:[^thisClass canZapMethodDictionary]! !!Metaclass methodsFor: 'as yet unclassified'!isSystemDefined	"Answer false if I am a UniClass (an instance-specific lightweight class)"	^ true! !!NativeFunction methodsFor: 'as yet unclassified'!callingConventionString	^ 'native'! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver	^self invokeReceiver: receiver withArguments: #()! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1	^self invokeReceiver: receiver withArguments: (Array with: arg1)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4 with: arg5	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver withArguments: argArray	handle isNull ifTrue: [ self bind ].	^ self primInvokeReceiver: receiver withArguments: argArray.! !!NativeFunction methodsFor: 'as yet unclassified'!primInvokeReceiver: receiver withArguments: argArray	"Manually invoke the receiver, representing an native function."	<primitive: 197>	^self primitiveFailed! !!ObjectTest methodsFor: 'as yet unclassified'!testBecome	"self debug: #testBecome"	"this test should that all the variables pointing to an object are pointing now to another one, and all      object pointing to the other are pointing to the object"	| pt1 pt2 pt3 |	pt1 := 0@0.	pt2 := pt1.	pt3 := 100@100.	pt1 become: pt3.	self assert: pt2 = (100@100).	self assert: pt3 = (0@0).	self assert: pt1 = (100@100).! !!ObjectTest methodsFor: 'as yet unclassified'!testBecomeForward	"self debug: #testBecomeForward"	"this test should that all the variables pointing to an object are pointing now to another one.	Not that this inverse is not true. This kind of become is called oneWayBecome in VW"	| pt1 pt2 pt3 |	pt1 := 0@0.	pt2 := pt1.	pt3 := 100@100.	pt1 becomeForward: pt3.	self assert: pt2 = (100@100).	self assert: pt3 == pt2.	self assert: pt1 = (100@100)! !!PrimitiveType class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalValue! !!PrimitiveType class methodsFor: 'as yet unclassified'!handleFromObject: anObject	^ self handleFromObject: anObject ifError: [ self throwTypeConvertionError ]! !!PrimitiveType class methodsFor: 'as yet unclassified'!handleFromObject: object ifError: aBlock	self subclassResponsibility.! !!PrimitiveType class methodsFor: 'as yet unclassified'!objectFromHandle: handle	^ self objectFromHandle: handle ifError: [  self throwTypeConvertionError ]! !!PrimitiveType class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock	self subclassResponsibility.! !!PrimitiveType class methodsFor: 'as yet unclassified'!throwTypeConvertionError	^ TypeConvertionError new signal! !!IntegerType class methodsFor: 'as yet unclassified'!handleFromObject: anInteger ifError: aBlock	| handle |		(self checkType: anInteger) ifFalse: [ ^ aBlock value ].	handle := ExternalValue new.	self store: anInteger in: handle.	^ handle.	! !!IntegerType class methodsFor: 'as yet unclassified'!isBigEndian	^  false! !!IntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	self subclassResponsibility.! !!IntegerType class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: errorBlock	| value |		value := self loadFrom: handle.	(value > self max ) ifTrue: [ ^ errorBlock value ].	^ value.! !!Process methodsFor: 'as yet unclassified'!primitiveBeInitialProcess	<primitive: 196>	self primitiveFailed! !!ProcessorScheduler methodsFor: 'as yet unclassified'!activeProcess	^ self primActiveProcess! !!ProcessorScheduler methodsFor: 'as yet unclassified'!primActiveProcess	<primitive: 195>	self primitiveFail.! !!ProcessorScheduler methodsFor: 'as yet unclassified'!startUp	| firstProcess |"	(processList isNil or: [ processList isEmpty not ]) ifTrue: [ self initialize ]."	self initialize.	firstProcess := Process new.	firstProcess name: 'Init'.	firstProcess priority: self userSchedulingPriority.	firstProcess state: #running."	firstProcess threadData: self activeThreadData."	firstProcess primitiveBeInitialProcess.! !!ReadOnlyAsciiZ methodsFor: 'as yet unclassified'!asString	^ handle toString.! !!ReadOnlyAsciiZ class methodsFor: 'as yet unclassified'!handleFromObject: aByteArray ifError: aBlock	"Can not be used as arguments"	aBlock value.! !!ReadOnlyAsciiZ class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; asString! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!addressRelativeTo: bytecodes	| functionAddress bytecodesAddress |	functionAddress := self function address asInteger.	bytecodesAddress := (ExternalAddress forArray: bytecodes ) asInteger.	^ functionAddress - bytecodesAddress - offset - 4! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!function	^ self library functionNamed: functionName.! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!functionName	^ functionName! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!functionName: aSymbol	^ functionName := aSymbol! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!library	^ Executable default! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!patch: bytecodes	self patch: bytecodes with: (self addressRelativeTo: bytecodes).! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!patch: bytecodes with: value	bytecodes longAt: (offset + 1) put: value bigEndian: false.! !!FunctionRelocation methodsFor: 'as yet unclassified'!addressRelativeTo: bytecodes	^ self primAddressRelativeTo: bytecodes! !!FunctionRelocation methodsFor: 'as yet unclassified'!primAddressRelativeTo: bytecodes	<primitive: 155>	self primitiveFail.! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!defaultLibraryClass	^ NativeLibrary! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!library 		^ self defaultLibraryClass named: libraryName! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!libraryName	^ libraryName! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!libraryName: aSymbol	^ libraryName := aSymbol! !!ExternalFunctionRelocation methodsFor: 'as yet unclassified'!defaultLibraryClass	^ ExternalLibrary2! !!SequenceableCollection methodsFor: 'as yet unclassified'!asTraitComposition	"For convenience the composition {T1. T2 ...} is the same as T1 + T2 + ..."	^self isEmpty		ifFalse: [			self size = 1				ifTrue: [self first asTraitComposition]				ifFalse: [					self copyWithoutFirst 						inject: self first						into: [:left :right | left + right]]]		ifTrue: [			TraitComposition new]! !!Array methodsFor: 'as yet unclassified'!elementsExchangeIdentityWith: otherArray	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsExchangeIdentityWith: otherArray.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!elementsForwardIdentityTo: otherArray	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsForwardIdentityTo: otherArray.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!elementsForwardIdentityTo: otherArray copyHash: copyHash	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsForwardIdentityTo: otherArray copyHash: copyHash.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!primElementsExchangeIdentityWith: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  At the same time, all pointers to the elements of otherArray are replaced by pointers to the corresponding elements of this array.  The identityHashes remain with the pointers rather than with the objects so that objects in hashed structures should still be properly indexed after the mutation."	<primitive: 128>	otherArray class == Array ifFalse: [^ self error: 'arg must be array'].	self size = otherArray size ifFalse: [^ self error: 'arrays must be same size'].	(self anySatisfy: [:obj | obj class == SmallInteger]) ifTrue: [^ self error: 'can''t become SmallIntegers'].	(otherArray anySatisfy: [:obj | obj class == SmallInteger]) ifTrue: [^ self error: 'can''t become SmallIntegers'].	"Must have failed because not enough space in forwarding table (see ObjectMemory-prepareForwardingTableForBecoming:with:twoWay:).  Do GC and try again only once"	(Smalltalk bytesLeft: true) = Smalltalk primitiveGarbageCollect		ifTrue: [^ self primitiveFailed].	^ self elementsExchangeIdentityWith: otherArray! !!Array methodsFor: 'as yet unclassified'!primElementsForwardIdentityTo: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  The identityHashes remain with the pointers rather than with the objects so that the objects in this array should still be properly indexed in any existing hashed structures after the mutation."	<primitive: 72>	self primitiveFailed! !!Array methodsFor: 'as yet unclassified'!primElementsForwardIdentityTo: otherArray copyHash: copyHash	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  The identityHashes remain with the pointers rather than with the objects so that the objects in this array should still be properly indexed in any existing hashed structures after the mutation."	<primitive: 249>	self primitiveFailed! !!ExternalValue methodsFor: 'as yet unclassified'!beNull	"Make the receiver a NULL pointer"	self atAllPut: 0.! !!ExternalValue methodsFor: 'as yet unclassified'!isNull	^(self basicAt: 1) = 0	and: (self basicAt: 2) = 0	and: (self basicAt: 3) = 0	and: (self basicAt: 4) = 0	! !!ExternalValue class methodsFor: 'as yet unclassified'!initialize	Smalltalk addToStartUpList: self.! !!ExternalValue class methodsFor: 'as yet unclassified'!new	"External addresses are always 4 bytes long"	^super new: 4! !!ExternalValue class methodsFor: 'as yet unclassified'!new: n	"You better don't try this..."	^self shouldNotImplement! !!ExternalValue class methodsFor: 'as yet unclassified'!startUp: resuming	resuming ifTrue: [		self allInstancesDo: [ :addr |			addr beNull		]	].! !!SharedPool class methodsFor: 'as yet unclassified'!bindingOf: varName	"Answer the binding of some variable resolved in the scope of the receiver"	| aSymbol binding |	aSymbol := varName asSymbol.	"First look in classVar dictionary."	binding := self classPool bindingOf: aSymbol.	binding ifNotNil:[^binding].	"Next look in shared pools."	self sharedPools do:[:pool | 		binding := pool bindingOf: aSymbol.		binding ifNotNil:[^binding].	].	"subclassing and environment are not preserved"	^nil! !!SharedPool class methodsFor: 'as yet unclassified'!bindingsDo: aBlock	^self classPool bindingsDo: aBlock! !!SharedPool class methodsFor: 'as yet unclassified'!classBindingOf: varName	"For initialization messages grant the regular scope"	^super bindingOf: varName! !!SharedPool class methodsFor: 'as yet unclassified'!hasBindingThatBeginsWith: aString	"Answer true if the receiver has a binding that begins with aString, false otherwise"	"First look in classVar dictionary."	(self classPool hasBindingThatBeginsWith: aString) ifTrue:[^true].	"Next look in shared pools."	self sharedPools do:[:pool | 		(pool hasBindingThatBeginsWith: aString) ifTrue: [^true]].	^false! !!SharedPool class methodsFor: 'as yet unclassified'!includesKey: aName	"does this pool include aName"	^(self bindingOf: aName) notNil! !!SharedPool class methodsFor: 'as yet unclassified'!keysDo: aBlock"A hopefully temporary fix for an issue arising from miss-spelled variable names in code being compiled. The correction code (see Class>possibleVariablesFor:continuedFrom: assumes that sharedPools are Dictionaries. The proper fix would involve making sure all pools are actually subclasses of SharedPool, which they are not currently."	self bindingsDo:[:b|		aBlock value: b key]! !!Shell methodsFor: 'as yet unclassified'!display: string	| buffer |		buffer := AsciiZ fromString: string.	^ FileDescriptor stdout writeBuffer: buffer size: buffer size.! !!Shell methodsFor: 'as yet unclassified'!input: prompt	^ LibReadLine default readline: prompt! !!Shell methodsFor: 'as yet unclassified'!main	| line value failed anotherLine buffer |	LibReadLine default readHistory: self historyFileName.	[		anotherLine := false.		buffer := ''.		[ 	| prompt |			prompt := anotherLine ifTrue: [ '' ] ifFalse: [ '> ' ].			line _ self input: prompt.			line isEmpty				ifTrue: [ true ] 				ifFalse: [					(line last = $\)						ifTrue: [							anotherLine := true.							line at: line size put: Character lf.						]						ifFalse: [ anotherLine := false ].					buffer := buffer, line.					anotherLine				]		] whileTrue. 		buffer = 'quit' or: [ buffer = 'save' ]	] whileFalse: [		self addToHistory: buffer.		failed _ false.		value _ Compiler new evaluate: buffer in: nil to: nil notifying: self ifFail: [ failed _ true].		failed ifFalse: [ self display: (value printString); lf ]	].	LibReadLine default writeHistory: self historyFileName.	buffer = 'save' ifTrue: [ Smalltalk snapshotAndQuit ].	^value.! !!SignedIntegerType class methodsFor: 'as yet unclassified'!checkType: value	^ value isInteger and: [ value >= self min and: [ value <= self max ] ]! !!SignedIntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	^ handle longAt: 1 bigEndian: self isBigEndian.! !!SignedIntegerType class methodsFor: 'as yet unclassified'!store: anInteger in: handle	handle longAt: 1 put: anInteger bigEndian: self isBigEndian.! !!SignedByte class methodsFor: 'as yet unclassified'!max			^ 127! !!SignedByte class methodsFor: 'as yet unclassified'!min			^ -128! !!SignedInteger class methodsFor: 'as yet unclassified'!max			^ 2147483647! !!SignedInteger class methodsFor: 'as yet unclassified'!min			^ -2147483648! !!SignedShortInteger class methodsFor: 'as yet unclassified'!max			^ 32767! !!SignedShortInteger class methodsFor: 'as yet unclassified'!min			^ -32768! !!SourceReference methodsFor: 'as yet unclassified'!sourceFrom: aString	self hasEmptySourceReference ifTrue: [ ^ '' ].	^ aString copyFrom: sourceStart to: sourceStop! !!StandardFileStream class methodsFor: 'as yet unclassified'!retryWithGC: execBlock until: testBlock forFileNamed: fullName	"Re-implemented to only force GC if a file with the given name exists"	| blockValue foundIt |	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	"See if we have a file with the given name"	foundIt := self registry keys "hold on strongly for now" 		anySatisfy:[:file| file name sameAs: fullName].	foundIt ifFalse:[^blockValue].	Smalltalk garbageCollectMost.	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollect.	^execBlock value.! !!SystemDictionary methodsFor: 'as yet unclassified'!forgetClass: aClass logged: aBool 	"Delete the class, aClass, from the system.	Note that this doesn't do everything required to dispose of a class - to do that use Class>>removeFromSystem."	aBool ifTrue: [SystemChangeNotifier uniqueInstance classRemoved: aClass fromCategory: aClass category].			SystemOrganization removeElement: aClass name.	self removeFromStartUpList: aClass.	self removeFromShutDownList: aClass.	self removeKey: aClass name ifAbsent: [].	self flushClassNameCache! !!SystemDictionary methodsFor: 'as yet unclassified'!removeClassNamed: aName	"Invoked from fileouts:  if there is currently a class in the system named aName, then remove it.  If anything untoward happens, report it in the Transcript.  "	| oldClass |	(oldClass _ self at: aName asSymbol ifAbsent: [nil]) == nil		ifTrue:			[Transcript cr; show: 'Removal of class named ', aName, ' ignored because ', aName, ' does not exist.'.			^ self].	oldClass removeFromSystem! !!SystemDictionary methodsFor: 'as yet unclassified'!startUp	Processor startUp.	ProcessorScheduler startUp.	self processStartUpList: true.	self installLowSpaceWatcher.! !!SystemTracer methodsFor: 'as yet unclassified'!getAligned: size	^ (( size + 3 ) bitShift: -2) bitShift: 2.! !!TraitBehavior methodsFor: 'as yet unclassified'!addUser: aClassOrTrait	users add: aClassOrTrait! !!TraitBehavior methodsFor: 'as yet unclassified'!classesComposedWithMe	^users gather: [:u | u classesComposedWithMe]! !!TraitBehavior methodsFor: 'as yet unclassified'!initialize	self methodDict: Dictionary new.	self traitComposition: nil.	users _ IdentitySet new.! !!TraitBehavior methodsFor: 'as yet unclassified'!removeUser: aClassOrTrait	users remove: aClassOrTrait ifAbsent: []! !!TraitBehavior methodsFor: 'as yet unclassified'!users	^users! !!TraitComposition methodsFor: 'as yet unclassified'!assertValidUser: aBehavior	"Assert that this trait composition set for aBehavior	does not introduce a cycle."		(self allTraits includes: aBehavior) ifTrue: [		TraitCompositionException signal: 'Cycle in compositions:  The composition (in)directly includes this trait!!']! !!TraitComposition methodsFor: 'as yet unclassified'!methodDescriptionsForSelector: aSymbol	"Return a collection of TraitMethodDescriptions for aSymbol and all the 	aliases of aSymbol."	| selectors collection |	selectors _ IdentitySet with: aSymbol.	self transformations do: [:each |		selectors addAll: (each aliasesForSelector: aSymbol)].	collection _ OrderedCollection new: selectors size.	selectors do: [:each |		collection add: (self methodDescriptionForSelector: each)].	^collection! !!TraitDescription methodsFor: 'as yet unclassified'!trait	"for compatibility with TraitTransformations"	^ self! !!TraitDescription methodsFor: 'as yet unclassified'!updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil	| currentCategory effectiveCategory sel changedCategories composition |	changedCategories _ IdentitySet new.	composition := self hasTraitComposition		ifTrue: [self traitComposition]		ifFalse: [TraitComposition new].	(composition methodDescriptionsForSelector: aSymbol) do: [:each |		sel _ each selector.		(self includesLocalSelector: sel) ifFalse: [			currentCategory _ self organization categoryOfElement: sel.			effectiveCategory _ each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.			effectiveCategory isNil ifTrue: [				currentCategory ifNotNil: [changedCategories add: currentCategory].				self organization removeElement: sel.			] ifFalse: [				((currentCategory isNil or: [currentCategory == ClassOrganizer ambiguous or: [currentCategory == oldCategoryOrNil]]) and: [currentCategory ~~ effectiveCategory]) ifTrue: [					currentCategory ifNotNil: [changedCategories add: currentCategory].					self organization 						classify: sel 						under: effectiveCategory						suppressIfDefault: false]]]].	^ changedCategories! !!TraitDescription methodsFor: 'as yet unclassified'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	(self includesSelector: aSelector)		ifTrue: [^ self organization categoryOfElement: aSelector]		ifFalse: [^nil]! !!Trait methodsFor: 'as yet unclassified'!initialize	super initialize.	classTrait _ ClassTrait for: self! !!TranscriptCodeView class methodsFor: 'as yet unclassified'!initialize	Smalltalk addToStartUpList: self.! !!TranscriptCodeView class methodsFor: 'as yet unclassified'!startUp: resuming	resuming ifTrue: [		TranscriptCodeBuffer := nil.	].! !!TranscriptStream methodsFor: 'as yet unclassified'!open	TranscriptCodeEditor open.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!atEnd	position ifNil: [ ^ nil ].	^ position >= readLimit! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!close	"Close this file."	fileID ifNotNil: [		fileID close.		fileID := nil.		position := nil.	].! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!open: fileName flags: flags	[ fileID := LibC6 default open: fileName flags: flags ]		on: ExternalFunctionError		do: [ ^ nil ].	name := fileName.	readLimit := fileID size.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!open: fileName forWrite: writeMode 	| flags |	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	flags := writeMode 		ifTrue: [ LibC6 default valueForOpenFlagNamed: 'O_RDWR' ]		ifFalse: [ LibC6 default valueForOpenFlagNamed: 'O_RDONLY' ].	rwmode := writeMode.	^ self open: fileName flags: flags.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!openForOverwrite: fileName	| flags |	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	flags := ((LibC6 default valueForOpenFlagNamed: 'O_RDWR') 			bitOr: ( LibC6 default valueForOpenFlagNamed: 'O_TRUNC' )) 			bitOr: ( LibC6 default valueForOpenFlagNamed: 'O_CREAT' ).	rwmode := true.	^ self open: fileName flags: flags.! !!BufferedFileStream methodsFor: 'as yet unclassified'!close	"Close this file."	self flush.	^ super close.! !!BufferedFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	self subclassResponsibility! !!BufferedFileStream methodsFor: 'as yet unclassified'!defaultBufferSize	^ DefaultBufferSize.! !!BufferedFileStream methodsFor: 'as yet unclassified'!flush	| bufferPosition bufferSize |	fileID ifNil: [ ^ nil ].	rwmode ifFalse: [ ^ nil ].	bufferPosition := position truncateTo: (collection size).	bufferSize := collection size min: ( readLimit - bufferPosition).	fileID position: bufferPosition.	bufferSize > 0 ifTrue: [ fileID writeString: collection size: bufferSize ].	 ! !!BufferedFileStream methodsFor: 'as yet unclassified'!initializeBuffer	| bufferSize |	position := 0.	collection := self defaultBufferClass new: self defaultBufferSize.	bufferSize := collection size min: readLimit.	bufferSize > 0 ifTrue: [ fileID readString: collection size: bufferSize ]. ! !!BufferedFileStream methodsFor: 'as yet unclassified'!next	| byte |	byte := self peek.	self position: position + 1.	^ byte! !!BufferedFileStream methodsFor: 'as yet unclassified'!nextPut: char	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	position ifNil: [ self position: 0 ].	collection at: (position \\ (collection size)) + 1put: char.	self position: position + 1.	^ char! !!BufferedFileStream methodsFor: 'as yet unclassified'!open: fileName flags: flags	(super open: fileName flags: flags) ifNotNil: [ self initializeBuffer ].! !!BufferedFileStream methodsFor: 'as yet unclassified'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	position ifNil: [ self position: 0 ].	self atEnd ifTrue: [^ nil ].	^ collection at: (position \\ (collection size)) + 1.! !!BufferedFileStream methodsFor: 'as yet unclassified'!position: newPosition	| oldBufferPosition newBufferPosition bufferSize |	fileID ifNil: [ ^nil ].	newPosition < 0 ifTrue: [ ^nil ]."	((newPosition > readLimit) and: [ rwmode not ])  ifTrue: [ ^nil ]."	newPosition > readLimit ifTrue: [		rwmode ifTrue: [ readLimit := newPosition ] ifFalse: [ ^nil ]	].	oldBufferPosition := position truncateTo: (collection size).	newBufferPosition := newPosition truncateTo: (collection size).	newBufferPosition = oldBufferPosition ifFalse: [ 		self flush.		fileID position: newBufferPosition.		bufferSize := collection size min: ( readLimit - newBufferPosition).		collection := self defaultBufferClass new: self defaultBufferSize.		bufferSize > 0 ifTrue: [ fileID readString: collection size: bufferSize ].	].	position := newPosition."	rwmode ifTrue: [ readLimit := newPosition ]."	^ position.! !!BinaryFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	^ ByteArray! !!TextFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	^ String! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!concreteStream	"Who should we really direct class queries to?  "	^ UnbufferedFileStream.! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!fileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new open: fileName forWrite: true! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!forceNewFileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new openForOverwrite: fileName! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!readOnlyFileNamed: fileName 	"Open an existing file with the given name for reading."	| f |	f := self new open: fileName forWrite: false.	^ f isNil		ifFalse: [f]		ifTrue: ["File does not exist..."			((FileDoesNotExistException fileName: fileName) readOnly: true) signal].	"StandardFileStream readOnlyFileNamed: 'kjsd.txt' "! !!BufferedFileStream class methodsFor: 'as yet unclassified'!initialize	self initializeDefaultBufferSize.! !!BufferedFileStream class methodsFor: 'as yet unclassified'!initializeDefaultBufferSize	DefaultBufferSize := 4096.! !!BufferedFileStream class methodsFor: 'as yet unclassified'!new	^ TextFileStream new.! !!UnhandledError methodsFor: 'as yet unclassified'!devDefaultAction	"The current computation is terminated. The cause of the error should be logged or reported to the user. If the program is operating in an interactive debugging environment the computation should be suspended and the debugger activated."	(GtkMessageDialog question: exception messageText, ', debug it?' ) = #yes		ifTrue: [ ^Processor activeProcess debugError: exception ]."	^ Processor activeProcess terminate."! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!checkType: value	^ value isInteger and: [ value >= 0 and: [ value <= self max ] ]! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	^ handle unsignedLongAt: 1 bigEndian: self isBigEndian.! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!min	^ 0! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!store: anInteger in: handle	handle unsignedLongAt: 1 put: anInteger bigEndian: self isBigEndian.! !!UnsignedByte class methodsFor: 'as yet unclassified'!max			^ 255! !!UnsignedInteger class methodsFor: 'as yet unclassified'!max			^ 4294967295! !!UnsignedShortInteger class methodsFor: 'as yet unclassified'!max			^ 65535! !!Workspace methodsFor: 'as yet unclassified'!buildMenuBar	| menu  edit  |	menu := GtkMenuBar new.	edit := GtkMenu new.	menu		append: AppLauncher fileMenu;		append: (edit createMenuItem: '_Edit');		append: workspaceView menu;		append: AppLauncher toolsMenu;		append: AppLauncher helpMenu.					^ menu.! !!Workspace methodsFor: 'as yet unclassified'!buildToolBar	| toolBar |	^ GtkToolbar new		appendItems: workspaceView toolBar;		yourself! !!Workspace methodsFor: 'as yet unclassified'!defaultCodeViewClass	^ WorkspaceView! !!Workspace methodsFor: 'as yet unclassified'!initialize	workspaceView := self defaultCodeViewClass new.	self container: (GtkVBox new		packStart: (self buildMenuBar) expand: false;		packStart: (self buildToolBar) expand: false;		packStart: (workspaceView view);		packStart: (GtkStatusbar new) expand: false	).! !!Workspace methodsFor: 'as yet unclassified'!inspectedVar: anObject	workspaceView inspectedVar: anObject.! !!TranscriptCodeEditor methodsFor: 'as yet unclassified'!defaultCodeViewClass	^ TranscriptCodeView! !!Workspace class methodsFor: 'as yet unclassified'!defaultSize	^ 640@480.! !!Workspace class methodsFor: 'as yet unclassified'!title	^'Workspace'! !!TranscriptCodeEditor class methodsFor: 'as yet unclassified'!title	^'Transcript'! !BufferedFileStream initialize!TranscriptCodeView initialize!TraitBehavior removeSelector: #initializeUsers!Application subclass: #Shell	instanceVariableNames: 'bindings'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!ExternalValue initialize!NativeFunctionRelocation removeSelector: #addressRelativeTo:!NativeFunctionRelocation removeSelector: #function!NativeFunctionRelocation removeSelector: #functionName!NativeFunctionRelocation removeSelector: #functionName:!NativeFunctionRelocation removeSelector: #patch:!NativeFunctionRelocation removeSelector: #patch:with:!ReadOnlyAsciiZ class removeSelector: #objectFromHandle:!ProcessorScheduler removeSelector: #activeProcess2!ProcessorScheduler removeSelector: #activeThreadData!ProcessorScheduler removeSelector: #primActiveThreadData!Process removeSelector: #threadData:!PrimitiveType class removeSelector: #defaultHandlerType!PrimitiveType class removeSelector: #instantiateHandler!NativeFunction removeSelector: #address!NativeFunction removeSelector: #bind!NativeFunction removeSelector: #invoke!NativeFunction removeSelector: #invokeAnswering:!NativeFunction removeSelector: #invokeAnswering:with:!NativeFunction removeSelector: #invokeAnswering:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:withArguments:!NativeFunction removeSelector: #invokeWith:!NativeFunction removeSelector: #invokeWith:with:!NativeFunction removeSelector: #invokeWith:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:with:with:!NativeFunction removeSelector: #invokeWithArguments:!NativeFunction removeSelector: #name!NativeFunction removeSelector: #name:!NativeFunction removeSelector: #throwNotKnownError!LibraryData removeSelector: #primitiveGetValue!LibExample initialize!LibC6 initialize!LibC6 removeSelector: #initializeUnistd!LibC6 removeSelector: #openPath:flags:!LibC6 removeSelector: #write2:buffer:size:!LibC removeSelector: #close!GPointer class removeSelector: #instantiateHandler!FileStream removeSelector: #position!FileDescriptor initialize!FileDescriptor removeSelector: #movePositionTo:!FileDescriptor removeSelector: #name!FileDescriptor removeSelector: #name:!FileDescriptor removeSelector: #positionFromEns:!FileDescriptor removeSelector: #setPositionAt:!FileDescriptor removeSelector: #setPositionFromEndAt:!CDeclFunction class removeSelector: #name:libraryNamed:returnType:argTypes:!ExecutableFunction class removeSelector: #name:library:!ExecutableFunction class removeSelector: #name:libraryNamed:!CDeclFunction removeSelector: #classFromType:!CDeclFunction removeSelector: #throwExternalFunctionError!ExecutableFunction removeSelector: #address!ExecutableFunction removeSelector: #bind!ExecutableFunction removeSelector: #invoke!ExecutableFunction removeSelector: #invokeWith:!ExecutableFunction removeSelector: #invokeWith:with:!ExecutableFunction removeSelector: #invokeWith:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithArguments:!ExecutableFunction removeSelector: #invokeWithReceiver:!ExecutableFunction removeSelector: #invokeWithReceiver:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:withArguments:!ExecutableFunction removeSelector: #library!ExecutableFunction removeSelector: #library:!ExecutableFunction removeSelector: #libraryName!ExecutableFunction removeSelector: #libraryNamed:!ExecutableFunction removeSelector: #name!ExecutableFunction removeSelector: #name:!ExecutableFunction removeSelector: #name:library:!ExecutableFunction removeSelector: #name:libraryNamed:!ExecutableFunction removeSelector: #primInvokeReceiver:withArguments:!ExecutableFunction removeSelector: #primInvokeWithArguments:!ExecutableFunction removeSelector: #primInvokeWithReceiver:withArguments:!ExecutableFunction removeSelector: #throwNotKnownError!ExternalSymbol removeSelector: #callingConventionString!ExternalObjectProxy removeSelector: #register!ExternalObjectProxy removeSelector: #unregister!AsciiZ class removeSelector: #objectFromHandle:!Executable class removeSelector: #huenul!DynamicLibrary class removeSelector: #addLibrary:named:!DynamicLibrary class removeSelector: #huemul!DynamicLibrary initialize!DynamicLibrary class removeSelector: #name:!DynamicLibrary class removeSelector: #named:!ExternalObject class removeSelector: #handle:!ExternalObject initialize!ExternalObject class removeSelector: #registry!ExternalObject class removeSelector: #registry:!AsciiZ removeSelector: #setFrom:!ExternalBuffer removeSelector: #finalize!ExternalBuffer removeSelector: #selfCheck!ExternalBuffer removeSelector: #setFrom:!ExternalBuffer removeSelector: #storeInto:size:!Executable removeSelector: #initialize!Executable removeSelector: #instantiateFunctionClass:!Executable removeSelector: #name:!Executable removeSelector: #nativeFunctionNamed:!Executable removeSelector: #primitiveOpen!DynamicLibrary removeSelector: #addExternal:!DynamicLibrary removeSelector: #basicName!DynamicLibrary removeSelector: #bind:!DynamicLibrary removeSelector: #bindFunction:!DynamicLibrary removeSelector: #cDeclFunctionNamed:returnType:argTypes:!DynamicLibrary removeSelector: #primitiveBind:!DynamicLibrary removeSelector: #primitiveBindFunction:!ExternalObject removeSelector: #isNullPointer!Object subclass: #ExternalObject	instanceVariableNames: 'handle'	classVariableNames: 'Registry'	poolDictionaries: ''	category: 'FFI-Types'!ExternalFunctionError class removeSelector: #function:!ExternalFunctionError removeSelector: #function!ExternalFunctionError removeSelector: #function:!ExternalFunctionError removeSelector: #isResumable!Error subclass: #ExternalFunctionError	instanceVariableNames: 'functionName'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!Application class removeSelector: #start!Application class removeSelector: #startWithArguments:!Class removeSelector: #superclass:methodDict:format:name:organization:instVarNames:classPool:sharedPools:!ClassBuilder removeSelector: #computeFormat:instSize:forSuper:ccIndex:!ClassBuilder removeSelector: #format:variable:words:pointers:weak:!Smalltalk removeClassNamed: #SystemChangeNotifierTest!RBProgramNodeVisitor subclass: #ASTChecker	instanceVariableNames: 'scope varsChangedInSend'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!RBProgramNodeVisitor subclass: #ASTTranslator	instanceVariableNames: 'methodBuilder receiverForCascade'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #Application	instanceVariableNames: 'arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!AssembleInstruction subclass: #AssembleCMov	instanceVariableNames: ''	classVariableNames: 'Condition'	poolDictionaries: ''	category: 'Exupery'!Object subclass: #AssemblerExupery	instanceVariableNames: 'stream blockAddresses jumpOffsets bytecodes instructionEncoders plugin relocator picEntries debugCollector source'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #BlockClosure	instanceVariableNames: 'method environment'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Contexts'!PluggableGtkSimpleApplication subclass: #ClassFinder	instanceVariableNames: 'classTrait'	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!Object subclass: #ColouringRegisterAllocator	instanceVariableNames: 'source result machine interferenceGraph registerStack registerFile registerTable spiltRegisters hasSpilt coloursUsed simplifyWorklist spillWorklist moveWorklist coalescedMoves isValidating deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #DebugInfo	instanceVariableNames: 'codeSourceReferences argVarsReferences tempVarsReferences capturedVarsReferences'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!Object subclass: #EventManager	instanceVariableNames: 'actionMap'	classVariableNames: 'ActionMaps'	poolDictionaries: ''	category: 'System-Object'!Error subclass: #ExternalFunctionError	instanceVariableNames: 'functionName '	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!Object subclass: #ExternalObject	instanceVariableNames: 'handle '	classVariableNames: 'Registry '	poolDictionaries: ''	category: 'FFI-Types'!ExternalObject subclass: #DynamicLibrary	instanceVariableNames: 'name symbolCache'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!DynamicLibrary subclass: #Executable	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!ExternalObject subclass: #ExternalBuffer	instanceVariableNames: 'size'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalBuffer subclass: #AsciiZ	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!DynamicLibrary class	instanceVariableNames: 'default'!ExternalObject subclass: #ExternalObjectProxy	instanceVariableNames: 'object'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalObjectProxy subclass: #ExternalArrayProxy	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalObject subclass: #ExternalSymbol	instanceVariableNames: 'name library'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!ExternalSymbol subclass: #ExecutableFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!ExecutableFunction subclass: #CDeclFunction	instanceVariableNames: 'returnType argTypes'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Error subclass: #ExternalSymbolError	instanceVariableNames: 'symbolName'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!ExternalObject subclass: #FileDescriptor	instanceVariableNames: ''	classVariableNames: 'StandardDescriptors'	poolDictionaries: ''	category: 'FFI-Types'!Error subclass: #FileStreamException	instanceVariableNames: 'fileName'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #CannotDeleteFileException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #FileDoesNotExistException	instanceVariableNames: 'readOnly'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #FileExistsException	instanceVariableNames: 'fileClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!AssemblyCopier subclass: #FinalCopier	instanceVariableNames: 'deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!LexicalScope subclass: #FunctionScope	instanceVariableNames: 'thisContextVar thisEnvVar tempVars capturedVars isHome hasInnerFreeVars hideTemps argVars uninitializedTemps capturedParentEnv'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #GIRBuilder	instanceVariableNames: 'ir currentBlock machine relocationInfo primitiveNode literals thisEnvVar cacheMap literalTemp source start stop debugInfo'	classVariableNames: 'InlinedSelectors SpecialConstants SpecialSelectors'	poolDictionaries: ''	category: 'Compiler-IR'!LexicalScope subclass: #InstanceScope	instanceVariableNames: 'vars'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!DynamicLibrary subclass: #LibC6	instanceVariableNames: ''	classVariableNames: 'LSeekDirectives OpenFlags'	poolDictionaries: ''	category: 'FFI-Libraries'!Object subclass: #LibExample	instanceVariableNames: ''	classVariableNames: 'GETPID'	poolDictionaries: ''	category: 'Guille-Test'!DynamicLibrary subclass: #LibReadLine	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!ExternalSymbol subclass: #LibraryData	instanceVariableNames: 'type'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Object subclass: #LivenessAnalyser	instanceVariableNames: 'source hasUpdated isValidating deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #MedLanguage	instanceVariableNames: 'in out start stop'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedCMov	instanceVariableNames: 'type from to'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedEnter	instanceVariableNames: 'argument'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedLeave	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedLiteral	instanceVariableNames: 'literal'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLiteral subclass: #MedFunction	instanceVariableNames: 'block byteCodeAddress'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!ExecutableFunction subclass: #NativeFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Object subclass: #PrimitiveType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!PrimitiveType subclass: #IntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!RBProgramNode subclass: #RBReturnNode	instanceVariableNames: 'return value homeBinding frameBinding'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Nodes'!ExternalObject subclass: #ReadOnlyAsciiZ	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SemanticWarning subclass: #RedeclaredVariableWarning	instanceVariableNames: 'variableNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #RelocationInfo	instanceVariableNames: 'offset'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #ExecutableFunctionRelocation	instanceVariableNames: 'functionName'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #FunctionRelocation	instanceVariableNames: 'function'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #LiteralRelocation	instanceVariableNames: 'literals'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!ExecutableFunctionRelocation subclass: #NativeFunctionRelocation	instanceVariableNames: 'libraryName'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!NativeFunctionRelocation subclass: #ExternalFunctionRelocation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #PrimitiveRelocation	instanceVariableNames: 'number'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!Object subclass: #ScopeVar	instanceVariableNames: 'scope usage'	classVariableNames: 'UsageAutomaton'	poolDictionaries: ''	category: 'Compiler-Semantics'!ScopeVar subclass: #GlobalVar	instanceVariableNames: 'assoc'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!ScopeVar subclass: #LocalVar	instanceVariableNames: 'name index'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!LocalVar subclass: #ArgVar	instanceVariableNames: 'isArg'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!LocalVar subclass: #CapturedVar	instanceVariableNames: 'sourceTemp'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!ByteArray variableByteSubclass: #ExternalValue	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!Object subclass: #SharedPool	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Pools'!Application subclass: #Shell	instanceVariableNames: 'bindings '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!IntegerType subclass: #SignedIntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedByte	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedShortInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!Object subclass: #SourceReference	instanceVariableNames: 'sourceStart sourceStop codeStop'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!RelocationInfo subclass: #SpecialSelectorRelocation	instanceVariableNames: 'specialSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!Model subclass: #StringHolder	instanceVariableNames: 'contents'	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Kernel-Remnants'!Object subclass: #SystemTracer	instanceVariableNames: 'byteStream traceQueue oopMap nextChunk nilOop count'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Tracer'!LocalVar subclass: #TempVar	instanceVariableNames: 'isArg'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Error subclass: #TraitException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Kernel'!TraitException subclass: #TraitCompositionException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Composition'!Error subclass: #TypeConvertionError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!FileStream subclass: #UnbufferedFileStream	instanceVariableNames: 'name fileID'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!Smalltalk renameClassNamed: #BufferedFileStream2 as: #BufferedFileStream!UnbufferedFileStream subclass: #BufferedFileStream	instanceVariableNames: ''	classVariableNames: 'DefaultBufferSize'	poolDictionaries: ''	category: 'Files-Kernel'!BufferedFileStream subclass: #BinaryFileStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!BufferedFileStream subclass: #TextFileStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!IntegerType subclass: #UnsignedIntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedByte	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedShortInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SemanticWarning subclass: #UnusedVariableWarning	instanceVariableNames: 'variableNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #VarReference	instanceVariableNames: 'name'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!RelocationInfo subclass: #VariableRelocation	instanceVariableNames: 'variable'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!PluggableGtkSimpleApplication subclass: #Workspace	instanceVariableNames: 'workspaceView'	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!Workspace subclass: #TranscriptCodeEditor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!!Object methodsFor: 'as yet unclassified'!errorSubscriptBounds: index 	"Create an error notification that an improper integer was used as an index."	self error: 'subscript is out of bounds: ' , index printString! !!Object methodsFor: 'as yet unclassified'!executeMethod: compiledMethod withArgs: argArray	"Execute compiledMethod against the receiver and args in argArray"	| selector |	<primitive: 188>	selector _ Symbol new.	self class addSelectorSilently: selector withMethod: compiledMethod.	^ [self perform: selector withArguments: argArray]		ensure: [self class basicRemoveSelector: selector]! !!Object methodsFor: 'as yet unclassified'!withArgs: argArray executeMethod: compiledMethod	"For compatibility with Aqueak"	self executeMethod: compiledMethod withArgs: argArray! !!Application methodsFor: 'as yet unclassified'!arguments	^ arguments.! !!Application methodsFor: 'as yet unclassified'!arguments: anArray	arguments := anArray.! !!Application methodsFor: 'as yet unclassified'!main	self subclassResponsibility.! !!Application methodsFor: 'as yet unclassified'!startUp	Smalltalk startUp.	^ self main.! !!Behavior methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return true if it is safe to zap the method dictionary on #obsolete"	^true! !!Behavior methodsFor: 'as yet unclassified'!isWeak	^ (format bitAnd: 4) = 1.! !!Behavior methodsFor: 'as yet unclassified'!obsolete	"Invalidate and recycle local methods,	e.g., zap the method dictionary if can be done safely."	self canZapMethodDictionary		ifTrue: [self methodDict: self emptyMethodDictionary].! !!Behavior methodsFor: 'as yet unclassified'!removeSelector: selector	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method."	| oldMethod |		oldMethod _ self methodDict at: selector ifAbsent: [^ self].	self methodDict removeKey: selector.	"Now flush Squeak's method cache, either by selector or by method"	oldMethod flushCache.	selector flushCache! !!Behavior methodsFor: 'as yet unclassified'!selectorsAndMethodsDo: aBlock	"Evaluate selectorBlock for all the message selectors in my method dictionary."	^ self methodDict keysAndValuesDo: aBlock! !!Behavior methodsFor: 'as yet unclassified'!setTraitComposition: aTraitComposition	| oldComposition |	(self hasTraitComposition not and: [aTraitComposition isEmpty]) ifTrue: [^self].	aTraitComposition assertValidUser: self.	oldComposition _ self traitComposition.	self traitComposition: aTraitComposition."	self applyChangesOfNewTraitCompositionReplacing: oldComposition."		oldComposition traits do: [:each | each removeUser: self].	aTraitComposition traits do: [:each | each addUser: self]! !!Behavior methodsFor: 'as yet unclassified'!traitCompositionString	^self hasTraitComposition		ifTrue: [self traitComposition asString]		ifFalse: ['{}']! !!Behavior methodsFor: 'as yet unclassified'!typeOfClass	"Answer a symbol uniquely describing the type of the receiver"	self isWeak ifTrue: [ ^ #weak ].	^ (format bitAnd: 3) caseOf: {		[ 0 ] -> [ #normal ].		[ 1 ] -> [ #variable ].		[ 2 ] -> [ #bytes ].		[ 3 ] -> [ #words ]	}! !!Behavior methodsFor: 'as yet unclassified'!whichSelectorsReferTo: literal	"Answer a set of selectors whose methods access the argument as a literal."	| who |	who _ IdentitySet new.	self selectorsAndMethodsDo: 		[:sel :method |		(method hasLiteral: literal)			ifTrue:				[((literal isVariableBinding) not					or: [method literals allButLast includes: literal])						ifTrue: [who add: sel]]].	^ who! !!BehaviorTest methodsFor: 'as yet unclassified'!testBehaviorSubclasses	"self run: #testBehaviorSubclasses"		| b b2 |"	b := Behavior new.	b superclass: OrderedCollection.	b methodDictionary: Dictionary new.	self shouldnt: [b subclasses ] raise: Error.	self shouldnt: [b withAllSubclasses] raise: Error.	self shouldnt: [b allSubclasses] raise: Error.	b2 := Behavior new.	b2 superclass: b.	b2 methodDictionary: Dictionary new.	self assert: (b subclasses includes: b2).	self assert: (b withAllSubclasses includes: b)."! !!BlockClosure methodsFor: 'as yet unclassified'!valueWithArguments: anArray 	"Evaluate the block with given args. Fail if the block expects other than the given number of arguments."	^ environment executeMethod: method withArgs: anArray ! !!ClassBrowser methodsFor: 'as yet unclassified'!buildClassCategoriesView	| model tree col cell |	tree := nil->nil.	SystemOrganization categories do: [ :each |		| category |		category := tree.		(each subStrings: '-') do: [ :cat |			category value ifNil: [ category value: Dictionary new].			category := category value associationAt: cat ifAbsent: [ category value at: cat put: nil. category value associationAt: cat ]		]	].	model := GtkTreeStore new: {String. String}.	[ self addSubcategoriesFrom: tree fromIter: nil inModel: model ] fork.	classCategoriesTree := GtkTreeView model: model.	col := GtkTreeViewColumn title: 'Class categories'.	cell := GtkCellRendererPixbuf new.	col		packStart: cell expand: false;		addAttribute: #stockId column: 1 on: cell.	cell := GtkCellRendererText new.	col		packStart: cell;		addAttribute: #text column: 0 on: cell.		classCategoriesTree appendColumn: col.	classCategoriesTree selection when: #changed send: #onClassCategoryChanged to: self.	classCategoriesTree enableTreeLines: true.	^ GtkScrolledWindow withChild: classCategoriesTree! !!ClassBrowser methodsFor: 'as yet unclassified'!loadClassMethodsOf: aClassClass	| iter |	classMethodsTree model clear.	aClassClass organization categories do: [ :cat |		iter := classMethodsTree model append: nil->{cat asString. true. 'grey'. 'gtk-info'}.		(aClassClass organization listAtCategoryNamed: cat) asSortedCollection do: [ :sel |			classMethodsTree model append: iter->{sel asString. false. 'grey'. 'gtk-execute'}		]	].	classMethodsTree expandAll.! !!ClassBrowser methodsFor: 'as yet unclassified'!loadInstanceMethodsOf: aClass	| iter |	instanceMethodsTree model clear.	aClass organization categories do: [ :cat |		iter := instanceMethodsTree model append: nil->{cat asString. true. 'grey'. 'gtk-info'}.		(aClass organization listAtCategoryNamed: cat) asSortedCollection do: [ :sel |			instanceMethodsTree model append: iter->{sel asString. false. 'grey'. 'gtk-execute'}		]	].	instanceMethodsTree expandAll.! !!ClassBrowser methodsFor: 'as yet unclassified'!onClassHierarchyChanged	| class iter path newIter aCategory classHierarchySelectedRow classesTreeSelectedRow |	classHierarchySelectedRow := classHierarchyTree selectedRow.	classHierarchySelectedRow ifNotNil: [		class := Smalltalk at: (classHierarchySelectedRow first asSymbol).							aCategory := class category.		( aCategory isNotNil and: [ aCategory ~= selectedClassCategory ] ) ifTrue: [			selectedClassCategory := aCategory.			iter := classCategoriesTree model firstIter.			newIter := nil.			(aCategory subStrings: '-') do: [ :cat |				newIter ifNotNil: [ iter := newIter ].				iter := self classCategoryFor: cat firstIter: iter.				newIter := classCategoriesTree model firstChildAt: iter.			].			path := classCategoriesTree model pathFromIter: iter.			classCategoriesTree expandRowsUpTo: path.			classCategoriesTree moveCursorAt: path.					classesTree model clear.			(SystemOrganization listAtCategoryNamed: aCategory) sort do: [ :ea |				classesTree model append: {ea asString. 'gtk-execute'}			]		].							self selectClass: class.	]! !!ClassBuilder methodsFor: 'as yet unclassified'!formatForType: type	^ type caseOf: {		[ #normal ] -> [ 0 ].		[ #variable ] -> [ 1 ].		[ #bytes ] -> [ 2 ].		[ #words ] -> [ 3 ].		[ #weak ] -> [ 5 "binary: 4 + 0 + 0 + 1" ]	} otherwise: [ self error: 'Unknown class type' ].! !!ClassBuilder methodsFor: 'as yet unclassified'!needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Answer whether we need a new subclass to conform to the requested changes"	"Check if we really need a new subclass"	oldClass ifNil:[^true]. "yes, it's a new class"	newSuper == oldClass superclass ifFalse:[^true]. "yes, it's a superclass change"	type = oldClass typeOfClass ifFalse:[^true]. "yes, it's a format change"	instVars = oldClass instVarNames ifFalse:[^true]. "yes, it's an iVar change"	^false! !!ClassBuilder methodsFor: 'as yet unclassified'!newSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Create a new subclass of the given superclass with the given specification."	| newClass |	(oldClass == nil or:[oldClass isMeta not]) 		ifTrue:[newClass := self privateNewSubclassOf: newSuper from: oldClass]		ifFalse:[newClass := oldClass clone].	newClass 		superclass: newSuper		methodDictionary: "Method"Dictionary new		instanceSize: (newSuper instSize + instVars size)		format: (self formatForType: type);		setInstVarNames: instVars.	oldClass ifNotNil:[		newClass organization: oldClass organization.		"Recompile the new class"		oldClass hasMethods 			ifTrue:[newClass compileAllFrom: oldClass].		oldClass hasTraitComposition ifTrue: [			newClass setTraitComposition: oldClass traitComposition copyTraitExpression ].		oldClass class hasTraitComposition ifTrue: [			newClass class setTraitComposition: oldClass class traitComposition copyTraitExpression ].				self recordClass: oldClass replacedBy: newClass.	].	(oldClass == nil or:[oldClass isObsolete not]) 		ifTrue:[newSuper addSubclass: newClass]		ifFalse:[newSuper addObsoleteSubclass: newClass].	^newClass! !!ClassBuilder methodsFor: 'as yet unclassified'!privateNewSubclassOf: newSuper from: oldClass	"Create a new meta and non-meta subclass of newSuper using oldClass as template"	"WARNING: This method does not preserve the superclass/subclass invariant!!"	| newSuperMeta oldMeta newMeta |	oldClass ifNil:[^self privateNewSubclassOf: newSuper].	newSuperMeta _ newSuper ifNil:[Class] ifNotNil:[newSuper class].	oldMeta _ oldClass class.	newMeta _ oldMeta clone.	newMeta 		superclass: newSuperMeta		methodDictionary: "Method"Dictionary new		instanceSize: oldMeta instSize		format: oldMeta format;		setInstVarNames: oldMeta instVarNames;		organization: oldMeta organization.	"Recompile the meta class"	oldMeta hasMethods 		ifTrue:[newMeta compileAllFrom: oldMeta].	"Record the meta class change"	self recordClass: oldMeta replacedBy: newMeta.	"And create a new instance"	^newMeta adoptInstance: oldClass from: oldMeta! !!ClassBuilder methodsFor: 'as yet unclassified'!reshapeClass: oldClass toSuper: newSuper	"Reshape the given class to the new super class. Recompile all the methods in the newly created class. Answer the new class."	| instVars |	instVars _ instVarMap at: oldClass name ifAbsent:[oldClass instVarNames].	^self newSubclassOf: newSuper 			type: oldClass typeOfClass 			instanceVariables: instVars 			from: oldClass! !!ClassDescription methodsFor: 'as yet unclassified'!classVersion	"Default.  Any class may return a later version to inform readers that use ReferenceStream.  8/17/96 tk"	"This method allows you to distinguish between class versions when the shape of the class 	hasn't changed (when there's no change in the instVar names).	In the conversion methods you usually can tell by the inst var names 	what old version you have. In a few cases, though, the same inst var 	names were kept but their interpretation changed (like in the layoutFrame).	By changing the class version when you keep the same instVars you can 	warn older and newer images that they have to convert."	^ 0! !!ClassDescription methodsFor: 'as yet unclassified'!obsolete	"Make the receiver obsolete."	superclass removeSubclass: self.	self organization: nil.	super obsolete.! !!ClassDescription methodsFor: 'as yet unclassified'!removeSelector: selector 	"Remove the message whose selector is given from the method 	dictionary of the receiver, if it is there. Answer nil otherwise."		| priorMethod priorProtocol | 	priorMethod _ self compiledMethodAt: selector ifAbsent: [^ nil].	priorProtocol _ self whichCategoryIncludesSelector: selector.	SystemChangeNotifier uniqueInstance		doSilently: [self organization removeElement: selector ].	super removeSelector: selector.	SystemChangeNotifier uniqueInstance 			methodRemoved: priorMethod selector: selector inProtocol: priorProtocol class: self.! !!ClassDescription methodsFor: 'as yet unclassified'!updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil	| currentCategory effectiveCategory sel changedCategories composition |	changedCategories _ IdentitySet new.	composition := self hasTraitComposition		ifTrue: [self traitComposition]		ifFalse: [TraitComposition new].	(composition methodDescriptionsForSelector: aSymbol) do: [:each |		sel _ each selector.		(self includesLocalSelector: sel) ifFalse: [			currentCategory _ self organization categoryOfElement: sel.			effectiveCategory _ each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.			effectiveCategory isNil ifTrue: [				currentCategory ifNotNil: [changedCategories add: currentCategory].				self organization removeElement: sel.			] ifFalse: [				((currentCategory isNil or: [currentCategory == ClassOrganizer ambiguous or: [currentCategory == oldCategoryOrNil]]) and: [currentCategory ~~ effectiveCategory]) ifTrue: [					currentCategory ifNotNil: [changedCategories add: currentCategory].					self organization 						classify: sel 						under: effectiveCategory						suppressIfDefault: false]]]].	^ changedCategories! !!ClassDescription methodsFor: 'as yet unclassified'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	(self includesSelector: aSelector)		ifTrue: [^ self organization categoryOfElement: aSelector]		ifFalse: [^nil]! !!Class methodsFor: 'as yet unclassified'!classPool: aDictionary	classPool _ aDictionary! !!Class methodsFor: 'as yet unclassified'!copy 	| newClass |	newClass _ self class copy new		superclass: superclass		methodDict: self methodDict copy		instanceSize: self instSize		format: format		name: name		organization: self organization copy		instVarNames: instanceVariables copy		classPool: classPool copy		sharedPools: sharedPools.	Class instSize+1 to: self class instSize do:		[:offset | newClass instVarAt: offset put: (self instVarAt: offset)].	^ newClass! !!Class methodsFor: 'as yet unclassified'!deactivate	"A remnant from the 3.3a modules work, retained . Does nothing, but may be overridden in Metaclasses."! !!Class methodsFor: 'as yet unclassified'!isSystemDefined	"Answer true if the receiver is a system-defined class, and not a UniClass (an instance-specific lightweight class)"	^ self == self officialClass! !!Class methodsFor: 'as yet unclassified'!obsolete	"Change the receiver and all of its subclasses to an obsolete class."	self == Object 		ifTrue: [^self error: 'Object is NOT obsolete'].	self setName: 'AnObsolete' , self name.	Object class instSize + 1 to: self class instSize do:		[:i | self instVarAt: i put: nil]. "Store nil over class instVars."	self classPool: nil.	self sharedPools: nil.	self class obsolete.	super obsolete.! !!Class methodsFor: 'as yet unclassified'!officialClass	"I am not a UniClass.  (See Player officialClass).  Return the class you use to make new subclasses."	^ self! !!Class methodsFor: 'as yet unclassified'!removeFromSystem	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."	self removeFromSystem: true.! !!Class methodsFor: 'as yet unclassified'!removeFromSystem: logged	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."		"keep the class name and category for triggering the system change message. If we wait to long, then we get obsolete information which is not what we want."	"tell class to deactivate and unload itself-- two separate events in the module system"	self deactivate; unload.	self superclass ifNotNil:		["If we have no superclass there's nothing to be remembered"		self superclass addObsoleteSubclass: self].	self environment forgetClass: self logged: logged.	self obsolete.! !!Class methodsFor: 'as yet unclassified'!sharedPools: aCollection	sharedPools _ aCollection! !!Class methodsFor: 'as yet unclassified'!superclass: sup methodDict: md instanceSize: is format: ft name: nm organization: org instVarNames: nilOrArray classPool: pool sharedPools: poolSet 	"Answer an instance of me, a new class, using the arguments of the 	message as the needed information.	Must only be sent to a new instance; else we would need Object flushCache."	superclass := sup.	methodDict := md.	instanceSize := is.	format := ft.	name := nm.	instanceVariables := nilOrArray.	classPool := pool.	sharedPools := poolSet.	self organization: org.! !!Class methodsFor: 'as yet unclassified'!unload	"Sent when a the class is removed.  Does nothing, but may be overridden by (class-side) subclasses."! !!Class methodsFor: 'as yet unclassified'!variableByteSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable byte-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableByteSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!variableSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable pointer variables."	^(ClassBuilder new)		superclass: self		variableSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!variableWordSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable word-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableWordSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!weakSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have weak indexable pointer variables."	^(ClassBuilder new)		superclass: self		weakSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!AppLauncher class methodsFor: 'as yet unclassified'!openAboutHuemul	| dlg logo |	logo := GdkPixbuf fromFile: 'Huemul.jpg'.	dlg := GtkAboutDialog new.	dlg		aboutDialogName: 'Huemul Smalltalk';		version: '0.8';		license: (StandardFileStream readOnlyFileNamed: 'LICENSE') upToEnd;		website: 'http://www.guillermomolina.com.ar/huemul';		comments: 'This is Huemul Smalltalk';		authors: {'Guillermo Adrian Molina'};		logo: logo.	dlg runAndDestroy! !!AppLauncher class methodsFor: 'as yet unclassified'!openWorkspace	^ Workspace open! !!Application class methodsFor: 'as yet unclassified'!startUp	^ self new startUp.! !!Application class methodsFor: 'as yet unclassified'!startUpWithArguments: arguments	| application |	application := self new.	application arguments: arguments.	^ application startUp.! !!Behavior class methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return false since zapping the method dictionary of Behavior class or its subclasses will cause the system to fail."	^false! !!ClassBrowser class methodsFor: 'as yet unclassified'!defaultSize	^ 640@480.! !!ClassBrowser class methodsFor: 'as yet unclassified'!title	^'Class browser'! !!ClassFinder class methodsFor: 'as yet unclassified'!defaultSize	^ 200@300.! !!ClassFinder class methodsFor: 'as yet unclassified'!title	^'Class finder'! !!CompiledMethod methodsFor: 'as yet unclassified'!hasLiteral: literal	"Answer whether the receiver references the argument, literal."	literals ifNil: [ ^false ].	^ literals hasLiteral: literal.! !!CompiledMethod methodsFor: 'as yet unclassified'!sourcePointer	"Answer the integer which can be used to find the source file and position for this method.	Not sources yet"	^ 0! !!CompiledMethodWithNode class methodsFor: 'as yet unclassified'!method: aCompiledMethod node: aMethodNode	^ self new method: aCompiledMethod; node: aMethodNode.! !!Compiler methodsFor: 'as yet unclassified'!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into a method. In other words, if receiver is not nil, then the text can refer to instance variables of that receiver (the Inspector uses this). If aContext is not nil, the text can refer to temporaries in that context (the Debugger uses this). If aRequestor is not nil, then it will receive a notify:at: message before the attempt to evaluate is aborted. Finally, the compiled method is directly invoked without modifying the receiving-class."	"| methodNode method value |	  	(Preferences compileUseNewCompiler or: 			[aContext ifNotNil: [aContext method isClosureCompiled] ifNil: [false]]) ifTrue: 				[^ self evaluate2: textOrStream 					    in: aContext 					    to: receiver 					    notifying: aRequestor 					    ifFail: failBlock 					    logged: logFlag].		class := (aContext isNil 		ifTrue: [ receiver ] 		ifFalse: [ aContext receiver ])			class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode := self 		translate: sourceStream		noPattern: true 		ifFail: [ ^ failBlock value ].	method := methodNode generate.	self interactive		ifTrue: [ method := method copyWithTempNames: methodNode tempNames ].	value := receiver		executeMethod: method 		withArgs: (context isNil			ifTrue: [ #() ]			ifFalse: [ Array with: aContext ]).	logFlag 		ifTrue: [ SystemChangeNotifier uniqueInstance evaluated: sourceStream contents context: aContext ].	^ value."	| string block |	string _ textOrStream readStream upToEnd.	block := self compileDoIt: string in: aContext to: receiver notifying: aRequestor ifFail: [^ failBlock value] log: logFlag.	^ block value! !!Exception methodsFor: 'as yet unclassified'!messageText	messageText ifNil: [ ^ self class name asString ].	^messageText! !!Exception methodsFor: 'as yet unclassified'!receiver	^ self signalerContext receiver! !!ExternalFunctionError methodsFor: 'as yet unclassified'!functionName	"Answer the function name that was beiing used."	^functionName! !!ExternalFunctionError methodsFor: 'as yet unclassified'!functionName: argument	"Specify the function name that was beiing used."	functionName := argument! !!ExternalFunctionError class methodsFor: 'as yet unclassified'!functionName: argument	^self new functionName: argument; yourself! !!ExternalObject methodsFor: 'as yet unclassified'!= anObject 	(anObject isKindOf: self class)		ifTrue: [^ anObject handle = self handle]		ifFalse: [^ false]! !!ExternalObject methodsFor: 'as yet unclassified'!beNull	^ handle beNull.! !!ExternalObject methodsFor: 'as yet unclassified'!finalize		self free.	self unregister.! !!ExternalObject methodsFor: 'as yet unclassified'!free	"Should override this"! !!ExternalObject methodsFor: 'as yet unclassified'!initialize	handle := self class defaultHandlerClass new.	self register.! !!ExternalObject methodsFor: 'as yet unclassified'!isNull	^ self handle isNull.! !!ExternalObject methodsFor: 'as yet unclassified'!register	Registry add: self.! !!ExternalObject methodsFor: 'as yet unclassified'!unregister		Registry remove: self ifAbsent:[  ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!addSymbol: anExternalSymbol	^ symbolCache at: anExternalSymbol name put: anExternalSymbol.! !!DynamicLibrary methodsFor: 'as yet unclassified'!bindSymbol: anExternalSymbol	self open.	^ self primitiveBindSymbol: anExternalSymbol.! !!DynamicLibrary methodsFor: 'as yet unclassified'!cDeclFunctionNamed: functionName	^ symbolCache at: functionName ifAbsent: [ self error: 'You must initialize the function before using it' ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!close		handle isNull ifFalse: [ 		self primitiveClose		handle beNull.	].! !!DynamicLibrary methodsFor: 'as yet unclassified'!initialize	super initialize.	symbolCache := Dictionary new.! !!DynamicLibrary methodsFor: 'as yet unclassified'!initializeCDeclFunctionNamed: functionName returnType: retType argTypes: argTypesArray	^ symbolCache at: functionName put: 			(CDeclFunction name: functionName library: self  returnType: retType argTypes: argTypesArray)! !!DynamicLibrary methodsFor: 'as yet unclassified'!initializeLibraryDataNamed: symbolName type: type	^ symbolCache at: symbolName put: (LibraryData name: symbolName library: self  type: type)! !!DynamicLibrary methodsFor: 'as yet unclassified'!libraryDataNamed: symbolName	^ symbolCache at: symbolName ifAbsent: [ self error: 'You must initialize the symbol before using it' ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!name	^name! !!DynamicLibrary methodsFor: 'as yet unclassified'!name: aName	name := aName.! !!DynamicLibrary methodsFor: 'as yet unclassified'!nativeFunctionNamed: functionName	^ symbolCache at: functionName ifAbsent: [ 		symbolCache at: functionName put: (NativeFunction name: functionName library: self)	].! !!DynamicLibrary methodsFor: 'as yet unclassified'!open		handle isNull ifTrue: [ self primitiveOpen ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveBindSymbol: anExternalSymbol	"Primitive. Find the given symbol in the library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 203>	^ anExternalSymbol throwNotKnownError.! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveClose	"Primitive. Close the given library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 202>! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveOpen	"Primitive. Open the given library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 198>	self primitiveFailed.! !!DynamicLibrary methodsFor: 'as yet unclassified'!printOn: aStream	aStream nextPutAll: self name.! !!DynamicLibrary methodsFor: 'as yet unclassified'!symbolNamed: symbolName	^ symbolCache at: symbolName ifAbsent: [ self error: 'You must initialize the symbol before using it' ]! !!Executable methodsFor: 'as yet unclassified'!name	^ Utilities executableName ! !!Executable methodsFor: 'as yet unclassified'!primitiveSmallIntegerAdd: receiver with: argument	^ (self nativeFunctionNamed: #primitiveSmallIntegerAdd) invokeReceiver: receiver with: argument.! !!ExternalBuffer methodsFor: 'as yet unclassified'!asByteArray	| array |	size ifNil: [ ^ self class throwTypeConvertionError ].	array := ByteArray new: self basicSize.	self storeInto: array.	^ array	! !!ExternalBuffer methodsFor: 'as yet unclassified'!atAllPut: constant	^ LibC6 default memSet: self constant: constant count: self size.! !!ExternalBuffer methodsFor: 'as yet unclassified'!atAllPutZero	^ self atAllPut: 0.! !!ExternalBuffer methodsFor: 'as yet unclassified'!basicSize	^ size.! !!ExternalBuffer methodsFor: 'as yet unclassified'!byteAt: index	<primitive: 190>	index isNumber		ifTrue: [self errorSubscriptBounds: index]		ifFalse: [self errorNonIntegerIndex].! !!ExternalBuffer methodsFor: 'as yet unclassified'!byteAt: index put: value	<primitive: 191>	index isNumber		ifTrue: [self errorSubscriptBounds: index]		ifFalse: [self errorNonIntegerIndex].! !!ExternalBuffer methodsFor: 'as yet unclassified'!free		handle isNull ifFalse: [ 		LibC6 default free: self.		self beNull.	]! !!ExternalBuffer methodsFor: 'as yet unclassified'!loadFrom: aByteArray	<primitive: 199>	self primitiveFailed.! !!ExternalBuffer methodsFor: 'as yet unclassified'!size	^ self basicSize.! !!ExternalBuffer methodsFor: 'as yet unclassified'!size: anInteger	size := anInteger.! !!ExternalBuffer methodsFor: 'as yet unclassified'!storeInto: aByteArray	<primitive: 218>	^ self class throwTypeConvertionError.! !!AsciiZ methodsFor: 'as yet unclassified'!asString	^ handle toString.! !!AsciiZ methodsFor: 'as yet unclassified'!asString2	| calcSize string |	size ifNil: [ ^ self class throwTypeConvertionError ].	calcSize := self strlen.	calcSize >= self size ifTrue: [ ^ self class throwTypeConvertionError ].	string := String new: calcSize.	self storeInto: string.	^ string! !!AsciiZ methodsFor: 'as yet unclassified'!loadFrom: aString		super loadFrom: aString.	self byteAt: (aString size + 1) put: 0.! !!AsciiZ methodsFor: 'as yet unclassified'!strlen	^ LibC6 default strLen: self.! !!ExternalFunction methodsFor: 'as yet unclassified'!library	^ library! !!ExternalFunction methodsFor: 'as yet unclassified'!library: aLibrary	library := aLibrary! !!ExternalFunction methodsFor: 'as yet unclassified'!name	^name! !!ExternalFunction methodsFor: 'as yet unclassified'!name: aName	name := aName! !!ExternalFunction methodsFor: 'as yet unclassified'!name: aName library: aLibrary	self name: aName.	self library: aLibrary! !!ExternalFunction methodsFor: 'as yet unclassified'!reload	library ifNil: [ ^ self throwNotKnownError ].	self handle: (library findFunction: self)! !!ExternalLibrary methodsFor: 'as yet unclassified'!bindFunction: function	| answer |	answer := self primitiveBindFunction: function.	answer ifNotNil: [ ^ answer ].	self open. "Library may be closed, open it and retry"	answer := self primitiveBindFunction: answer.	answer ifNotNil: [ ^ answer ].	^ function throwNotKnownError.		! !!ExternalLibrary methodsFor: 'as yet unclassified'!closeLibrary		(handle isNotNil and: [ handle isNull not ]) ifTrue: [ self primitiveClose ].	self handle: nil.	functionCache := nil.! !!ExternalLibrary methodsFor: 'as yet unclassified'!openLibrary		self primitiveOpen.	self initializeFunctionCache.! !!ExternalLibrary methodsFor: 'as yet unclassified'!primitiveBindFunction: function	"Primitive. Find the given symbol in the library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 203>	^ nil.! !!ExternalObject class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: self! !!ExternalObject class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalAddress! !!ExternalObject class methodsFor: 'as yet unclassified'!handleFromObject: anObject	^ self handleFromObject: anObject ifError: [ self throwTypeConvertionError ]! !!ExternalObject class methodsFor: 'as yet unclassified'!handleFromObject: anObject ifError: aBlock		(anObject isKindOf: ExternalObject) ifFalse: [ ^ aBlock value ].	^ anObject handle.	! !!ExternalObject class methodsFor: 'as yet unclassified'!initialize	Registry := WeakRegistry new.	Smalltalk addToShutDownList: self.! !!ExternalObject class methodsFor: 'as yet unclassified'!objectFromHandle: handle	^self objectFromHandle: handle ifError: [ self throwTypeConvertionError ]! !!ExternalObject class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; yourself! !!ExternalObject class methodsFor: 'as yet unclassified'!quit	Registry do: [ :each | each free ].	self allSubclassesDo: [ :ea | ea quit ]! !!ExternalObject class methodsFor: 'as yet unclassified'!shutDown: quitting	quitting ifTrue: [ self quit ].! !!ExternalObject class methodsFor: 'as yet unclassified'!throwTypeConvertionError	^ TypeConvertionError new signal! !!DynamicLibrary class methodsFor: 'as yet unclassified'!default	self = DynamicLibrary ifTrue: [ self error: 'Create a class to create its singleton' ].	default ifNil: [	"Represents the executable itself"		default := self new.		default name: self moduleName.		default open.	].	^ default.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!initialize	self = DynamicLibrary ifFalse: [ 		Smalltalk addToShutDownList: self	].! !!DynamicLibrary class methodsFor: 'as yet unclassified'!moduleName	self subClassResponsibility.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!resetLibrary	default := nil.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!shutDown: aBool	default ifNotNil: [ default close ].! !!Executable class methodsFor: 'as yet unclassified'!huemul	^ self default! !!Executable class methodsFor: 'as yet unclassified'!moduleName	^nil.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: ByteArray! !!ExternalBuffer class methodsFor: 'as yet unclassified'!fromByteArray: aByteArray	| anExternalBuffer |		anExternalBuffer := ExternalBuffer new: aByteArray size.	anExternalBuffer setFrom: aByteArray.	^ anExternalBuffer.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!handleFromObject: aByteArray ifError: aBlock		(aByteArray isKindOf: ByteArray) ifFalse: [ 		^ super handleFromObject: aByteArray ifError: aBlock	].	^ ( self fromByteArray: aByteArray ) handle.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!new: size	| anExternalBuffer |	"This space is allocated from the system not 	from Object Memory, you will have to give it back, 	as it is not garbage collected"	anExternalBuffer := LibC6 default malloc: (size +  10).	anExternalBuffer size: size.	^ anExternalBuffer! !!AsciiZ class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: String! !!AsciiZ class methodsFor: 'as yet unclassified'!fromString: aString	| anAsciiZ |		anAsciiZ := AsciiZ new: aString size + 1.	anAsciiZ loadFrom: aString.	^ anAsciiZ.! !!AsciiZ class methodsFor: 'as yet unclassified'!handleFromObject: aString ifError: aBlock		(aString isKindOf: String) ifFalse: [ 		^ super handleFromObject: aString ifError: aBlock	].	^ ( self fromString: aString ) handle.! !!AsciiZ class methodsFor: 'as yet unclassified'!new: size	| buffer asciiZ |	buffer := super new: size.	asciiZ := AsciiZ new handle: buffer handle.	asciiZ size: size.	asciiZ atAllPutZero.	buffer handle: ExternalAddress nullPointer.	^ asciiZ! !!AsciiZ class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; asString! !!ExternalFunction class methodsFor: 'as yet unclassified'!name: aName library: aLibrary	^self new name: aName library: aLibrary! !!ExternalLibrary class methodsFor: 'as yet unclassified'!huemul	Huemul ifNil: [	"Represents the executable itself"		Huemul := self new.		Huemul open.	].	^ Huemul.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!handle	self object ifNil: [ handle beNull ].	^ handle.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!initialize	super initialize.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!initializePointer	self handle forObject: self object.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!object	^ self objectPointer at: 1! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!object: anObject	self objectPointer at: 1 put: anObject.	self initializePointer.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!objectPointer	object ifNil: [ object := WeakArray new: 1 ].	^ object! !!ExternalArrayProxy methodsFor: 'as yet unclassified'!initializePointer	self handle forArray: self object.! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!fromObject: anObject		^ self new object: anObject; yourself! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!handleFromObject: anObject ifError: aBlock		^ ( self fromObject: anObject ) handle.! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		^ aBlock value! !!ExternalSymbol methodsFor: 'as yet unclassified'!address	handle isNull ifTrue: [ self bind ].	^ handle.! !!ExternalSymbol methodsFor: 'as yet unclassified'!bind	^ library bindSymbol: self.! !!ExternalSymbol methodsFor: 'as yet unclassified'!classFromType: aType	^ Smalltalk at: aType ifAbsent: [ self throwExternalSymbolError ].! !!ExternalSymbol methodsFor: 'as yet unclassified'!library	^ library! !!ExternalSymbol methodsFor: 'as yet unclassified'!library: aLibrary	library := aLibrary! !!ExternalSymbol methodsFor: 'as yet unclassified'!libraryName	^ library name.! !!ExternalSymbol methodsFor: 'as yet unclassified'!name	^name! !!ExternalSymbol methodsFor: 'as yet unclassified'!name: aName	name := aName! !!ExternalSymbol methodsFor: 'as yet unclassified'!name: aName library: aLibrary	self name: aName.	self library: aLibrary! !!ExternalSymbol methodsFor: 'as yet unclassified'!throwExternalSymbolError	^(ExternalSymbolError symbolName: name) signal.! !!ExternalSymbol methodsFor: 'as yet unclassified'!throwNotKnownError	^(ExternalSymbolError symbolName: name) signal.! !!ExecutableFunction methodsFor: 'as yet unclassified'!callingConventionString	self subclassResponsibility.! !!CDeclFunction methodsFor: 'as yet unclassified'!argTypes: anArrayOfTypes	argTypes := anArrayOfTypes.! !!CDeclFunction methodsFor: 'as yet unclassified'!callingConventionString	^ 'cdecl'! !!CDeclFunction methodsFor: 'as yet unclassified'!invoke	^self invokeWithArguments: #()! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1	^self invokeWithArguments: (Array with: arg1)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2	^self invokeWithArguments: (Array with: arg1 with: arg2)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4 with: arg5	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWithArguments: argArray	| argSize argHandleArray returnClass returnHandle |	argSize := argArray size.	argSize = argTypes size ifFalse: [ self throwExternalFunctionError ].	argHandleArray := Array new: argSize.	1 to: argSize do: [ :i |		| argType argClass argHandle arg |		argType := argTypes at: i.		argClass := self classFromType: argType.		arg := argArray at: i.		argHandle := argClass handleFromObject: arg.		argHandleArray at: i put: argHandle.	].	returnHandle := nil.	returnType = #Void ifFalse: [		returnClass := self classFromType: returnType.		returnHandle := returnClass defaultHandlerClass new.	].	handle isNull ifTrue: [ self bind ].	self primInvokeAnswering: returnHandle withArguments: argHandleArray.	returnType = #Void ifTrue: [ ^ nil ].	^ returnClass objectFromHandle: returnHandle.! !!CDeclFunction methodsFor: 'as yet unclassified'!primInvokeAnswering: aReturnValue withArguments: argArray	"Manually invoke the receiver, representing an external function."	<primitive: 204>	^self primitiveFailed! !!CDeclFunction methodsFor: 'as yet unclassified'!returnType: aType	returnType := aType.! !!CDeclFunction methodsFor: 'as yet unclassified'!returnType: aType argTypes: anArrayOfTypes	self returnType: aType.	self argTypes: anArrayOfTypes.! !!ExternalSymbol class methodsFor: 'as yet unclassified'!name: aName library: aLibrary	^self new name: aName library: aLibrary; bind! !!CDeclFunction class methodsFor: 'as yet unclassified'!name: aName library: aLibrary returnType: retType argTypes: argTypesArray	^self new name: aName library: aLibrary;		 returnType: retType argTypes: argTypesArray;		bind! !!ExternalSymbolError methodsFor: 'as yet unclassified'!isResumable	"Determine whether an exception is resumable."	^true! !!ExternalSymbolError methodsFor: 'as yet unclassified'!symbolName	^ symbolName! !!ExternalSymbolError methodsFor: 'as yet unclassified'!symbolName: argument	"Specify the function name that was beiing used."	symbolName := argument! !!ExternalSymbolError class methodsFor: 'as yet unclassified'!symbolName: argument	^self new symbolName: argument; yourself! !!FileDescriptor methodsFor: 'as yet unclassified'!close		self fileDescriptor > 2 ifTrue: [ 		LibC6 default close: self.		self fileDescriptor: -1.	]! !!FileDescriptor methodsFor: 'as yet unclassified'!fileDescriptor	^ SignedInteger objectFromHandle: handle. ! !!FileDescriptor methodsFor: 'as yet unclassified'!fileDescriptor: anInteger	handle := SignedInteger handleFromObject: anInteger. ! !!FileDescriptor methodsFor: 'as yet unclassified'!free		self close.! !!FileDescriptor methodsFor: 'as yet unclassified'!movePosition: offset"relative to actual position"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_CUR' ).	! !!FileDescriptor methodsFor: 'as yet unclassified'!position	^ self movePosition: 0.	! !!FileDescriptor methodsFor: 'as yet unclassified'!position: offset"absolute position"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_SET' ).! !!FileDescriptor methodsFor: 'as yet unclassified'!positionFromEnd: offset"relative to end of file"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_END' ).	! !!FileDescriptor methodsFor: 'as yet unclassified'!read: size	| retValue buffer |	buffer := ExternalBuffer new: size.	retValue := self readBuffer: buffer size: size.	! !!FileDescriptor methodsFor: 'as yet unclassified'!readBuffer: buffer size: size	^ LibC6 default read: self buffer: buffer size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!readString: aString	^ LibC6 default read: self string: aString size: aString size! !!FileDescriptor methodsFor: 'as yet unclassified'!readString: aString size: size	| internalSize |	internalSize := size.	aString size < size ifTrue: [ internalSize := aString size ].	^ LibC6 default read: self string: aString size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!size	| position size |	position := self position.	size := self positionFromEnd: 0.	self position: position.	^ size	! !!FileDescriptor methodsFor: 'as yet unclassified'!writeBuffer: buffer size: size	^ LibC6 default write: self buffer: buffer size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!writeString: aString	^ LibC6 default write: self string: aString size: aString size! !!FileDescriptor methodsFor: 'as yet unclassified'!writeString: aString size: size	| internalSize |	internalSize := size.	aString size < size ifTrue: [ internalSize := aString size ].	^ LibC6 default write: self string: aString size: size! !!FileDescriptor class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalValue! !!FileDescriptor class methodsFor: 'as yet unclassified'!initialize	self initializeStandardDescriptors! !!FileDescriptor class methodsFor: 'as yet unclassified'!initializeStandardDescriptors	StandardDescriptors := Dictionary new.	StandardDescriptors at: #stdout put: (self newFileDescriptor: 0).	StandardDescriptors at: #stdin put: (self newFileDescriptor: 1).	StandardDescriptors at: #stderr put: (self newFileDescriptor: 2).! !!FileDescriptor class methodsFor: 'as yet unclassified'!newFileDescriptor: anInteger	^ self new fileDescriptor: anInteger; yourself.! !!FileDescriptor class methodsFor: 'as yet unclassified'!standardDescriptors	^ StandardDescriptors! !!FileDescriptor class methodsFor: 'as yet unclassified'!stderr	^ StandardDescriptors at: #stderr.! !!FileDescriptor class methodsFor: 'as yet unclassified'!stdin	^ StandardDescriptors at: #stdin.! !!FileDescriptor class methodsFor: 'as yet unclassified'!stdout	^ StandardDescriptors at: #stdout.! !!FileStream methodsFor: 'as yet unclassified'!atEnd	"Answer true if the current position is >= the end of file position.	 1/31/96 sw: subclassResponsibility"	self subclassResponsibility! !!FileStream class methodsFor: 'as yet unclassified'!fileDoesNotExistUserHandling: fullFileName	(GtkMessageDialog question: fullFileName, ' does not exist, create it?') = #yes		ifTrue: [ ^ self new open: fullFileName forWrite: true ].! !!FileStream class methodsFor: 'as yet unclassified'!fileExistsUserHandling: fullFileName	(GtkMessageDialog question: fullFileName, ' exist, overwrite it?') = #yes		ifTrue: [ ^ self new openForOverwrite: fullFileName ].! !!FileStream class methodsFor: 'as yet unclassified'!readOnlyFileDoesNotExistUserHandling: fullFileName	GtkMessageDialog error: fullFileName, ' does not exist'! !!FileDoesNotExistException methodsFor: 'as yet unclassified'!defaultAction	"The default action taken if the exception is signaled."	^self readOnly		ifTrue: [FileStream readOnlyFileDoesNotExistUserHandling: self fileName]		ifFalse: [FileStream fileDoesNotExistUserHandling: self fileName]! !!GIRBuilder methodsFor: 'as yet unclassified'!compiledMethod	| bytecodes |	bytecodes := self bytecodes.	bytecodes ifNil: [ ^ nil ].	^ CompiledMethod new		primitive: 0;		numArgs: self numArgs;		numTemps: self numTemps;		literals: self literals;		relocationInfo: self relocationInfo;		bytecodes: bytecodes;		debugInfo: debugInfo;		source: source;		relocate.! !!GPointer methodsFor: 'as yet unclassified'!initialize	handle := self class defaultHandlerClass new.! !!GPointer class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalAddress! !!GPointer class methodsFor: 'as yet unclassified'!handle: aByteArray	^self basicNew handle: aByteArray; yourself! !!GObject class methodsFor: 'as yet unclassified'!handleFromObject: object	^ object handle.	! !!Gtk methodsFor: 'as yet unclassified'!initialize	self initializeGtkLibrary.	self startMainLoop.! !!Gtk class methodsFor: 'as yet unclassified'!shutDown: quiting	"Quits the Gtk main loop"	Default ifNotNil: [		Default quitMainLoop.		Default close.		Default := nil.	].! !!GtkDemoStockIds methodsFor: 'as yet unclassified'!initialize	| model tree |	model := GtkListStore new: {String. String. String. String}.	GtkStockItem allStocks do: [ :ea |		ea ifNotNil: [			model append: {				ea stockId asGtkStockId.				ea stockId.				ea label.				Gtk acceleratorName: ea keyval asCharacter modifier: ea modifier}]].	tree := GtkTreeView model: model.	self createFirstColumn: tree.	tree appendColumns: {		GtkTreeViewColumn title: 'Label' text: 2.		GtkTreeViewColumn title: 'Accel' text: 3.		GtkTreeViewColumn title: 'ID' text: 0}.	tree selection when: #changed send: #onItemChanged: to: self withArgumentsFirst: {tree}.			self container: (GtkHBox spacing: 5).	self container		packStart: (GtkScrolledWindow withChild: tree);		packEnd: self createInfoFrame expand: false fill: false! !!GtkDemoStockIds methodsFor: 'as yet unclassified'!onItemChanged: aTreeView	aTreeView selectedRow in: [:row |		idLabel label: row first.		nameLabel label: '#', row second.		accelLabel label: row third.		iconImage stock: row second iconSize: #dialog]! !!InMidstOfFileinNotification methodsFor: 'as yet unclassified'!defaultAction	^ self resume: false! !!LibC methodsFor: 'as yet unclassified'!closeLibrary	cLibrary closeLibrary.	cLibrary := nil.! !!LibC methodsFor: 'as yet unclassified'!initializeCLibrary	cLibrary := ExternalLibrary new.	cLibrary name: 'libc.so.6'.	cLibrary openLibrary.! !!LibC class methodsFor: 'as yet unclassified'!shutDown: quiting	"Quits the Gtk main loop"	self default closeLibrary.	Default := nil.! !!LibC6 methodsFor: 'as yet unclassified'!close: fd	| retValue |	retValue := ( self cDeclFunctionNamed: #close ) invokeWith: fd.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #close ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!errno	^ (self libraryDataNamed: #errno) value.	! !!LibC6 methodsFor: 'as yet unclassified'!errno: errno	(self libraryDataNamed: #errno) value: errno.	! !!LibC6 methodsFor: 'as yet unclassified'!free: anExternalBuffer	( self cDeclFunctionNamed: #free ) invokeWith: anExternalBuffer.	! !!LibC6 methodsFor: 'as yet unclassified'!getCurrentDirName	| retValue |	[ retValue := ( self cDeclFunctionNamed: 'get_current_dir_name' asSymbol ) invoke ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: 'get_current_dir_name' asSymbol ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!getEnv: envVariable	^ ( self cDeclFunctionNamed: #getenv ) invokeWith: envVariable.! !!LibC6 methodsFor: 'as yet unclassified'!getpid	^ (self cDeclFunctionNamed: #getpid) invoke.	! !!LibC6 methodsFor: 'as yet unclassified'!initialize	super initialize.	self initializeUniStd.	self initializeStdLib.	self initializeString.	self initializeFCntl.	self initializeStdIO.	self initializeErrNO.! !!LibC6 methodsFor: 'as yet unclassified'!initializeErrNO	self initializeLibraryDataNamed: #errno type: #SignedInteger.! !!LibC6 methodsFor: 'as yet unclassified'!initializeFCntl	self initializeCDeclFunctionNamed: #open returnType: #FileDescriptor argTypes: #( AsciiZ SignedInteger UnsignedInteger ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeStdIO	self initializeCDeclFunctionNamed: #printf  returnType: #SignedInteger argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: #perror  returnType: #Void argTypes: #( AsciiZ  ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeStdLib	self initializeCDeclFunctionNamed: #malloc  returnType: #ExternalBuffer argTypes: #( UnsignedInteger  ).	self initializeCDeclFunctionNamed: #free  returnType: #Void argTypes: #( ExternalBuffer  ).	self initializeCDeclFunctionNamed: #getenv  returnType: #AsciiZ argTypes: #( AsciiZ ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeString	self initializeCDeclFunctionNamed: #strlen returnType: #UnsignedInteger argTypes: #( AsciiZ ).	self initializeCDeclFunctionNamed: #strcat returnType: #AsciiZ argTypes: #( AsciiZ AsciiZ ).	self initializeCDeclFunctionNamed: #strcpy returnType: #AsciiZ argTypes: #( AsciiZ AsciiZ ).	self initializeCDeclFunctionNamed: #strerror returnType: #ReadOnlyAsciiZ argTypes: #( SignedInteger ).	self initializeCDeclFunctionNamed: #memset returnType: #ExternalBuffer argTypes: #( ExternalBuffer SignedInteger  UnsignedInteger ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeUniStd	self initializeCDeclFunctionNamed: #getpid  returnType: #UnsignedInteger argTypes: #().	self initializeCDeclFunctionNamed: 'get_current_dir_name' asSymbol  returnType: #AsciiZ argTypes: #().	self initializeCDeclFunctionNamed: #close  returnType: #SignedInteger argTypes: #( FileDescriptor ).	self initializeCDeclFunctionNamed: #lseek  returnType: #UnsignedInteger argTypes: #( FileDescriptor UnsignedInteger SignedInteger ).	self initializeCDeclFunctionNamed: #read  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalBuffer UnsignedInteger ).	self initializeCDeclFunctionNamed: #write  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalBuffer UnsignedInteger )."Redefinition of read for Strings"	symbolCache at: #readString put: (CDeclFunction name: #read library: self  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalArrayProxy UnsignedInteger ) )."Redefinition of write for Strings"	symbolCache at: #writeString put: (CDeclFunction name: #write library: self  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalArrayProxy UnsignedInteger ) ).! !!LibC6 methodsFor: 'as yet unclassified'!lseek: fileDescriptor offset: offset whence: whence	| returnValue |	returnValue := (self cDeclFunctionNamed: #lseek) invokeWith: fileDescriptor with: offset with: whence.	returnValue < 0 ifTrue: [		self throwErrorForExternalFunctionNamed: #lseek.		^ nil.	].	^ returnValue.	! !!LibC6 methodsFor: 'as yet unclassified'!malloc: size	| retValue |	[ retValue := ( self cDeclFunctionNamed: #malloc ) invokeWith: size ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: #malloc withMessage: 'can not allocate memory' ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!memSet: buffer constant: c count: n	^ (self cDeclFunctionNamed: #memset) invokeWith: buffer with: c with: n.	! !!LibC6 methodsFor: 'as yet unclassified'!open: path flags: flags	^ self open: path flags: flags mode: 8r644	! !!LibC6 methodsFor: 'as yet unclassified'!open: path flags: flags mode: mode	| fileDescriptor |	fileDescriptor := (self cDeclFunctionNamed: #open) invokeWith: path with: flags with: mode.	fileDescriptor fileDescriptor < 0 ifTrue: [		self throwErrorForExternalFunctionNamed: #open.		^ nil.	].	^ fileDescriptor.	! !!LibC6 methodsFor: 'as yet unclassified'!perror: aString	( self cDeclFunctionNamed: #perror ) invokeWith: aString.	! !!LibC6 methodsFor: 'as yet unclassified'!printf: aString	^ ( self cDeclFunctionNamed: #printf ) invokeWith: aString.	! !!LibC6 methodsFor: 'as yet unclassified'!read: fd buffer: buffer size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #read ) invokeWith: fd with: buffer with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #read ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!read: fd string: aString size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #readString ) invokeWith: fd with: aString with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #readString ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!strCat: destString with: sourceString	^ ( self cDeclFunctionNamed: #strcat ) invokeWith: destString with: sourceString.	! !!LibC6 methodsFor: 'as yet unclassified'!strCpy: destString with: sourceString	^ ( self cDeclFunctionNamed: #strcpy ) invokeWith: destString with: sourceString.	! !!LibC6 methodsFor: 'as yet unclassified'!strError: errno	| retValue |	[ retValue := ( self cDeclFunctionNamed: #strerror ) invokeWith: errno ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: #strerror ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!strLen: string	^ ( self cDeclFunctionNamed: #strlen ) invokeWith: string	! !!LibC6 methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName	^ self throwErrorForExternalFunctionNamed: functionName withMessage: (self strError: self errno).	! !!LibC6 methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName withMessage: aString	| error |	error := ExternalFunctionError functionName: functionName.	error messageText: aString.	^ error signal.	! !!LibC6 methodsFor: 'as yet unclassified'!valueForLSeekDirectiveNamed: aString	^ LSeekDirectives at: aString asSymbol.	! !!LibC6 methodsFor: 'as yet unclassified'!valueForOpenFlagNamed: aString	^ OpenFlags at: aString asSymbol.	! !!LibC6 methodsFor: 'as yet unclassified'!write: fd buffer: buffer size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #write ) invokeWith: fd with: buffer with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #write ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!write: fd string: aString size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #writeString ) invokeWith: fd with: aString with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #writeString ].	^ retValue.	! !!LibC6 class methodsFor: 'as yet unclassified'!initialize	self initializeOpenFlags.	self initializeLSeekDirectives.! !!LibC6 class methodsFor: 'as yet unclassified'!initializeLSeekDirectives	| lSeekDirectives |		lSeekDirectives := Dictionary new.	lSeekDirectives at: 'SEEK_SET' put: 0.	lSeekDirectives at: 'SEEK_CUR' put: 1.	lSeekDirectives at: 'SEEK_END' put: 2.	LSeekDirectives := lSeekDirectives! !!LibC6 class methodsFor: 'as yet unclassified'!initializeOpenFlags	| flagArray openFlags |		flagArray := #( 		('O_RDONLY'		0)		('O_WRONLY'		8r1)		('O_RDWR'		8r2)		('O_CREAT'		8r100)			('O_EXCL'			8r200)			('O_NOCTTY'		8r400)			('O_TRUNC'		8r1000)			('O_APPEND'		8r2000)		('O_NONBLOCK'	8r4000)		('O_SYNC'		8r10000)		('O_ASYNC'		8r20000)	).	openFlags := Dictionary new.	flagArray do: [ :i |		openFlags at: i first asSymbol put: i second	].	OpenFlags := openFlags! !!LibC6 class methodsFor: 'as yet unclassified'!moduleName	^ 'libc.so.6'.! !!LibExample methodsFor: 'as yet unclassified'!getpid	^ GETPID invoke! !!LibExample class methodsFor: 'as yet unclassified'!getpid	^ GETPID! !!LibExample class methodsFor: 'as yet unclassified'!initialize	GETPID := CDeclFunction name: 'getpid' libraryNamed: 'libc.so.6' returnType: #UnsignedInteger argTypes: #().! !!LibReadLine methodsFor: 'as yet unclassified'!addHistory: aString	( self cDeclFunctionNamed: 'add_history' asSymbol ) invokeWith: aString.! !!LibReadLine methodsFor: 'as yet unclassified'!initialize	super initialize.	self initializeCDeclFunctionNamed: #readline  returnType: #AsciiZ argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'add_history' asSymbol returnType: #Void argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'read_history' asSymbol returnType: #SignedInteger argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'write_history' asSymbol returnType: #SignedInteger argTypes: #( AsciiZ  ).! !!LibReadLine methodsFor: 'as yet unclassified'!readHistory: aFileName	| errno |	errno := ( self cDeclFunctionNamed: 'read_history' asSymbol ) invokeWith: aFileName.	errno = 0 ifFalse: [ self throwErrorForExternalFunctionNamed: 'read_history' asSymbol errno: errno ].	^ errno.! !!LibReadLine methodsFor: 'as yet unclassified'!readline: prompt	^ ( self cDeclFunctionNamed: #readline ) invokeWith: prompt.! !!LibReadLine methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName errno: errno	| error |	error := ExternalFunctionError functionName: functionName.	error messageText: (LibC6 default strError: errno).	^ error signal.! !!LibReadLine methodsFor: 'as yet unclassified'!writeHistory: aFileName	| errno |	errno := ( self cDeclFunctionNamed: 'write_history' asSymbol ) invokeWith: aFileName.	errno = 0 ifFalse: [ self throwErrorForExternalFunctionNamed: 'write_history' asSymbol errno: errno ].	^ errno.! !!LibReadLine class methodsFor: 'as yet unclassified'!moduleName	^ 'libreadline.so.5'.! !!LibraryData methodsFor: 'as yet unclassified'!primitiveGetValue: valueHandle	<primitive: 216>	^self primitiveFailed! !!LibraryData methodsFor: 'as yet unclassified'!primitiveSetValue: valueHandle	<primitive: 217>	^self primitiveFailed! !!LibraryData methodsFor: 'as yet unclassified'!type	^ type.! !!LibraryData methodsFor: 'as yet unclassified'!type: aType	type := aType.! !!LibraryData methodsFor: 'as yet unclassified'!value	| valueClass valueHandle |	valueClass := self classFromType: type.	valueHandle := valueClass defaultHandlerClass new.	handle isNull ifTrue: [ self bind ].	self primitiveGetValue: valueHandle.	^ valueClass objectFromHandle: valueHandle.! !!LibraryData methodsFor: 'as yet unclassified'!value: aValue	| argHandle argClass |	argClass := self classFromType: type.	argHandle := argClass handleFromObject: aValue.	handle isNull ifTrue: [ self bind ].	self primitiveSetValue: argHandle! !!LibraryData class methodsFor: 'as yet unclassified'!name: aName library: aLibrary type: type	^self new name: aName library: aLibrary;		type: type;		bind! !!Metaclass methodsFor: 'as yet unclassified'!addObsoleteSubclass: aClass	"Do nothing."! !!Metaclass methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return true if it is safe to zap the method dictionary on #obsolete"	thisClass == nil		ifTrue:[^true]		ifFalse:[^thisClass canZapMethodDictionary]! !!Metaclass methodsFor: 'as yet unclassified'!isSystemDefined	"Answer false if I am a UniClass (an instance-specific lightweight class)"	^ true! !!NativeFunction methodsFor: 'as yet unclassified'!callingConventionString	^ 'native'! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver	^self invokeReceiver: receiver withArguments: #()! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1	^self invokeReceiver: receiver withArguments: (Array with: arg1)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4 with: arg5	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver withArguments: argArray	handle isNull ifTrue: [ self bind ].	^ self primInvokeReceiver: receiver withArguments: argArray.! !!NativeFunction methodsFor: 'as yet unclassified'!primInvokeReceiver: receiver withArguments: argArray	"Manually invoke the receiver, representing an native function."	<primitive: 197>	^self primitiveFailed! !!ObjectTest methodsFor: 'as yet unclassified'!testBecome	"self debug: #testBecome"	"this test should that all the variables pointing to an object are pointing now to another one, and all      object pointing to the other are pointing to the object"	| pt1 pt2 pt3 |	pt1 := 0@0.	pt2 := pt1.	pt3 := 100@100.	pt1 become: pt3.	self assert: pt2 = (100@100).	self assert: pt3 = (0@0).	self assert: pt1 = (100@100).! !!ObjectTest methodsFor: 'as yet unclassified'!testBecomeForward	"self debug: #testBecomeForward"	"this test should that all the variables pointing to an object are pointing now to another one.	Not that this inverse is not true. This kind of become is called oneWayBecome in VW"	| pt1 pt2 pt3 |	pt1 := 0@0.	pt2 := pt1.	pt3 := 100@100.	pt1 becomeForward: pt3.	self assert: pt2 = (100@100).	self assert: pt3 == pt2.	self assert: pt1 = (100@100)! !!PrimitiveType class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalValue! !!PrimitiveType class methodsFor: 'as yet unclassified'!handleFromObject: anObject	^ self handleFromObject: anObject ifError: [ self throwTypeConvertionError ]! !!PrimitiveType class methodsFor: 'as yet unclassified'!handleFromObject: object ifError: aBlock	self subclassResponsibility.! !!PrimitiveType class methodsFor: 'as yet unclassified'!objectFromHandle: handle	^ self objectFromHandle: handle ifError: [  self throwTypeConvertionError ]! !!PrimitiveType class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock	self subclassResponsibility.! !!PrimitiveType class methodsFor: 'as yet unclassified'!throwTypeConvertionError	^ TypeConvertionError new signal! !!IntegerType class methodsFor: 'as yet unclassified'!handleFromObject: anInteger ifError: aBlock	| handle |		(self checkType: anInteger) ifFalse: [ ^ aBlock value ].	handle := ExternalValue new.	self store: anInteger in: handle.	^ handle.	! !!IntegerType class methodsFor: 'as yet unclassified'!isBigEndian	^  false! !!IntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	self subclassResponsibility.! !!IntegerType class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: errorBlock	| value |		value := self loadFrom: handle.	(value > self max ) ifTrue: [ ^ errorBlock value ].	^ value.! !!Process methodsFor: 'as yet unclassified'!primitiveBeInitialProcess	<primitive: 196>	self primitiveFailed! !!ProcessorScheduler methodsFor: 'as yet unclassified'!activeProcess	^ self primActiveProcess! !!ProcessorScheduler methodsFor: 'as yet unclassified'!primActiveProcess	<primitive: 195>	self primitiveFail.! !!ProcessorScheduler methodsFor: 'as yet unclassified'!startUp	| firstProcess |"	(processList isNil or: [ processList isEmpty not ]) ifTrue: [ self initialize ]."	self initialize.	firstProcess := Process new.	firstProcess name: 'Init'.	firstProcess priority: self userSchedulingPriority.	firstProcess state: #running."	firstProcess threadData: self activeThreadData."	firstProcess primitiveBeInitialProcess.! !!ReadOnlyAsciiZ methodsFor: 'as yet unclassified'!asString	^ handle toString.! !!ReadOnlyAsciiZ class methodsFor: 'as yet unclassified'!handleFromObject: aByteArray ifError: aBlock	"Can not be used as arguments"	aBlock value.! !!ReadOnlyAsciiZ class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; asString! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!addressRelativeTo: bytecodes	| functionAddress bytecodesAddress |	functionAddress := self function address asInteger.	bytecodesAddress := (ExternalAddress forArray: bytecodes ) asInteger.	^ functionAddress - bytecodesAddress - offset - 4! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!function	^ self library functionNamed: functionName.! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!functionName	^ functionName! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!functionName: aSymbol	^ functionName := aSymbol! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!library	^ Executable default! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!patch: bytecodes	self patch: bytecodes with: (self addressRelativeTo: bytecodes).! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!patch: bytecodes with: value	bytecodes longAt: (offset + 1) put: value bigEndian: false.! !!FunctionRelocation methodsFor: 'as yet unclassified'!addressRelativeTo: bytecodes	^ self primAddressRelativeTo: bytecodes! !!FunctionRelocation methodsFor: 'as yet unclassified'!primAddressRelativeTo: bytecodes	<primitive: 155>	self primitiveFail.! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!defaultLibraryClass	^ NativeLibrary! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!library 		^ self defaultLibraryClass named: libraryName! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!libraryName	^ libraryName! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!libraryName: aSymbol	^ libraryName := aSymbol! !!ExternalFunctionRelocation methodsFor: 'as yet unclassified'!defaultLibraryClass	^ ExternalLibrary2! !!SequenceableCollection methodsFor: 'as yet unclassified'!asTraitComposition	"For convenience the composition {T1. T2 ...} is the same as T1 + T2 + ..."	^self isEmpty		ifFalse: [			self size = 1				ifTrue: [self first asTraitComposition]				ifFalse: [					self copyWithoutFirst 						inject: self first						into: [:left :right | left + right]]]		ifTrue: [			TraitComposition new]! !!Array methodsFor: 'as yet unclassified'!elementsExchangeIdentityWith: otherArray	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsExchangeIdentityWith: otherArray.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!elementsForwardIdentityTo: otherArray	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsForwardIdentityTo: otherArray.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!elementsForwardIdentityTo: otherArray copyHash: copyHash	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsForwardIdentityTo: otherArray copyHash: copyHash.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!primElementsExchangeIdentityWith: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  At the same time, all pointers to the elements of otherArray are replaced by pointers to the corresponding elements of this array.  The identityHashes remain with the pointers rather than with the objects so that objects in hashed structures should still be properly indexed after the mutation."	<primitive: 128>	otherArray class == Array ifFalse: [^ self error: 'arg must be array'].	self size = otherArray size ifFalse: [^ self error: 'arrays must be same size'].	(self anySatisfy: [:obj | obj class == SmallInteger]) ifTrue: [^ self error: 'can''t become SmallIntegers'].	(otherArray anySatisfy: [:obj | obj class == SmallInteger]) ifTrue: [^ self error: 'can''t become SmallIntegers'].	"Must have failed because not enough space in forwarding table (see ObjectMemory-prepareForwardingTableForBecoming:with:twoWay:).  Do GC and try again only once"	(Smalltalk bytesLeft: true) = Smalltalk primitiveGarbageCollect		ifTrue: [^ self primitiveFailed].	^ self elementsExchangeIdentityWith: otherArray! !!Array methodsFor: 'as yet unclassified'!primElementsForwardIdentityTo: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  The identityHashes remain with the pointers rather than with the objects so that the objects in this array should still be properly indexed in any existing hashed structures after the mutation."	<primitive: 72>	self primitiveFailed! !!Array methodsFor: 'as yet unclassified'!primElementsForwardIdentityTo: otherArray copyHash: copyHash	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  The identityHashes remain with the pointers rather than with the objects so that the objects in this array should still be properly indexed in any existing hashed structures after the mutation."	<primitive: 249>	self primitiveFailed! !!ExternalValue methodsFor: 'as yet unclassified'!beNull	"Make the receiver a NULL pointer"	self atAllPut: 0.! !!ExternalValue methodsFor: 'as yet unclassified'!isNull	^(self basicAt: 1) = 0	and: (self basicAt: 2) = 0	and: (self basicAt: 3) = 0	and: (self basicAt: 4) = 0	! !!ExternalValue class methodsFor: 'as yet unclassified'!initialize	Smalltalk addToStartUpList: self.! !!ExternalValue class methodsFor: 'as yet unclassified'!new	"External addresses are always 4 bytes long"	^super new: 4! !!ExternalValue class methodsFor: 'as yet unclassified'!new: n	"You better don't try this..."	^self shouldNotImplement! !!ExternalValue class methodsFor: 'as yet unclassified'!startUp: resuming	resuming ifTrue: [		self allInstancesDo: [ :addr |			addr beNull		]	].! !!SharedPool class methodsFor: 'as yet unclassified'!bindingOf: varName	"Answer the binding of some variable resolved in the scope of the receiver"	| aSymbol binding |	aSymbol := varName asSymbol.	"First look in classVar dictionary."	binding := self classPool bindingOf: aSymbol.	binding ifNotNil:[^binding].	"Next look in shared pools."	self sharedPools do:[:pool | 		binding := pool bindingOf: aSymbol.		binding ifNotNil:[^binding].	].	"subclassing and environment are not preserved"	^nil! !!SharedPool class methodsFor: 'as yet unclassified'!bindingsDo: aBlock	^self classPool bindingsDo: aBlock! !!SharedPool class methodsFor: 'as yet unclassified'!classBindingOf: varName	"For initialization messages grant the regular scope"	^super bindingOf: varName! !!SharedPool class methodsFor: 'as yet unclassified'!hasBindingThatBeginsWith: aString	"Answer true if the receiver has a binding that begins with aString, false otherwise"	"First look in classVar dictionary."	(self classPool hasBindingThatBeginsWith: aString) ifTrue:[^true].	"Next look in shared pools."	self sharedPools do:[:pool | 		(pool hasBindingThatBeginsWith: aString) ifTrue: [^true]].	^false! !!SharedPool class methodsFor: 'as yet unclassified'!includesKey: aName	"does this pool include aName"	^(self bindingOf: aName) notNil! !!SharedPool class methodsFor: 'as yet unclassified'!keysDo: aBlock"A hopefully temporary fix for an issue arising from miss-spelled variable names in code being compiled. The correction code (see Class>possibleVariablesFor:continuedFrom: assumes that sharedPools are Dictionaries. The proper fix would involve making sure all pools are actually subclasses of SharedPool, which they are not currently."	self bindingsDo:[:b|		aBlock value: b key]! !!Shell methodsFor: 'as yet unclassified'!display: string	| buffer |		buffer := AsciiZ fromString: string.	^ FileDescriptor stdout writeBuffer: buffer size: buffer size.! !!Shell methodsFor: 'as yet unclassified'!input: prompt	^ LibReadLine default readline: prompt! !!Shell methodsFor: 'as yet unclassified'!main	| line value failed anotherLine buffer |	LibReadLine default readHistory: self historyFileName.	[		anotherLine := false.		buffer := ''.		[ 	| prompt |			prompt := anotherLine ifTrue: [ '' ] ifFalse: [ '> ' ].			line _ self input: prompt.			line isEmpty				ifTrue: [ true ] 				ifFalse: [					(line last = $\)						ifTrue: [							anotherLine := true.							line at: line size put: Character lf.						]						ifFalse: [ anotherLine := false ].					buffer := buffer, line.					anotherLine				]		] whileTrue. 		buffer = 'quit' or: [ buffer = 'save' ]	] whileFalse: [		self addToHistory: buffer.		failed _ false.		value _ Compiler new evaluate: buffer in: nil to: nil notifying: self ifFail: [ failed _ true].		failed ifFalse: [ self display: (value printString); lf ]	].	LibReadLine default writeHistory: self historyFileName.	buffer = 'save' ifTrue: [ Smalltalk snapshotAndQuit ].	^value.! !!SignedIntegerType class methodsFor: 'as yet unclassified'!checkType: value	^ value isInteger and: [ value >= self min and: [ value <= self max ] ]! !!SignedIntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	^ handle longAt: 1 bigEndian: self isBigEndian.! !!SignedIntegerType class methodsFor: 'as yet unclassified'!store: anInteger in: handle	handle longAt: 1 put: anInteger bigEndian: self isBigEndian.! !!SignedByte class methodsFor: 'as yet unclassified'!max			^ 127! !!SignedByte class methodsFor: 'as yet unclassified'!min			^ -128! !!SignedInteger class methodsFor: 'as yet unclassified'!max			^ 2147483647! !!SignedInteger class methodsFor: 'as yet unclassified'!min			^ -2147483648! !!SignedShortInteger class methodsFor: 'as yet unclassified'!max			^ 32767! !!SignedShortInteger class methodsFor: 'as yet unclassified'!min			^ -32768! !!SourceReference methodsFor: 'as yet unclassified'!sourceFrom: aString	self hasEmptySourceReference ifTrue: [ ^ '' ].	^ aString copyFrom: sourceStart to: sourceStop! !!StandardFileStream class methodsFor: 'as yet unclassified'!retryWithGC: execBlock until: testBlock forFileNamed: fullName	"Re-implemented to only force GC if a file with the given name exists"	| blockValue foundIt |	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	"See if we have a file with the given name"	foundIt := self registry keys "hold on strongly for now" 		anySatisfy:[:file| file name sameAs: fullName].	foundIt ifFalse:[^blockValue].	Smalltalk garbageCollectMost.	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollect.	^execBlock value.! !!SystemDictionary methodsFor: 'as yet unclassified'!forgetClass: aClass logged: aBool 	"Delete the class, aClass, from the system.	Note that this doesn't do everything required to dispose of a class - to do that use Class>>removeFromSystem."	aBool ifTrue: [SystemChangeNotifier uniqueInstance classRemoved: aClass fromCategory: aClass category].			SystemOrganization removeElement: aClass name.	self removeFromStartUpList: aClass.	self removeFromShutDownList: aClass.	self removeKey: aClass name ifAbsent: [].	self flushClassNameCache! !!SystemDictionary methodsFor: 'as yet unclassified'!removeClassNamed: aName	"Invoked from fileouts:  if there is currently a class in the system named aName, then remove it.  If anything untoward happens, report it in the Transcript.  "	| oldClass |	(oldClass _ self at: aName asSymbol ifAbsent: [nil]) == nil		ifTrue:			[Transcript cr; show: 'Removal of class named ', aName, ' ignored because ', aName, ' does not exist.'.			^ self].	oldClass removeFromSystem! !!SystemDictionary methodsFor: 'as yet unclassified'!startUp	Processor startUp.	ProcessorScheduler startUp.	self processStartUpList: true.	self installLowSpaceWatcher.! !!SystemTracer methodsFor: 'as yet unclassified'!getAligned: size	^ (( size + 3 ) bitShift: -2) bitShift: 2.! !!TraitBehavior methodsFor: 'as yet unclassified'!addUser: aClassOrTrait	users add: aClassOrTrait! !!TraitBehavior methodsFor: 'as yet unclassified'!classesComposedWithMe	^users gather: [:u | u classesComposedWithMe]! !!TraitBehavior methodsFor: 'as yet unclassified'!initialize	self methodDict: Dictionary new.	self traitComposition: nil.	users _ IdentitySet new.! !!TraitBehavior methodsFor: 'as yet unclassified'!removeUser: aClassOrTrait	users remove: aClassOrTrait ifAbsent: []! !!TraitBehavior methodsFor: 'as yet unclassified'!users	^users! !!TraitComposition methodsFor: 'as yet unclassified'!assertValidUser: aBehavior	"Assert that this trait composition set for aBehavior	does not introduce a cycle."		(self allTraits includes: aBehavior) ifTrue: [		TraitCompositionException signal: 'Cycle in compositions:  The composition (in)directly includes this trait!!']! !!TraitComposition methodsFor: 'as yet unclassified'!methodDescriptionsForSelector: aSymbol	"Return a collection of TraitMethodDescriptions for aSymbol and all the 	aliases of aSymbol."	| selectors collection |	selectors _ IdentitySet with: aSymbol.	self transformations do: [:each |		selectors addAll: (each aliasesForSelector: aSymbol)].	collection _ OrderedCollection new: selectors size.	selectors do: [:each |		collection add: (self methodDescriptionForSelector: each)].	^collection! !!TraitDescription methodsFor: 'as yet unclassified'!trait	"for compatibility with TraitTransformations"	^ self! !!TraitDescription methodsFor: 'as yet unclassified'!updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil	| currentCategory effectiveCategory sel changedCategories composition |	changedCategories _ IdentitySet new.	composition := self hasTraitComposition		ifTrue: [self traitComposition]		ifFalse: [TraitComposition new].	(composition methodDescriptionsForSelector: aSymbol) do: [:each |		sel _ each selector.		(self includesLocalSelector: sel) ifFalse: [			currentCategory _ self organization categoryOfElement: sel.			effectiveCategory _ each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.			effectiveCategory isNil ifTrue: [				currentCategory ifNotNil: [changedCategories add: currentCategory].				self organization removeElement: sel.			] ifFalse: [				((currentCategory isNil or: [currentCategory == ClassOrganizer ambiguous or: [currentCategory == oldCategoryOrNil]]) and: [currentCategory ~~ effectiveCategory]) ifTrue: [					currentCategory ifNotNil: [changedCategories add: currentCategory].					self organization 						classify: sel 						under: effectiveCategory						suppressIfDefault: false]]]].	^ changedCategories! !!TraitDescription methodsFor: 'as yet unclassified'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	(self includesSelector: aSelector)		ifTrue: [^ self organization categoryOfElement: aSelector]		ifFalse: [^nil]! !!Trait methodsFor: 'as yet unclassified'!initialize	super initialize.	classTrait _ ClassTrait for: self! !!TranscriptCodeView class methodsFor: 'as yet unclassified'!initialize	Smalltalk addToStartUpList: self.! !!TranscriptCodeView class methodsFor: 'as yet unclassified'!startUp: resuming	resuming ifTrue: [		TranscriptCodeBuffer := nil.	].! !!TranscriptStream methodsFor: 'as yet unclassified'!open	TranscriptCodeEditor open.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!atEnd	position ifNil: [ ^ nil ].	^ position >= readLimit! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!close	"Close this file."	fileID ifNotNil: [		fileID close.		fileID := nil.		position := nil.	].! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!open: fileName flags: flags	[ fileID := LibC6 default open: fileName flags: flags ]		on: ExternalFunctionError		do: [ ^ nil ].	name := fileName.	readLimit := fileID size.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!open: fileName forWrite: writeMode 	| flags |	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	flags := writeMode 		ifTrue: [ LibC6 default valueForOpenFlagNamed: 'O_RDWR' ]		ifFalse: [ LibC6 default valueForOpenFlagNamed: 'O_RDONLY' ].	rwmode := writeMode.	^ self open: fileName flags: flags.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!openForOverwrite: fileName	| flags |	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	flags := ((LibC6 default valueForOpenFlagNamed: 'O_RDWR') 			bitOr: ( LibC6 default valueForOpenFlagNamed: 'O_TRUNC' )) 			bitOr: ( LibC6 default valueForOpenFlagNamed: 'O_CREAT' ).	rwmode := true.	^ self open: fileName flags: flags.! !!BufferedFileStream methodsFor: 'as yet unclassified'!close	"Close this file."	self flush.	^ super close.! !!BufferedFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	self subclassResponsibility! !!BufferedFileStream methodsFor: 'as yet unclassified'!defaultBufferSize	^ DefaultBufferSize.! !!BufferedFileStream methodsFor: 'as yet unclassified'!flush	| bufferPosition bufferSize |	fileID ifNil: [ ^ nil ].	rwmode ifFalse: [ ^ nil ].	bufferPosition := position truncateTo: (collection size).	bufferSize := collection size min: ( readLimit - bufferPosition).	fileID position: bufferPosition.	bufferSize > 0 ifTrue: [ fileID writeString: collection size: bufferSize ].	 ! !!BufferedFileStream methodsFor: 'as yet unclassified'!initializeBuffer	| bufferSize |	position := 0.	collection := self defaultBufferClass new: self defaultBufferSize.	bufferSize := collection size min: readLimit.	bufferSize > 0 ifTrue: [ fileID readString: collection size: bufferSize ]. ! !!BufferedFileStream methodsFor: 'as yet unclassified'!next	| byte |	byte := self peek.	self position: position + 1.	^ byte! !!BufferedFileStream methodsFor: 'as yet unclassified'!nextPut: char	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	position ifNil: [ self position: 0 ].	collection at: (position \\ (collection size)) + 1put: char.	self position: position + 1.	^ char! !!BufferedFileStream methodsFor: 'as yet unclassified'!open: fileName flags: flags	(super open: fileName flags: flags) ifNotNil: [ self initializeBuffer ].! !!BufferedFileStream methodsFor: 'as yet unclassified'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	position ifNil: [ self position: 0 ].	self atEnd ifTrue: [^ nil ].	^ collection at: (position \\ (collection size)) + 1.! !!BufferedFileStream methodsFor: 'as yet unclassified'!position: newPosition	| oldBufferPosition newBufferPosition bufferSize |	fileID ifNil: [ ^nil ].	newPosition < 0 ifTrue: [ ^nil ]."	((newPosition > readLimit) and: [ rwmode not ])  ifTrue: [ ^nil ]."	newPosition > readLimit ifTrue: [		rwmode ifTrue: [ readLimit := newPosition ] ifFalse: [ ^nil ]	].	oldBufferPosition := position truncateTo: (collection size).	newBufferPosition := newPosition truncateTo: (collection size).	newBufferPosition = oldBufferPosition ifFalse: [ 		self flush.		fileID position: newBufferPosition.		bufferSize := collection size min: ( readLimit - newBufferPosition).		collection := self defaultBufferClass new: self defaultBufferSize.		bufferSize > 0 ifTrue: [ fileID readString: collection size: bufferSize ].	].	position := newPosition."	rwmode ifTrue: [ readLimit := newPosition ]."	^ position.! !!BinaryFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	^ ByteArray! !!TextFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	^ String! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!concreteStream	"Who should we really direct class queries to?  "	^ UnbufferedFileStream.! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!fileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new open: fileName forWrite: true! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!forceNewFileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new openForOverwrite: fileName! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!readOnlyFileNamed: fileName 	"Open an existing file with the given name for reading."	| f |	f := self new open: fileName forWrite: false.	^ f isNil		ifFalse: [f]		ifTrue: ["File does not exist..."			((FileDoesNotExistException fileName: fileName) readOnly: true) signal].	"StandardFileStream readOnlyFileNamed: 'kjsd.txt' "! !!BufferedFileStream class methodsFor: 'as yet unclassified'!initialize	self initializeDefaultBufferSize.! !!BufferedFileStream class methodsFor: 'as yet unclassified'!initializeDefaultBufferSize	DefaultBufferSize := 4096.! !!BufferedFileStream class methodsFor: 'as yet unclassified'!new	^ TextFileStream new.! !!UnhandledError methodsFor: 'as yet unclassified'!devDefaultAction	"The current computation is terminated. The cause of the error should be logged or reported to the user. If the program is operating in an interactive debugging environment the computation should be suspended and the debugger activated."	(GtkMessageDialog question: exception messageText, ', debug it?' ) = #yes		ifTrue: [ ^Processor activeProcess debugError: exception ]."	^ Processor activeProcess terminate."! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!checkType: value	^ value isInteger and: [ value >= 0 and: [ value <= self max ] ]! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	^ handle unsignedLongAt: 1 bigEndian: self isBigEndian.! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!min	^ 0! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!store: anInteger in: handle	handle unsignedLongAt: 1 put: anInteger bigEndian: self isBigEndian.! !!UnsignedByte class methodsFor: 'as yet unclassified'!max			^ 255! !!UnsignedInteger class methodsFor: 'as yet unclassified'!max			^ 4294967295! !!UnsignedShortInteger class methodsFor: 'as yet unclassified'!max			^ 65535! !!Workspace methodsFor: 'as yet unclassified'!buildMenuBar	| menu  edit  |	menu := GtkMenuBar new.	edit := GtkMenu new.	menu		append: AppLauncher fileMenu;		append: (edit createMenuItem: '_Edit');		append: workspaceView menu;		append: AppLauncher toolsMenu;		append: AppLauncher helpMenu.					^ menu.! !!Workspace methodsFor: 'as yet unclassified'!buildToolBar	| toolBar |	^ GtkToolbar new		appendItems: workspaceView toolBar;		yourself! !!Workspace methodsFor: 'as yet unclassified'!defaultCodeViewClass	^ WorkspaceView! !!Workspace methodsFor: 'as yet unclassified'!initialize	workspaceView := self defaultCodeViewClass new.	self container: (GtkVBox new		packStart: (self buildMenuBar) expand: false;		packStart: (self buildToolBar) expand: false;		packStart: (workspaceView view);		packStart: (GtkStatusbar new) expand: false	).! !!Workspace methodsFor: 'as yet unclassified'!inspectedVar: anObject	workspaceView inspectedVar: anObject.! !!TranscriptCodeEditor methodsFor: 'as yet unclassified'!defaultCodeViewClass	^ TranscriptCodeView! !!Workspace class methodsFor: 'as yet unclassified'!defaultSize	^ 640@480.! !!Workspace class methodsFor: 'as yet unclassified'!title	^'Workspace'! !!TranscriptCodeEditor class methodsFor: 'as yet unclassified'!title	^'Transcript'! !BufferedFileStream initialize!TranscriptCodeView initialize!TraitBehavior removeSelector: #initializeUsers!Application subclass: #Shell	instanceVariableNames: 'bindings'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!ExternalValue initialize!NativeFunctionRelocation removeSelector: #addressRelativeTo:!NativeFunctionRelocation removeSelector: #function!NativeFunctionRelocation removeSelector: #functionName!NativeFunctionRelocation removeSelector: #functionName:!NativeFunctionRelocation removeSelector: #patch:!NativeFunctionRelocation removeSelector: #patch:with:!ReadOnlyAsciiZ class removeSelector: #objectFromHandle:!ProcessorScheduler removeSelector: #activeProcess2!ProcessorScheduler removeSelector: #activeThreadData!ProcessorScheduler removeSelector: #primActiveThreadData!Process removeSelector: #threadData:!PrimitiveType class removeSelector: #defaultHandlerType!PrimitiveType class removeSelector: #instantiateHandler!NativeFunction removeSelector: #address!NativeFunction removeSelector: #bind!NativeFunction removeSelector: #invoke!NativeFunction removeSelector: #invokeAnswering:!NativeFunction removeSelector: #invokeAnswering:with:!NativeFunction removeSelector: #invokeAnswering:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:withArguments:!NativeFunction removeSelector: #invokeWith:!NativeFunction removeSelector: #invokeWith:with:!NativeFunction removeSelector: #invokeWith:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:with:with:!NativeFunction removeSelector: #invokeWithArguments:!NativeFunction removeSelector: #name!NativeFunction removeSelector: #name:!NativeFunction removeSelector: #throwNotKnownError!LibraryData removeSelector: #primitiveGetValue!LibExample initialize!LibC6 initialize!LibC6 removeSelector: #initializeUnistd!LibC6 removeSelector: #openPath:flags:!LibC6 removeSelector: #write2:buffer:size:!LibC removeSelector: #close!GPointer class removeSelector: #instantiateHandler!FileStream removeSelector: #position!FileDescriptor initialize!FileDescriptor removeSelector: #movePositionTo:!FileDescriptor removeSelector: #name!FileDescriptor removeSelector: #name:!FileDescriptor removeSelector: #positionFromEns:!FileDescriptor removeSelector: #setPositionAt:!FileDescriptor removeSelector: #setPositionFromEndAt:!CDeclFunction class removeSelector: #name:libraryNamed:returnType:argTypes:!ExecutableFunction class removeSelector: #name:library:!ExecutableFunction class removeSelector: #name:libraryNamed:!CDeclFunction removeSelector: #classFromType:!CDeclFunction removeSelector: #throwExternalFunctionError!ExecutableFunction removeSelector: #address!ExecutableFunction removeSelector: #bind!ExecutableFunction removeSelector: #invoke!ExecutableFunction removeSelector: #invokeWith:!ExecutableFunction removeSelector: #invokeWith:with:!ExecutableFunction removeSelector: #invokeWith:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithArguments:!ExecutableFunction removeSelector: #invokeWithReceiver:!ExecutableFunction removeSelector: #invokeWithReceiver:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:withArguments:!ExecutableFunction removeSelector: #library!ExecutableFunction removeSelector: #library:!ExecutableFunction removeSelector: #libraryName!ExecutableFunction removeSelector: #libraryNamed:!ExecutableFunction removeSelector: #name!ExecutableFunction removeSelector: #name:!ExecutableFunction removeSelector: #name:library:!ExecutableFunction removeSelector: #name:libraryNamed:!ExecutableFunction removeSelector: #primInvokeReceiver:withArguments:!ExecutableFunction removeSelector: #primInvokeWithArguments:!ExecutableFunction removeSelector: #primInvokeWithReceiver:withArguments:!ExecutableFunction removeSelector: #throwNotKnownError!ExternalSymbol removeSelector: #callingConventionString!ExternalObjectProxy removeSelector: #register!ExternalObjectProxy removeSelector: #unregister!AsciiZ class removeSelector: #objectFromHandle:!Executable class removeSelector: #huenul!DynamicLibrary class removeSelector: #addLibrary:named:!DynamicLibrary class removeSelector: #huemul!DynamicLibrary initialize!DynamicLibrary class removeSelector: #name:!DynamicLibrary class removeSelector: #named:!ExternalObject class removeSelector: #handle:!ExternalObject initialize!ExternalObject class removeSelector: #registry!ExternalObject class removeSelector: #registry:!AsciiZ removeSelector: #setFrom:!ExternalBuffer removeSelector: #finalize!ExternalBuffer removeSelector: #selfCheck!ExternalBuffer removeSelector: #setFrom:!ExternalBuffer removeSelector: #storeInto:size:!Executable removeSelector: #initialize!Executable removeSelector: #instantiateFunctionClass:!Executable removeSelector: #name:!Executable removeSelector: #nativeFunctionNamed:!Executable removeSelector: #primitiveOpen!DynamicLibrary removeSelector: #addExternal:!DynamicLibrary removeSelector: #basicName!DynamicLibrary removeSelector: #bind:!DynamicLibrary removeSelector: #bindFunction:!DynamicLibrary removeSelector: #cDeclFunctionNamed:returnType:argTypes:!DynamicLibrary removeSelector: #primitiveBind:!DynamicLibrary removeSelector: #primitiveBindFunction:!ExternalObject removeSelector: #isNullPointer!Object subclass: #ExternalObject	instanceVariableNames: 'handle'	classVariableNames: 'Registry'	poolDictionaries: ''	category: 'FFI-Types'!ExternalFunctionError class removeSelector: #function:!ExternalFunctionError removeSelector: #function!ExternalFunctionError removeSelector: #function:!ExternalFunctionError removeSelector: #isResumable!Error subclass: #ExternalFunctionError	instanceVariableNames: 'functionName'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!Application class removeSelector: #start!Application class removeSelector: #startWithArguments:!Class removeSelector: #superclass:methodDict:format:name:organization:instVarNames:classPool:sharedPools:!ClassBuilder removeSelector: #computeFormat:instSize:forSuper:ccIndex:!ClassBuilder removeSelector: #format:variable:words:pointers:weak:!Smalltalk removeClassNamed: #SystemChangeNotifierTest!RBProgramNodeVisitor subclass: #ASTChecker	instanceVariableNames: 'scope varsChangedInSend'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!RBProgramNodeVisitor subclass: #ASTTranslator	instanceVariableNames: 'methodBuilder receiverForCascade'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #Application	instanceVariableNames: 'arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!AssembleInstruction subclass: #AssembleCMov	instanceVariableNames: ''	classVariableNames: 'Condition'	poolDictionaries: ''	category: 'Exupery'!Object subclass: #AssemblerExupery	instanceVariableNames: 'stream blockAddresses jumpOffsets bytecodes instructionEncoders plugin relocator picEntries debugCollector source'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #BlockClosure	instanceVariableNames: 'method environment'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Contexts'!PluggableGtkSimpleApplication subclass: #ClassFinder	instanceVariableNames: 'classTrait'	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!Object subclass: #ColouringRegisterAllocator	instanceVariableNames: 'source result machine interferenceGraph registerStack registerFile registerTable spiltRegisters hasSpilt coloursUsed simplifyWorklist spillWorklist moveWorklist coalescedMoves isValidating deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #DebugInfo	instanceVariableNames: 'codeSourceReferences argVarsReferences tempVarsReferences capturedVarsReferences'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!Object subclass: #EventManager	instanceVariableNames: 'actionMap'	classVariableNames: 'ActionMaps'	poolDictionaries: ''	category: 'System-Object'!Error subclass: #ExternalFunctionError	instanceVariableNames: 'functionName '	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!Object subclass: #ExternalObject	instanceVariableNames: 'handle '	classVariableNames: 'Registry '	poolDictionaries: ''	category: 'FFI-Types'!ExternalObject subclass: #DynamicLibrary	instanceVariableNames: 'name symbolCache'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!DynamicLibrary subclass: #Executable	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!ExternalObject subclass: #ExternalBuffer	instanceVariableNames: 'size'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalBuffer subclass: #AsciiZ	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!DynamicLibrary class	instanceVariableNames: 'default'!ExternalObject subclass: #ExternalObjectProxy	instanceVariableNames: 'object'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalObjectProxy subclass: #ExternalArrayProxy	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalObject subclass: #ExternalSymbol	instanceVariableNames: 'name library'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!ExternalSymbol subclass: #ExecutableFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!ExecutableFunction subclass: #CDeclFunction	instanceVariableNames: 'returnType argTypes'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Error subclass: #ExternalSymbolError	instanceVariableNames: 'symbolName'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!ExternalObject subclass: #FileDescriptor	instanceVariableNames: ''	classVariableNames: 'StandardDescriptors'	poolDictionaries: ''	category: 'FFI-Types'!Error subclass: #FileStreamException	instanceVariableNames: 'fileName'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #CannotDeleteFileException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #FileDoesNotExistException	instanceVariableNames: 'readOnly'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #FileExistsException	instanceVariableNames: 'fileClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!AssemblyCopier subclass: #FinalCopier	instanceVariableNames: 'deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!LexicalScope subclass: #FunctionScope	instanceVariableNames: 'thisContextVar thisEnvVar tempVars capturedVars isHome hasInnerFreeVars hideTemps argVars uninitializedTemps capturedParentEnv'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #GIRBuilder	instanceVariableNames: 'ir currentBlock machine relocationInfo primitiveNode literals thisEnvVar cacheMap literalTemp source start stop debugInfo'	classVariableNames: 'InlinedSelectors SpecialConstants SpecialSelectors'	poolDictionaries: ''	category: 'Compiler-IR'!LexicalScope subclass: #InstanceScope	instanceVariableNames: 'vars'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!DynamicLibrary subclass: #LibC6	instanceVariableNames: ''	classVariableNames: 'LSeekDirectives OpenFlags'	poolDictionaries: ''	category: 'FFI-Libraries'!Object subclass: #LibExample	instanceVariableNames: ''	classVariableNames: 'GETPID'	poolDictionaries: ''	category: 'Guille-Test'!DynamicLibrary subclass: #LibReadLine	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!ExternalSymbol subclass: #LibraryData	instanceVariableNames: 'type'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Object subclass: #LivenessAnalyser	instanceVariableNames: 'source hasUpdated isValidating deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #MedLanguage	instanceVariableNames: 'in out start stop'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedCMov	instanceVariableNames: 'type from to'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedEnter	instanceVariableNames: 'argument'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedLeave	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedLiteral	instanceVariableNames: 'literal'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLiteral subclass: #MedFunction	instanceVariableNames: 'block byteCodeAddress'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!ExecutableFunction subclass: #NativeFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Object subclass: #PrimitiveType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!PrimitiveType subclass: #IntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!RBProgramNode subclass: #RBReturnNode	instanceVariableNames: 'return value homeBinding frameBinding'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Nodes'!ExternalObject subclass: #ReadOnlyAsciiZ	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SemanticWarning subclass: #RedeclaredVariableWarning	instanceVariableNames: 'variableNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #RelocationInfo	instanceVariableNames: 'offset'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #ExecutableFunctionRelocation	instanceVariableNames: 'functionName'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #FunctionRelocation	instanceVariableNames: 'function'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #LiteralRelocation	instanceVariableNames: 'literals'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!ExecutableFunctionRelocation subclass: #NativeFunctionRelocation	instanceVariableNames: 'libraryName'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!NativeFunctionRelocation subclass: #ExternalFunctionRelocation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #PrimitiveRelocation	instanceVariableNames: 'number'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!Object subclass: #ScopeVar	instanceVariableNames: 'scope usage'	classVariableNames: 'UsageAutomaton'	poolDictionaries: ''	category: 'Compiler-Semantics'!ScopeVar subclass: #GlobalVar	instanceVariableNames: 'assoc'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!ScopeVar subclass: #LocalVar	instanceVariableNames: 'name index'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!LocalVar subclass: #ArgVar	instanceVariableNames: 'isArg'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!LocalVar subclass: #CapturedVar	instanceVariableNames: 'sourceTemp'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!ByteArray variableByteSubclass: #ExternalValue	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!Object subclass: #SharedPool	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Pools'!Application subclass: #Shell	instanceVariableNames: 'bindings '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!IntegerType subclass: #SignedIntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedByte	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedShortInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!Object subclass: #SourceReference	instanceVariableNames: 'sourceStart sourceStop codeStop'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!RelocationInfo subclass: #SpecialSelectorRelocation	instanceVariableNames: 'specialSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!Model subclass: #StringHolder	instanceVariableNames: 'contents'	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Kernel-Remnants'!Object subclass: #SystemTracer	instanceVariableNames: 'byteStream traceQueue oopMap nextChunk nilOop count'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Tracer'!LocalVar subclass: #TempVar	instanceVariableNames: 'isArg'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Error subclass: #TraitException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Kernel'!TraitException subclass: #TraitCompositionException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Composition'!Error subclass: #TypeConvertionError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!FileStream subclass: #UnbufferedFileStream	instanceVariableNames: 'name fileID'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!Smalltalk renameClassNamed: #BufferedFileStream2 as: #BufferedFileStream!UnbufferedFileStream subclass: #BufferedFileStream	instanceVariableNames: ''	classVariableNames: 'DefaultBufferSize'	poolDictionaries: ''	category: 'Files-Kernel'!BufferedFileStream subclass: #BinaryFileStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!BufferedFileStream subclass: #TextFileStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!IntegerType subclass: #UnsignedIntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedByte	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedShortInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SemanticWarning subclass: #UnusedVariableWarning	instanceVariableNames: 'variableNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #VarReference	instanceVariableNames: 'name'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!RelocationInfo subclass: #VariableRelocation	instanceVariableNames: 'variable'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!PluggableGtkSimpleApplication subclass: #Workspace	instanceVariableNames: 'workspaceView'	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!Workspace subclass: #TranscriptCodeEditor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!!Object methodsFor: 'as yet unclassified'!errorSubscriptBounds: index 	"Create an error notification that an improper integer was used as an index."	self error: 'subscript is out of bounds: ' , index printString! !!Object methodsFor: 'as yet unclassified'!executeMethod: compiledMethod withArgs: argArray	"Execute compiledMethod against the receiver and args in argArray"	| selector |	<primitive: 188>	selector _ Symbol new.	self class addSelectorSilently: selector withMethod: compiledMethod.	^ [self perform: selector withArguments: argArray]		ensure: [self class basicRemoveSelector: selector]! !!Object methodsFor: 'as yet unclassified'!withArgs: argArray executeMethod: compiledMethod	"For compatibility with Aqueak"	self executeMethod: compiledMethod withArgs: argArray! !!Application methodsFor: 'as yet unclassified'!arguments	^ arguments.! !!Application methodsFor: 'as yet unclassified'!arguments: anArray	arguments := anArray.! !!Application methodsFor: 'as yet unclassified'!main	self subclassResponsibility.! !!Application methodsFor: 'as yet unclassified'!startUp	Smalltalk startUp.	^ self main.! !!Behavior methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return true if it is safe to zap the method dictionary on #obsolete"	^true! !!Behavior methodsFor: 'as yet unclassified'!isWeak	^ (format bitAnd: 4) = 1.! !!Behavior methodsFor: 'as yet unclassified'!obsolete	"Invalidate and recycle local methods,	e.g., zap the method dictionary if can be done safely."	self canZapMethodDictionary		ifTrue: [self methodDict: self emptyMethodDictionary].! !!Behavior methodsFor: 'as yet unclassified'!removeSelector: selector	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method."	| oldMethod |		oldMethod _ self methodDict at: selector ifAbsent: [^ self].	self methodDict removeKey: selector.	"Now flush Squeak's method cache, either by selector or by method"	oldMethod flushCache.	selector flushCache! !!Behavior methodsFor: 'as yet unclassified'!selectorsAndMethodsDo: aBlock	"Evaluate selectorBlock for all the message selectors in my method dictionary."	^ self methodDict keysAndValuesDo: aBlock! !!Behavior methodsFor: 'as yet unclassified'!setTraitComposition: aTraitComposition	| oldComposition |	(self hasTraitComposition not and: [aTraitComposition isEmpty]) ifTrue: [^self].	aTraitComposition assertValidUser: self.	oldComposition _ self traitComposition.	self traitComposition: aTraitComposition."	self applyChangesOfNewTraitCompositionReplacing: oldComposition."		oldComposition traits do: [:each | each removeUser: self].	aTraitComposition traits do: [:each | each addUser: self]! !!Behavior methodsFor: 'as yet unclassified'!traitCompositionString	^self hasTraitComposition		ifTrue: [self traitComposition asString]		ifFalse: ['{}']! !!Behavior methodsFor: 'as yet unclassified'!typeOfClass	"Answer a symbol uniquely describing the type of the receiver"	self isWeak ifTrue: [ ^ #weak ].	^ (format bitAnd: 3) caseOf: {		[ 0 ] -> [ #normal ].		[ 1 ] -> [ #variable ].		[ 2 ] -> [ #bytes ].		[ 3 ] -> [ #words ]	}! !!Behavior methodsFor: 'as yet unclassified'!whichSelectorsReferTo: literal	"Answer a set of selectors whose methods access the argument as a literal."	| who |	who _ IdentitySet new.	self selectorsAndMethodsDo: 		[:sel :method |		(method hasLiteral: literal)			ifTrue:				[((literal isVariableBinding) not					or: [method literals allButLast includes: literal])						ifTrue: [who add: sel]]].	^ who! !!BehaviorTest methodsFor: 'as yet unclassified'!testBehaviorSubclasses	"self run: #testBehaviorSubclasses"		| b b2 |"	b := Behavior new.	b superclass: OrderedCollection.	b methodDictionary: Dictionary new.	self shouldnt: [b subclasses ] raise: Error.	self shouldnt: [b withAllSubclasses] raise: Error.	self shouldnt: [b allSubclasses] raise: Error.	b2 := Behavior new.	b2 superclass: b.	b2 methodDictionary: Dictionary new.	self assert: (b subclasses includes: b2).	self assert: (b withAllSubclasses includes: b)."! !!BlockClosure methodsFor: 'as yet unclassified'!valueWithArguments: anArray 	"Evaluate the block with given args. Fail if the block expects other than the given number of arguments."	^ environment executeMethod: method withArgs: anArray ! !!ClassBrowser methodsFor: 'as yet unclassified'!buildClassCategoriesView	| model tree col cell |	tree := nil->nil.	SystemOrganization categories do: [ :each |		| category |		category := tree.		(each subStrings: '-') do: [ :cat |			category value ifNil: [ category value: Dictionary new].			category := category value associationAt: cat ifAbsent: [ category value at: cat put: nil. category value associationAt: cat ]		]	].	model := GtkTreeStore new: {String. String}.	[ self addSubcategoriesFrom: tree fromIter: nil inModel: model ] fork.	classCategoriesTree := GtkTreeView model: model.	col := GtkTreeViewColumn title: 'Class categories'.	cell := GtkCellRendererPixbuf new.	col		packStart: cell expand: false;		addAttribute: #stockId column: 1 on: cell.	cell := GtkCellRendererText new.	col		packStart: cell;		addAttribute: #text column: 0 on: cell.		classCategoriesTree appendColumn: col.	classCategoriesTree selection when: #changed send: #onClassCategoryChanged to: self.	classCategoriesTree enableTreeLines: true.	^ GtkScrolledWindow withChild: classCategoriesTree! !!ClassBrowser methodsFor: 'as yet unclassified'!loadClassMethodsOf: aClassClass	| iter |	classMethodsTree model clear.	aClassClass organization categories do: [ :cat |		iter := classMethodsTree model append: nil->{cat asString. true. 'grey'. 'gtk-info'}.		(aClassClass organization listAtCategoryNamed: cat) asSortedCollection do: [ :sel |			classMethodsTree model append: iter->{sel asString. false. 'grey'. 'gtk-execute'}		]	].	classMethodsTree expandAll.! !!ClassBrowser methodsFor: 'as yet unclassified'!loadInstanceMethodsOf: aClass	| iter |	instanceMethodsTree model clear.	aClass organization categories do: [ :cat |		iter := instanceMethodsTree model append: nil->{cat asString. true. 'grey'. 'gtk-info'}.		(aClass organization listAtCategoryNamed: cat) asSortedCollection do: [ :sel |			instanceMethodsTree model append: iter->{sel asString. false. 'grey'. 'gtk-execute'}		]	].	instanceMethodsTree expandAll.! !!ClassBrowser methodsFor: 'as yet unclassified'!onClassHierarchyChanged	| class iter path newIter aCategory classHierarchySelectedRow classesTreeSelectedRow |	classHierarchySelectedRow := classHierarchyTree selectedRow.	classHierarchySelectedRow ifNotNil: [		class := Smalltalk at: (classHierarchySelectedRow first asSymbol).							aCategory := class category.		( aCategory isNotNil and: [ aCategory ~= selectedClassCategory ] ) ifTrue: [			selectedClassCategory := aCategory.			iter := classCategoriesTree model firstIter.			newIter := nil.			(aCategory subStrings: '-') do: [ :cat |				newIter ifNotNil: [ iter := newIter ].				iter := self classCategoryFor: cat firstIter: iter.				newIter := classCategoriesTree model firstChildAt: iter.			].			path := classCategoriesTree model pathFromIter: iter.			classCategoriesTree expandRowsUpTo: path.			classCategoriesTree moveCursorAt: path.					classesTree model clear.			(SystemOrganization listAtCategoryNamed: aCategory) sort do: [ :ea |				classesTree model append: {ea asString. 'gtk-execute'}			]		].							self selectClass: class.	]! !!ClassBuilder methodsFor: 'as yet unclassified'!formatForType: type	^ type caseOf: {		[ #normal ] -> [ 0 ].		[ #variable ] -> [ 1 ].		[ #bytes ] -> [ 2 ].		[ #words ] -> [ 3 ].		[ #weak ] -> [ 5 "binary: 4 + 0 + 0 + 1" ]	} otherwise: [ self error: 'Unknown class type' ].! !!ClassBuilder methodsFor: 'as yet unclassified'!needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Answer whether we need a new subclass to conform to the requested changes"	"Check if we really need a new subclass"	oldClass ifNil:[^true]. "yes, it's a new class"	newSuper == oldClass superclass ifFalse:[^true]. "yes, it's a superclass change"	type = oldClass typeOfClass ifFalse:[^true]. "yes, it's a format change"	instVars = oldClass instVarNames ifFalse:[^true]. "yes, it's an iVar change"	^false! !!ClassBuilder methodsFor: 'as yet unclassified'!newSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Create a new subclass of the given superclass with the given specification."	| newClass |	(oldClass == nil or:[oldClass isMeta not]) 		ifTrue:[newClass := self privateNewSubclassOf: newSuper from: oldClass]		ifFalse:[newClass := oldClass clone].	newClass 		superclass: newSuper		methodDictionary: "Method"Dictionary new		instanceSize: (newSuper instSize + instVars size)		format: (self formatForType: type);		setInstVarNames: instVars.	oldClass ifNotNil:[		newClass organization: oldClass organization.		"Recompile the new class"		oldClass hasMethods 			ifTrue:[newClass compileAllFrom: oldClass].		oldClass hasTraitComposition ifTrue: [			newClass setTraitComposition: oldClass traitComposition copyTraitExpression ].		oldClass class hasTraitComposition ifTrue: [			newClass class setTraitComposition: oldClass class traitComposition copyTraitExpression ].				self recordClass: oldClass replacedBy: newClass.	].	(oldClass == nil or:[oldClass isObsolete not]) 		ifTrue:[newSuper addSubclass: newClass]		ifFalse:[newSuper addObsoleteSubclass: newClass].	^newClass! !!ClassBuilder methodsFor: 'as yet unclassified'!privateNewSubclassOf: newSuper from: oldClass	"Create a new meta and non-meta subclass of newSuper using oldClass as template"	"WARNING: This method does not preserve the superclass/subclass invariant!!"	| newSuperMeta oldMeta newMeta |	oldClass ifNil:[^self privateNewSubclassOf: newSuper].	newSuperMeta _ newSuper ifNil:[Class] ifNotNil:[newSuper class].	oldMeta _ oldClass class.	newMeta _ oldMeta clone.	newMeta 		superclass: newSuperMeta		methodDictionary: "Method"Dictionary new		instanceSize: oldMeta instSize		format: oldMeta format;		setInstVarNames: oldMeta instVarNames;		organization: oldMeta organization.	"Recompile the meta class"	oldMeta hasMethods 		ifTrue:[newMeta compileAllFrom: oldMeta].	"Record the meta class change"	self recordClass: oldMeta replacedBy: newMeta.	"And create a new instance"	^newMeta adoptInstance: oldClass from: oldMeta! !!ClassBuilder methodsFor: 'as yet unclassified'!reshapeClass: oldClass toSuper: newSuper	"Reshape the given class to the new super class. Recompile all the methods in the newly created class. Answer the new class."	| instVars |	instVars _ instVarMap at: oldClass name ifAbsent:[oldClass instVarNames].	^self newSubclassOf: newSuper 			type: oldClass typeOfClass 			instanceVariables: instVars 			from: oldClass! !!ClassDescription methodsFor: 'as yet unclassified'!classVersion	"Default.  Any class may return a later version to inform readers that use ReferenceStream.  8/17/96 tk"	"This method allows you to distinguish between class versions when the shape of the class 	hasn't changed (when there's no change in the instVar names).	In the conversion methods you usually can tell by the inst var names 	what old version you have. In a few cases, though, the same inst var 	names were kept but their interpretation changed (like in the layoutFrame).	By changing the class version when you keep the same instVars you can 	warn older and newer images that they have to convert."	^ 0! !!ClassDescription methodsFor: 'as yet unclassified'!obsolete	"Make the receiver obsolete."	superclass removeSubclass: self.	self organization: nil.	super obsolete.! !!ClassDescription methodsFor: 'as yet unclassified'!removeSelector: selector 	"Remove the message whose selector is given from the method 	dictionary of the receiver, if it is there. Answer nil otherwise."		| priorMethod priorProtocol | 	priorMethod _ self compiledMethodAt: selector ifAbsent: [^ nil].	priorProtocol _ self whichCategoryIncludesSelector: selector.	SystemChangeNotifier uniqueInstance		doSilently: [self organization removeElement: selector ].	super removeSelector: selector.	SystemChangeNotifier uniqueInstance 			methodRemoved: priorMethod selector: selector inProtocol: priorProtocol class: self.! !!ClassDescription methodsFor: 'as yet unclassified'!updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil	| currentCategory effectiveCategory sel changedCategories composition |	changedCategories _ IdentitySet new.	composition := self hasTraitComposition		ifTrue: [self traitComposition]		ifFalse: [TraitComposition new].	(composition methodDescriptionsForSelector: aSymbol) do: [:each |		sel _ each selector.		(self includesLocalSelector: sel) ifFalse: [			currentCategory _ self organization categoryOfElement: sel.			effectiveCategory _ each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.			effectiveCategory isNil ifTrue: [				currentCategory ifNotNil: [changedCategories add: currentCategory].				self organization removeElement: sel.			] ifFalse: [				((currentCategory isNil or: [currentCategory == ClassOrganizer ambiguous or: [currentCategory == oldCategoryOrNil]]) and: [currentCategory ~~ effectiveCategory]) ifTrue: [					currentCategory ifNotNil: [changedCategories add: currentCategory].					self organization 						classify: sel 						under: effectiveCategory						suppressIfDefault: false]]]].	^ changedCategories! !!ClassDescription methodsFor: 'as yet unclassified'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	(self includesSelector: aSelector)		ifTrue: [^ self organization categoryOfElement: aSelector]		ifFalse: [^nil]! !!Class methodsFor: 'as yet unclassified'!classPool: aDictionary	classPool _ aDictionary! !!Class methodsFor: 'as yet unclassified'!copy 	| newClass |	newClass _ self class copy new		superclass: superclass		methodDict: self methodDict copy		instanceSize: self instSize		format: format		name: name		organization: self organization copy		instVarNames: instanceVariables copy		classPool: classPool copy		sharedPools: sharedPools.	Class instSize+1 to: self class instSize do:		[:offset | newClass instVarAt: offset put: (self instVarAt: offset)].	^ newClass! !!Class methodsFor: 'as yet unclassified'!deactivate	"A remnant from the 3.3a modules work, retained . Does nothing, but may be overridden in Metaclasses."! !!Class methodsFor: 'as yet unclassified'!isSystemDefined	"Answer true if the receiver is a system-defined class, and not a UniClass (an instance-specific lightweight class)"	^ self == self officialClass! !!Class methodsFor: 'as yet unclassified'!obsolete	"Change the receiver and all of its subclasses to an obsolete class."	self == Object 		ifTrue: [^self error: 'Object is NOT obsolete'].	self setName: 'AnObsolete' , self name.	Object class instSize + 1 to: self class instSize do:		[:i | self instVarAt: i put: nil]. "Store nil over class instVars."	self classPool: nil.	self sharedPools: nil.	self class obsolete.	super obsolete.! !!Class methodsFor: 'as yet unclassified'!officialClass	"I am not a UniClass.  (See Player officialClass).  Return the class you use to make new subclasses."	^ self! !!Class methodsFor: 'as yet unclassified'!removeFromSystem	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."	self removeFromSystem: true.! !!Class methodsFor: 'as yet unclassified'!removeFromSystem: logged	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."		"keep the class name and category for triggering the system change message. If we wait to long, then we get obsolete information which is not what we want."	"tell class to deactivate and unload itself-- two separate events in the module system"	self deactivate; unload.	self superclass ifNotNil:		["If we have no superclass there's nothing to be remembered"		self superclass addObsoleteSubclass: self].	self environment forgetClass: self logged: logged.	self obsolete.! !!Class methodsFor: 'as yet unclassified'!sharedPools: aCollection	sharedPools _ aCollection! !!Class methodsFor: 'as yet unclassified'!superclass: sup methodDict: md instanceSize: is format: ft name: nm organization: org instVarNames: nilOrArray classPool: pool sharedPools: poolSet 	"Answer an instance of me, a new class, using the arguments of the 	message as the needed information.	Must only be sent to a new instance; else we would need Object flushCache."	superclass := sup.	methodDict := md.	instanceSize := is.	format := ft.	name := nm.	instanceVariables := nilOrArray.	classPool := pool.	sharedPools := poolSet.	self organization: org.! !!Class methodsFor: 'as yet unclassified'!unload	"Sent when a the class is removed.  Does nothing, but may be overridden by (class-side) subclasses."! !!Class methodsFor: 'as yet unclassified'!variableByteSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable byte-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableByteSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!variableSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable pointer variables."	^(ClassBuilder new)		superclass: self		variableSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!variableWordSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable word-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableWordSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!weakSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have weak indexable pointer variables."	^(ClassBuilder new)		superclass: self		weakSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!AppLauncher class methodsFor: 'as yet unclassified'!openAboutHuemul	| dlg logo |	logo := GdkPixbuf fromFile: 'Huemul.jpg'.	dlg := GtkAboutDialog new.	dlg		aboutDialogName: 'Huemul Smalltalk';		version: '0.8';		license: (StandardFileStream readOnlyFileNamed: 'LICENSE') upToEnd;		website: 'http://www.guillermomolina.com.ar/huemul';		comments: 'This is Huemul Smalltalk';		authors: {'Guillermo Adrian Molina'};		logo: logo.	dlg runAndDestroy! !!AppLauncher class methodsFor: 'as yet unclassified'!openWorkspace	^ Workspace open! !!Application class methodsFor: 'as yet unclassified'!startUp	^ self new startUp.! !!Application class methodsFor: 'as yet unclassified'!startUpWithArguments: arguments	| application |	application := self new.	application arguments: arguments.	^ application startUp.! !!Behavior class methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return false since zapping the method dictionary of Behavior class or its subclasses will cause the system to fail."	^false! !!ClassBrowser class methodsFor: 'as yet unclassified'!defaultSize	^ 640@480.! !!ClassBrowser class methodsFor: 'as yet unclassified'!title	^'Class browser'! !!ClassFinder class methodsFor: 'as yet unclassified'!defaultSize	^ 200@300.! !!ClassFinder class methodsFor: 'as yet unclassified'!title	^'Class finder'! !!CompiledMethod methodsFor: 'as yet unclassified'!hasLiteral: literal	"Answer whether the receiver references the argument, literal."	literals ifNil: [ ^false ].	^ literals hasLiteral: literal.! !!CompiledMethod methodsFor: 'as yet unclassified'!sourcePointer	"Answer the integer which can be used to find the source file and position for this method.	Not sources yet"	^ 0! !!CompiledMethodWithNode class methodsFor: 'as yet unclassified'!method: aCompiledMethod node: aMethodNode	^ self new method: aCompiledMethod; node: aMethodNode.! !!Compiler methodsFor: 'as yet unclassified'!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into a method. In other words, if receiver is not nil, then the text can refer to instance variables of that receiver (the Inspector uses this). If aContext is not nil, the text can refer to temporaries in that context (the Debugger uses this). If aRequestor is not nil, then it will receive a notify:at: message before the attempt to evaluate is aborted. Finally, the compiled method is directly invoked without modifying the receiving-class."	"| methodNode method value |	  	(Preferences compileUseNewCompiler or: 			[aContext ifNotNil: [aContext method isClosureCompiled] ifNil: [false]]) ifTrue: 				[^ self evaluate2: textOrStream 					    in: aContext 					    to: receiver 					    notifying: aRequestor 					    ifFail: failBlock 					    logged: logFlag].		class := (aContext isNil 		ifTrue: [ receiver ] 		ifFalse: [ aContext receiver ])			class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode := self 		translate: sourceStream		noPattern: true 		ifFail: [ ^ failBlock value ].	method := methodNode generate.	self interactive		ifTrue: [ method := method copyWithTempNames: methodNode tempNames ].	value := receiver		executeMethod: method 		withArgs: (context isNil			ifTrue: [ #() ]			ifFalse: [ Array with: aContext ]).	logFlag 		ifTrue: [ SystemChangeNotifier uniqueInstance evaluated: sourceStream contents context: aContext ].	^ value."	| string block |	string _ textOrStream readStream upToEnd.	block := self compileDoIt: string in: aContext to: receiver notifying: aRequestor ifFail: [^ failBlock value] log: logFlag.	^ block value! !!Exception methodsFor: 'as yet unclassified'!messageText	messageText ifNil: [ ^ self class name asString ].	^messageText! !!Exception methodsFor: 'as yet unclassified'!receiver	^ self signalerContext receiver! !!ExternalFunctionError methodsFor: 'as yet unclassified'!functionName	"Answer the function name that was beiing used."	^functionName! !!ExternalFunctionError methodsFor: 'as yet unclassified'!functionName: argument	"Specify the function name that was beiing used."	functionName := argument! !!ExternalFunctionError class methodsFor: 'as yet unclassified'!functionName: argument	^self new functionName: argument; yourself! !!ExternalObject methodsFor: 'as yet unclassified'!= anObject 	(anObject isKindOf: self class)		ifTrue: [^ anObject handle = self handle]		ifFalse: [^ false]! !!ExternalObject methodsFor: 'as yet unclassified'!beNull	^ handle beNull.! !!ExternalObject methodsFor: 'as yet unclassified'!finalize		self free.	self unregister.! !!ExternalObject methodsFor: 'as yet unclassified'!free	"Should override this"! !!ExternalObject methodsFor: 'as yet unclassified'!initialize	handle := self class defaultHandlerClass new.	self register.! !!ExternalObject methodsFor: 'as yet unclassified'!isNull	^ self handle isNull.! !!ExternalObject methodsFor: 'as yet unclassified'!register	Registry add: self.! !!ExternalObject methodsFor: 'as yet unclassified'!unregister		Registry remove: self ifAbsent:[  ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!addSymbol: anExternalSymbol	^ symbolCache at: anExternalSymbol name put: anExternalSymbol.! !!DynamicLibrary methodsFor: 'as yet unclassified'!bindSymbol: anExternalSymbol	self open.	^ self primitiveBindSymbol: anExternalSymbol.! !!DynamicLibrary methodsFor: 'as yet unclassified'!cDeclFunctionNamed: functionName	^ symbolCache at: functionName ifAbsent: [ self error: 'You must initialize the function before using it' ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!close		handle isNull ifFalse: [ 		self primitiveClose		handle beNull.	].! !!DynamicLibrary methodsFor: 'as yet unclassified'!initialize	super initialize.	symbolCache := Dictionary new.! !!DynamicLibrary methodsFor: 'as yet unclassified'!initializeCDeclFunctionNamed: functionName returnType: retType argTypes: argTypesArray	^ symbolCache at: functionName put: 			(CDeclFunction name: functionName library: self  returnType: retType argTypes: argTypesArray)! !!DynamicLibrary methodsFor: 'as yet unclassified'!initializeLibraryDataNamed: symbolName type: type	^ symbolCache at: symbolName put: (LibraryData name: symbolName library: self  type: type)! !!DynamicLibrary methodsFor: 'as yet unclassified'!libraryDataNamed: symbolName	^ symbolCache at: symbolName ifAbsent: [ self error: 'You must initialize the symbol before using it' ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!name	^name! !!DynamicLibrary methodsFor: 'as yet unclassified'!name: aName	name := aName.! !!DynamicLibrary methodsFor: 'as yet unclassified'!nativeFunctionNamed: functionName	^ symbolCache at: functionName ifAbsent: [ 		symbolCache at: functionName put: (NativeFunction name: functionName library: self)	].! !!DynamicLibrary methodsFor: 'as yet unclassified'!open		handle isNull ifTrue: [ self primitiveOpen ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveBindSymbol: anExternalSymbol	"Primitive. Find the given symbol in the library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 203>	^ anExternalSymbol throwNotKnownError.! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveClose	"Primitive. Close the given library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 202>! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveOpen	"Primitive. Open the given library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 198>	self primitiveFailed.! !!DynamicLibrary methodsFor: 'as yet unclassified'!printOn: aStream	aStream nextPutAll: self name.! !!DynamicLibrary methodsFor: 'as yet unclassified'!symbolNamed: symbolName	^ symbolCache at: symbolName ifAbsent: [ self error: 'You must initialize the symbol before using it' ]! !!Executable methodsFor: 'as yet unclassified'!name	^ Utilities executableName ! !!Executable methodsFor: 'as yet unclassified'!primitiveSmallIntegerAdd: receiver with: argument	^ (self nativeFunctionNamed: #primitiveSmallIntegerAdd) invokeReceiver: receiver with: argument.! !!ExternalBuffer methodsFor: 'as yet unclassified'!asByteArray	| array |	size ifNil: [ ^ self class throwTypeConvertionError ].	array := ByteArray new: self basicSize.	self storeInto: array.	^ array	! !!ExternalBuffer methodsFor: 'as yet unclassified'!atAllPut: constant	^ LibC6 default memSet: self constant: constant count: self size.! !!ExternalBuffer methodsFor: 'as yet unclassified'!atAllPutZero	^ self atAllPut: 0.! !!ExternalBuffer methodsFor: 'as yet unclassified'!basicSize	^ size.! !!ExternalBuffer methodsFor: 'as yet unclassified'!byteAt: index	<primitive: 190>	index isNumber		ifTrue: [self errorSubscriptBounds: index]		ifFalse: [self errorNonIntegerIndex].! !!ExternalBuffer methodsFor: 'as yet unclassified'!byteAt: index put: value	<primitive: 191>	index isNumber		ifTrue: [self errorSubscriptBounds: index]		ifFalse: [self errorNonIntegerIndex].! !!ExternalBuffer methodsFor: 'as yet unclassified'!free		handle isNull ifFalse: [ 		LibC6 default free: self.		self beNull.	]! !!ExternalBuffer methodsFor: 'as yet unclassified'!loadFrom: aByteArray	<primitive: 199>	self primitiveFailed.! !!ExternalBuffer methodsFor: 'as yet unclassified'!size	^ self basicSize.! !!ExternalBuffer methodsFor: 'as yet unclassified'!size: anInteger	size := anInteger.! !!ExternalBuffer methodsFor: 'as yet unclassified'!storeInto: aByteArray	<primitive: 218>	^ self class throwTypeConvertionError.! !!AsciiZ methodsFor: 'as yet unclassified'!asString	^ handle toString.! !!AsciiZ methodsFor: 'as yet unclassified'!asString2	| calcSize string |	size ifNil: [ ^ self class throwTypeConvertionError ].	calcSize := self strlen.	calcSize >= self size ifTrue: [ ^ self class throwTypeConvertionError ].	string := String new: calcSize.	self storeInto: string.	^ string! !!AsciiZ methodsFor: 'as yet unclassified'!loadFrom: aString		super loadFrom: aString.	self byteAt: (aString size + 1) put: 0.! !!AsciiZ methodsFor: 'as yet unclassified'!strlen	^ LibC6 default strLen: self.! !!ExternalFunction methodsFor: 'as yet unclassified'!library	^ library! !!ExternalFunction methodsFor: 'as yet unclassified'!library: aLibrary	library := aLibrary! !!ExternalFunction methodsFor: 'as yet unclassified'!name	^name! !!ExternalFunction methodsFor: 'as yet unclassified'!name: aName	name := aName! !!ExternalFunction methodsFor: 'as yet unclassified'!name: aName library: aLibrary	self name: aName.	self library: aLibrary! !!ExternalFunction methodsFor: 'as yet unclassified'!reload	library ifNil: [ ^ self throwNotKnownError ].	self handle: (library findFunction: self)! !!ExternalLibrary methodsFor: 'as yet unclassified'!bindFunction: function	| answer |	answer := self primitiveBindFunction: function.	answer ifNotNil: [ ^ answer ].	self open. "Library may be closed, open it and retry"	answer := self primitiveBindFunction: answer.	answer ifNotNil: [ ^ answer ].	^ function throwNotKnownError.		! !!ExternalLibrary methodsFor: 'as yet unclassified'!closeLibrary		(handle isNotNil and: [ handle isNull not ]) ifTrue: [ self primitiveClose ].	self handle: nil.	functionCache := nil.! !!ExternalLibrary methodsFor: 'as yet unclassified'!openLibrary		self primitiveOpen.	self initializeFunctionCache.! !!ExternalLibrary methodsFor: 'as yet unclassified'!primitiveBindFunction: function	"Primitive. Find the given symbol in the library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 203>	^ nil.! !!ExternalObject class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: self! !!ExternalObject class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalAddress! !!ExternalObject class methodsFor: 'as yet unclassified'!handleFromObject: anObject	^ self handleFromObject: anObject ifError: [ self throwTypeConvertionError ]! !!ExternalObject class methodsFor: 'as yet unclassified'!handleFromObject: anObject ifError: aBlock		(anObject isKindOf: ExternalObject) ifFalse: [ ^ aBlock value ].	^ anObject handle.	! !!ExternalObject class methodsFor: 'as yet unclassified'!initialize	Registry := WeakRegistry new.	Smalltalk addToShutDownList: self.! !!ExternalObject class methodsFor: 'as yet unclassified'!objectFromHandle: handle	^self objectFromHandle: handle ifError: [ self throwTypeConvertionError ]! !!ExternalObject class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; yourself! !!ExternalObject class methodsFor: 'as yet unclassified'!quit	Registry do: [ :each | each free ].	self allSubclassesDo: [ :ea | ea quit ]! !!ExternalObject class methodsFor: 'as yet unclassified'!shutDown: quitting	quitting ifTrue: [ self quit ].! !!ExternalObject class methodsFor: 'as yet unclassified'!throwTypeConvertionError	^ TypeConvertionError new signal! !!DynamicLibrary class methodsFor: 'as yet unclassified'!default	self = DynamicLibrary ifTrue: [ self error: 'Create a class to create its singleton' ].	default ifNil: [	"Represents the executable itself"		default := self new.		default name: self moduleName.		default open.	].	^ default.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!initialize	self = DynamicLibrary ifFalse: [ 		Smalltalk addToShutDownList: self	].! !!DynamicLibrary class methodsFor: 'as yet unclassified'!moduleName	self subClassResponsibility.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!resetLibrary	default := nil.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!shutDown: aBool	default ifNotNil: [ default close ].! !!Executable class methodsFor: 'as yet unclassified'!huemul	^ self default! !!Executable class methodsFor: 'as yet unclassified'!moduleName	^nil.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: ByteArray! !!ExternalBuffer class methodsFor: 'as yet unclassified'!fromByteArray: aByteArray	| anExternalBuffer |		anExternalBuffer := ExternalBuffer new: aByteArray size.	anExternalBuffer setFrom: aByteArray.	^ anExternalBuffer.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!handleFromObject: aByteArray ifError: aBlock		(aByteArray isKindOf: ByteArray) ifFalse: [ 		^ super handleFromObject: aByteArray ifError: aBlock	].	^ ( self fromByteArray: aByteArray ) handle.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!new: size	| anExternalBuffer |	"This space is allocated from the system not 	from Object Memory, you will have to give it back, 	as it is not garbage collected"	anExternalBuffer := LibC6 default malloc: (size +  10).	anExternalBuffer size: size.	^ anExternalBuffer! !!AsciiZ class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: String! !!AsciiZ class methodsFor: 'as yet unclassified'!fromString: aString	| anAsciiZ |		anAsciiZ := AsciiZ new: aString size + 1.	anAsciiZ loadFrom: aString.	^ anAsciiZ.! !!AsciiZ class methodsFor: 'as yet unclassified'!handleFromObject: aString ifError: aBlock		(aString isKindOf: String) ifFalse: [ 		^ super handleFromObject: aString ifError: aBlock	].	^ ( self fromString: aString ) handle.! !!AsciiZ class methodsFor: 'as yet unclassified'!new: size	| buffer asciiZ |	buffer := super new: size.	asciiZ := AsciiZ new handle: buffer handle.	asciiZ size: size.	asciiZ atAllPutZero.	buffer handle: ExternalAddress nullPointer.	^ asciiZ! !!AsciiZ class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; asString! !!ExternalFunction class methodsFor: 'as yet unclassified'!name: aName library: aLibrary	^self new name: aName library: aLibrary! !!ExternalLibrary class methodsFor: 'as yet unclassified'!huemul	Huemul ifNil: [	"Represents the executable itself"		Huemul := self new.		Huemul open.	].	^ Huemul.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!handle	self object ifNil: [ handle beNull ].	^ handle.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!initialize	super initialize.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!initializePointer	self handle forObject: self object.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!object	^ self objectPointer at: 1! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!object: anObject	self objectPointer at: 1 put: anObject.	self initializePointer.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!objectPointer	object ifNil: [ object := WeakArray new: 1 ].	^ object! !!ExternalArrayProxy methodsFor: 'as yet unclassified'!initializePointer	self handle forArray: self object.! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!fromObject: anObject		^ self new object: anObject; yourself! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!handleFromObject: anObject ifError: aBlock		^ ( self fromObject: anObject ) handle.! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		^ aBlock value! !!ExternalSymbol methodsFor: 'as yet unclassified'!address	handle isNull ifTrue: [ self bind ].	^ handle.! !!ExternalSymbol methodsFor: 'as yet unclassified'!bind	^ library bindSymbol: self.! !!ExternalSymbol methodsFor: 'as yet unclassified'!classFromType: aType	^ Smalltalk at: aType ifAbsent: [ self throwExternalSymbolError ].! !!ExternalSymbol methodsFor: 'as yet unclassified'!library	^ library! !!ExternalSymbol methodsFor: 'as yet unclassified'!library: aLibrary	library := aLibrary! !!ExternalSymbol methodsFor: 'as yet unclassified'!libraryName	^ library name.! !!ExternalSymbol methodsFor: 'as yet unclassified'!name	^name! !!ExternalSymbol methodsFor: 'as yet unclassified'!name: aName	name := aName! !!ExternalSymbol methodsFor: 'as yet unclassified'!name: aName library: aLibrary	self name: aName.	self library: aLibrary! !!ExternalSymbol methodsFor: 'as yet unclassified'!throwExternalSymbolError	^(ExternalSymbolError symbolName: name) signal.! !!ExternalSymbol methodsFor: 'as yet unclassified'!throwNotKnownError	^(ExternalSymbolError symbolName: name) signal.! !!ExecutableFunction methodsFor: 'as yet unclassified'!callingConventionString	self subclassResponsibility.! !!CDeclFunction methodsFor: 'as yet unclassified'!argTypes: anArrayOfTypes	argTypes := anArrayOfTypes.! !!CDeclFunction methodsFor: 'as yet unclassified'!callingConventionString	^ 'cdecl'! !!CDeclFunction methodsFor: 'as yet unclassified'!invoke	^self invokeWithArguments: #()! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1	^self invokeWithArguments: (Array with: arg1)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2	^self invokeWithArguments: (Array with: arg1 with: arg2)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4 with: arg5	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWithArguments: argArray	| argSize argHandleArray returnClass returnHandle |	argSize := argArray size.	argSize = argTypes size ifFalse: [ self throwExternalFunctionError ].	argHandleArray := Array new: argSize.	1 to: argSize do: [ :i |		| argType argClass argHandle arg |		argType := argTypes at: i.		argClass := self classFromType: argType.		arg := argArray at: i.		argHandle := argClass handleFromObject: arg.		argHandleArray at: i put: argHandle.	].	returnHandle := nil.	returnType = #Void ifFalse: [		returnClass := self classFromType: returnType.		returnHandle := returnClass defaultHandlerClass new.	].	handle isNull ifTrue: [ self bind ].	self primInvokeAnswering: returnHandle withArguments: argHandleArray.	returnType = #Void ifTrue: [ ^ nil ].	^ returnClass objectFromHandle: returnHandle.! !!CDeclFunction methodsFor: 'as yet unclassified'!primInvokeAnswering: aReturnValue withArguments: argArray	"Manually invoke the receiver, representing an external function."	<primitive: 204>	^self primitiveFailed! !!CDeclFunction methodsFor: 'as yet unclassified'!returnType: aType	returnType := aType.! !!CDeclFunction methodsFor: 'as yet unclassified'!returnType: aType argTypes: anArrayOfTypes	self returnType: aType.	self argTypes: anArrayOfTypes.! !!ExternalSymbol class methodsFor: 'as yet unclassified'!name: aName library: aLibrary	^self new name: aName library: aLibrary; bind! !!CDeclFunction class methodsFor: 'as yet unclassified'!name: aName library: aLibrary returnType: retType argTypes: argTypesArray	^self new name: aName library: aLibrary;		 returnType: retType argTypes: argTypesArray;		bind! !!ExternalSymbolError methodsFor: 'as yet unclassified'!isResumable	"Determine whether an exception is resumable."	^true! !!ExternalSymbolError methodsFor: 'as yet unclassified'!symbolName	^ symbolName! !!ExternalSymbolError methodsFor: 'as yet unclassified'!symbolName: argument	"Specify the function name that was beiing used."	symbolName := argument! !!ExternalSymbolError class methodsFor: 'as yet unclassified'!symbolName: argument	^self new symbolName: argument; yourself! !!FileDescriptor methodsFor: 'as yet unclassified'!close		self fileDescriptor > 2 ifTrue: [ 		LibC6 default close: self.		self fileDescriptor: -1.	]! !!FileDescriptor methodsFor: 'as yet unclassified'!fileDescriptor	^ SignedInteger objectFromHandle: handle. ! !!FileDescriptor methodsFor: 'as yet unclassified'!fileDescriptor: anInteger	handle := SignedInteger handleFromObject: anInteger. ! !!FileDescriptor methodsFor: 'as yet unclassified'!free		self close.! !!FileDescriptor methodsFor: 'as yet unclassified'!movePosition: offset"relative to actual position"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_CUR' ).	! !!FileDescriptor methodsFor: 'as yet unclassified'!position	^ self movePosition: 0.	! !!FileDescriptor methodsFor: 'as yet unclassified'!position: offset"absolute position"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_SET' ).! !!FileDescriptor methodsFor: 'as yet unclassified'!positionFromEnd: offset"relative to end of file"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_END' ).	! !!FileDescriptor methodsFor: 'as yet unclassified'!read: size	| retValue buffer |	buffer := ExternalBuffer new: size.	retValue := self readBuffer: buffer size: size.	! !!FileDescriptor methodsFor: 'as yet unclassified'!readBuffer: buffer size: size	^ LibC6 default read: self buffer: buffer size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!readString: aString	^ LibC6 default read: self string: aString size: aString size! !!FileDescriptor methodsFor: 'as yet unclassified'!readString: aString size: size	| internalSize |	internalSize := size.	aString size < size ifTrue: [ internalSize := aString size ].	^ LibC6 default read: self string: aString size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!size	| position size |	position := self position.	size := self positionFromEnd: 0.	self position: position.	^ size	! !!FileDescriptor methodsFor: 'as yet unclassified'!writeBuffer: buffer size: size	^ LibC6 default write: self buffer: buffer size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!writeString: aString	^ LibC6 default write: self string: aString size: aString size! !!FileDescriptor methodsFor: 'as yet unclassified'!writeString: aString size: size	| internalSize |	internalSize := size.	aString size < size ifTrue: [ internalSize := aString size ].	^ LibC6 default write: self string: aString size: size! !!FileDescriptor class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalValue! !!FileDescriptor class methodsFor: 'as yet unclassified'!initialize	self initializeStandardDescriptors! !!FileDescriptor class methodsFor: 'as yet unclassified'!initializeStandardDescriptors	StandardDescriptors := Dictionary new.	StandardDescriptors at: #stdout put: (self newFileDescriptor: 0).	StandardDescriptors at: #stdin put: (self newFileDescriptor: 1).	StandardDescriptors at: #stderr put: (self newFileDescriptor: 2).! !!FileDescriptor class methodsFor: 'as yet unclassified'!newFileDescriptor: anInteger	^ self new fileDescriptor: anInteger; yourself.! !!FileDescriptor class methodsFor: 'as yet unclassified'!standardDescriptors	^ StandardDescriptors! !!FileDescriptor class methodsFor: 'as yet unclassified'!stderr	^ StandardDescriptors at: #stderr.! !!FileDescriptor class methodsFor: 'as yet unclassified'!stdin	^ StandardDescriptors at: #stdin.! !!FileDescriptor class methodsFor: 'as yet unclassified'!stdout	^ StandardDescriptors at: #stdout.! !!FileStream methodsFor: 'as yet unclassified'!atEnd	"Answer true if the current position is >= the end of file position.	 1/31/96 sw: subclassResponsibility"	self subclassResponsibility! !!FileStream class methodsFor: 'as yet unclassified'!fileDoesNotExistUserHandling: fullFileName	(GtkMessageDialog question: fullFileName, ' does not exist, create it?') = #yes		ifTrue: [ ^ self new open: fullFileName forWrite: true ].! !!FileStream class methodsFor: 'as yet unclassified'!fileExistsUserHandling: fullFileName	(GtkMessageDialog question: fullFileName, ' exist, overwrite it?') = #yes		ifTrue: [ ^ self new openForOverwrite: fullFileName ].! !!FileStream class methodsFor: 'as yet unclassified'!readOnlyFileDoesNotExistUserHandling: fullFileName	GtkMessageDialog error: fullFileName, ' does not exist'! !!FileDoesNotExistException methodsFor: 'as yet unclassified'!defaultAction	"The default action taken if the exception is signaled."	^self readOnly		ifTrue: [FileStream readOnlyFileDoesNotExistUserHandling: self fileName]		ifFalse: [FileStream fileDoesNotExistUserHandling: self fileName]! !!GIRBuilder methodsFor: 'as yet unclassified'!compiledMethod	| bytecodes |	bytecodes := self bytecodes.	bytecodes ifNil: [ ^ nil ].	^ CompiledMethod new		primitive: 0;		numArgs: self numArgs;		numTemps: self numTemps;		literals: self literals;		relocationInfo: self relocationInfo;		bytecodes: bytecodes;		debugInfo: debugInfo;		source: source;		relocate.! !!GPointer methodsFor: 'as yet unclassified'!initialize	handle := self class defaultHandlerClass new.! !!GPointer class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalAddress! !!GPointer class methodsFor: 'as yet unclassified'!handle: aByteArray	^self basicNew handle: aByteArray; yourself! !!GObject class methodsFor: 'as yet unclassified'!handleFromObject: object	^ object handle.	! !!Gtk methodsFor: 'as yet unclassified'!initialize	self initializeGtkLibrary.	self startMainLoop.! !!Gtk class methodsFor: 'as yet unclassified'!shutDown: quiting	"Quits the Gtk main loop"	Default ifNotNil: [		Default quitMainLoop.		Default close.		Default := nil.	].! !!GtkDemoStockIds methodsFor: 'as yet unclassified'!initialize	| model tree |	model := GtkListStore new: {String. String. String. String}.	GtkStockItem allStocks do: [ :ea |		ea ifNotNil: [			model append: {				ea stockId asGtkStockId.				ea stockId.				ea label.				Gtk acceleratorName: ea keyval asCharacter modifier: ea modifier}]].	tree := GtkTreeView model: model.	self createFirstColumn: tree.	tree appendColumns: {		GtkTreeViewColumn title: 'Label' text: 2.		GtkTreeViewColumn title: 'Accel' text: 3.		GtkTreeViewColumn title: 'ID' text: 0}.	tree selection when: #changed send: #onItemChanged: to: self withArgumentsFirst: {tree}.			self container: (GtkHBox spacing: 5).	self container		packStart: (GtkScrolledWindow withChild: tree);		packEnd: self createInfoFrame expand: false fill: false! !!GtkDemoStockIds methodsFor: 'as yet unclassified'!onItemChanged: aTreeView	aTreeView selectedRow in: [:row |		idLabel label: row first.		nameLabel label: '#', row second.		accelLabel label: row third.		iconImage stock: row second iconSize: #dialog]! !!InMidstOfFileinNotification methodsFor: 'as yet unclassified'!defaultAction	^ self resume: false! !!LibC methodsFor: 'as yet unclassified'!closeLibrary	cLibrary closeLibrary.	cLibrary := nil.! !!LibC methodsFor: 'as yet unclassified'!initializeCLibrary	cLibrary := ExternalLibrary new.	cLibrary name: 'libc.so.6'.	cLibrary openLibrary.! !!LibC class methodsFor: 'as yet unclassified'!shutDown: quiting	"Quits the Gtk main loop"	self default closeLibrary.	Default := nil.! !!LibC6 methodsFor: 'as yet unclassified'!close: fd	| retValue |	retValue := ( self cDeclFunctionNamed: #close ) invokeWith: fd.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #close ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!errno	^ (self libraryDataNamed: #errno) value.	! !!LibC6 methodsFor: 'as yet unclassified'!errno: errno	(self libraryDataNamed: #errno) value: errno.	! !!LibC6 methodsFor: 'as yet unclassified'!free: anExternalBuffer	( self cDeclFunctionNamed: #free ) invokeWith: anExternalBuffer.	! !!LibC6 methodsFor: 'as yet unclassified'!getCurrentDirName	| retValue |	[ retValue := ( self cDeclFunctionNamed: 'get_current_dir_name' asSymbol ) invoke ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: 'get_current_dir_name' asSymbol ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!getEnv: envVariable	^ ( self cDeclFunctionNamed: #getenv ) invokeWith: envVariable.! !!LibC6 methodsFor: 'as yet unclassified'!getpid	^ (self cDeclFunctionNamed: #getpid) invoke.	! !!LibC6 methodsFor: 'as yet unclassified'!initialize	super initialize.	self initializeUniStd.	self initializeStdLib.	self initializeString.	self initializeFCntl.	self initializeStdIO.	self initializeErrNO.! !!LibC6 methodsFor: 'as yet unclassified'!initializeErrNO	self initializeLibraryDataNamed: #errno type: #SignedInteger.! !!LibC6 methodsFor: 'as yet unclassified'!initializeFCntl	self initializeCDeclFunctionNamed: #open returnType: #FileDescriptor argTypes: #( AsciiZ SignedInteger UnsignedInteger ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeStdIO	self initializeCDeclFunctionNamed: #printf  returnType: #SignedInteger argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: #perror  returnType: #Void argTypes: #( AsciiZ  ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeStdLib	self initializeCDeclFunctionNamed: #malloc  returnType: #ExternalBuffer argTypes: #( UnsignedInteger  ).	self initializeCDeclFunctionNamed: #free  returnType: #Void argTypes: #( ExternalBuffer  ).	self initializeCDeclFunctionNamed: #getenv  returnType: #AsciiZ argTypes: #( AsciiZ ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeString	self initializeCDeclFunctionNamed: #strlen returnType: #UnsignedInteger argTypes: #( AsciiZ ).	self initializeCDeclFunctionNamed: #strcat returnType: #AsciiZ argTypes: #( AsciiZ AsciiZ ).	self initializeCDeclFunctionNamed: #strcpy returnType: #AsciiZ argTypes: #( AsciiZ AsciiZ ).	self initializeCDeclFunctionNamed: #strerror returnType: #ReadOnlyAsciiZ argTypes: #( SignedInteger ).	self initializeCDeclFunctionNamed: #memset returnType: #ExternalBuffer argTypes: #( ExternalBuffer SignedInteger  UnsignedInteger ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeUniStd	self initializeCDeclFunctionNamed: #getpid  returnType: #UnsignedInteger argTypes: #().	self initializeCDeclFunctionNamed: 'get_current_dir_name' asSymbol  returnType: #AsciiZ argTypes: #().	self initializeCDeclFunctionNamed: #close  returnType: #SignedInteger argTypes: #( FileDescriptor ).	self initializeCDeclFunctionNamed: #lseek  returnType: #UnsignedInteger argTypes: #( FileDescriptor UnsignedInteger SignedInteger ).	self initializeCDeclFunctionNamed: #read  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalBuffer UnsignedInteger ).	self initializeCDeclFunctionNamed: #write  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalBuffer UnsignedInteger )."Redefinition of read for Strings"	symbolCache at: #readString put: (CDeclFunction name: #read library: self  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalArrayProxy UnsignedInteger ) )."Redefinition of write for Strings"	symbolCache at: #writeString put: (CDeclFunction name: #write library: self  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalArrayProxy UnsignedInteger ) ).! !!LibC6 methodsFor: 'as yet unclassified'!lseek: fileDescriptor offset: offset whence: whence	| returnValue |	returnValue := (self cDeclFunctionNamed: #lseek) invokeWith: fileDescriptor with: offset with: whence.	returnValue < 0 ifTrue: [		self throwErrorForExternalFunctionNamed: #lseek.		^ nil.	].	^ returnValue.	! !!LibC6 methodsFor: 'as yet unclassified'!malloc: size	| retValue |	[ retValue := ( self cDeclFunctionNamed: #malloc ) invokeWith: size ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: #malloc withMessage: 'can not allocate memory' ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!memSet: buffer constant: c count: n	^ (self cDeclFunctionNamed: #memset) invokeWith: buffer with: c with: n.	! !!LibC6 methodsFor: 'as yet unclassified'!open: path flags: flags	^ self open: path flags: flags mode: 8r644	! !!LibC6 methodsFor: 'as yet unclassified'!open: path flags: flags mode: mode	| fileDescriptor |	fileDescriptor := (self cDeclFunctionNamed: #open) invokeWith: path with: flags with: mode.	fileDescriptor fileDescriptor < 0 ifTrue: [		self throwErrorForExternalFunctionNamed: #open.		^ nil.	].	^ fileDescriptor.	! !!LibC6 methodsFor: 'as yet unclassified'!perror: aString	( self cDeclFunctionNamed: #perror ) invokeWith: aString.	! !!LibC6 methodsFor: 'as yet unclassified'!printf: aString	^ ( self cDeclFunctionNamed: #printf ) invokeWith: aString.	! !!LibC6 methodsFor: 'as yet unclassified'!read: fd buffer: buffer size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #read ) invokeWith: fd with: buffer with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #read ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!read: fd string: aString size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #readString ) invokeWith: fd with: aString with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #readString ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!strCat: destString with: sourceString	^ ( self cDeclFunctionNamed: #strcat ) invokeWith: destString with: sourceString.	! !!LibC6 methodsFor: 'as yet unclassified'!strCpy: destString with: sourceString	^ ( self cDeclFunctionNamed: #strcpy ) invokeWith: destString with: sourceString.	! !!LibC6 methodsFor: 'as yet unclassified'!strError: errno	| retValue |	[ retValue := ( self cDeclFunctionNamed: #strerror ) invokeWith: errno ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: #strerror ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!strLen: string	^ ( self cDeclFunctionNamed: #strlen ) invokeWith: string	! !!LibC6 methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName	^ self throwErrorForExternalFunctionNamed: functionName withMessage: (self strError: self errno).	! !!LibC6 methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName withMessage: aString	| error |	error := ExternalFunctionError functionName: functionName.	error messageText: aString.	^ error signal.	! !!LibC6 methodsFor: 'as yet unclassified'!valueForLSeekDirectiveNamed: aString	^ LSeekDirectives at: aString asSymbol.	! !!LibC6 methodsFor: 'as yet unclassified'!valueForOpenFlagNamed: aString	^ OpenFlags at: aString asSymbol.	! !!LibC6 methodsFor: 'as yet unclassified'!write: fd buffer: buffer size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #write ) invokeWith: fd with: buffer with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #write ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!write: fd string: aString size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #writeString ) invokeWith: fd with: aString with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #writeString ].	^ retValue.	! !!LibC6 class methodsFor: 'as yet unclassified'!initialize	self initializeOpenFlags.	self initializeLSeekDirectives.! !!LibC6 class methodsFor: 'as yet unclassified'!initializeLSeekDirectives	| lSeekDirectives |		lSeekDirectives := Dictionary new.	lSeekDirectives at: 'SEEK_SET' put: 0.	lSeekDirectives at: 'SEEK_CUR' put: 1.	lSeekDirectives at: 'SEEK_END' put: 2.	LSeekDirectives := lSeekDirectives! !!LibC6 class methodsFor: 'as yet unclassified'!initializeOpenFlags	| flagArray openFlags |		flagArray := #( 		('O_RDONLY'		0)		('O_WRONLY'		8r1)		('O_RDWR'		8r2)		('O_CREAT'		8r100)			('O_EXCL'			8r200)			('O_NOCTTY'		8r400)			('O_TRUNC'		8r1000)			('O_APPEND'		8r2000)		('O_NONBLOCK'	8r4000)		('O_SYNC'		8r10000)		('O_ASYNC'		8r20000)	).	openFlags := Dictionary new.	flagArray do: [ :i |		openFlags at: i first asSymbol put: i second	].	OpenFlags := openFlags! !!LibC6 class methodsFor: 'as yet unclassified'!moduleName	^ 'libc.so.6'.! !!LibExample methodsFor: 'as yet unclassified'!getpid	^ GETPID invoke! !!LibExample class methodsFor: 'as yet unclassified'!getpid	^ GETPID! !!LibExample class methodsFor: 'as yet unclassified'!initialize	GETPID := CDeclFunction name: 'getpid' libraryNamed: 'libc.so.6' returnType: #UnsignedInteger argTypes: #().! !!LibReadLine methodsFor: 'as yet unclassified'!addHistory: aString	( self cDeclFunctionNamed: 'add_history' asSymbol ) invokeWith: aString.! !!LibReadLine methodsFor: 'as yet unclassified'!initialize	super initialize.	self initializeCDeclFunctionNamed: #readline  returnType: #AsciiZ argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'add_history' asSymbol returnType: #Void argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'read_history' asSymbol returnType: #SignedInteger argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'write_history' asSymbol returnType: #SignedInteger argTypes: #( AsciiZ  ).! !!LibReadLine methodsFor: 'as yet unclassified'!readHistory: aFileName	| errno |	errno := ( self cDeclFunctionNamed: 'read_history' asSymbol ) invokeWith: aFileName.	errno = 0 ifFalse: [ self throwErrorForExternalFunctionNamed: 'read_history' asSymbol errno: errno ].	^ errno.! !!LibReadLine methodsFor: 'as yet unclassified'!readline: prompt	^ ( self cDeclFunctionNamed: #readline ) invokeWith: prompt.! !!LibReadLine methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName errno: errno	| error |	error := ExternalFunctionError functionName: functionName.	error messageText: (LibC6 default strError: errno).	^ error signal.! !!LibReadLine methodsFor: 'as yet unclassified'!writeHistory: aFileName	| errno |	errno := ( self cDeclFunctionNamed: 'write_history' asSymbol ) invokeWith: aFileName.	errno = 0 ifFalse: [ self throwErrorForExternalFunctionNamed: 'write_history' asSymbol errno: errno ].	^ errno.! !!LibReadLine class methodsFor: 'as yet unclassified'!moduleName	^ 'libreadline.so.5'.! !!LibraryData methodsFor: 'as yet unclassified'!primitiveGetValue: valueHandle	<primitive: 216>	^self primitiveFailed! !!LibraryData methodsFor: 'as yet unclassified'!primitiveSetValue: valueHandle	<primitive: 217>	^self primitiveFailed! !!LibraryData methodsFor: 'as yet unclassified'!type	^ type.! !!LibraryData methodsFor: 'as yet unclassified'!type: aType	type := aType.! !!LibraryData methodsFor: 'as yet unclassified'!value	| valueClass valueHandle |	valueClass := self classFromType: type.	valueHandle := valueClass defaultHandlerClass new.	handle isNull ifTrue: [ self bind ].	self primitiveGetValue: valueHandle.	^ valueClass objectFromHandle: valueHandle.! !!LibraryData methodsFor: 'as yet unclassified'!value: aValue	| argHandle argClass |	argClass := self classFromType: type.	argHandle := argClass handleFromObject: aValue.	handle isNull ifTrue: [ self bind ].	self primitiveSetValue: argHandle! !!LibraryData class methodsFor: 'as yet unclassified'!name: aName library: aLibrary type: type	^self new name: aName library: aLibrary;		type: type;		bind! !!Metaclass methodsFor: 'as yet unclassified'!addObsoleteSubclass: aClass	"Do nothing."! !!Metaclass methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return true if it is safe to zap the method dictionary on #obsolete"	thisClass == nil		ifTrue:[^true]		ifFalse:[^thisClass canZapMethodDictionary]! !!Metaclass methodsFor: 'as yet unclassified'!isSystemDefined	"Answer false if I am a UniClass (an instance-specific lightweight class)"	^ true! !!NativeFunction methodsFor: 'as yet unclassified'!callingConventionString	^ 'native'! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver	^self invokeReceiver: receiver withArguments: #()! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1	^self invokeReceiver: receiver withArguments: (Array with: arg1)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4 with: arg5	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver withArguments: argArray	handle isNull ifTrue: [ self bind ].	^ self primInvokeReceiver: receiver withArguments: argArray.! !!NativeFunction methodsFor: 'as yet unclassified'!primInvokeReceiver: receiver withArguments: argArray	"Manually invoke the receiver, representing an native function."	<primitive: 197>	^self primitiveFailed! !!ObjectTest methodsFor: 'as yet unclassified'!testBecome	"self debug: #testBecome"	"this test should that all the variables pointing to an object are pointing now to another one, and all      object pointing to the other are pointing to the object"	| pt1 pt2 pt3 |	pt1 := 0@0.	pt2 := pt1.	pt3 := 100@100.	pt1 become: pt3.	self assert: pt2 = (100@100).	self assert: pt3 = (0@0).	self assert: pt1 = (100@100).! !!ObjectTest methodsFor: 'as yet unclassified'!testBecomeForward	"self debug: #testBecomeForward"	"this test should that all the variables pointing to an object are pointing now to another one.	Not that this inverse is not true. This kind of become is called oneWayBecome in VW"	| pt1 pt2 pt3 |	pt1 := 0@0.	pt2 := pt1.	pt3 := 100@100.	pt1 becomeForward: pt3.	self assert: pt2 = (100@100).	self assert: pt3 == pt2.	self assert: pt1 = (100@100)! !!PrimitiveType class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalValue! !!PrimitiveType class methodsFor: 'as yet unclassified'!handleFromObject: anObject	^ self handleFromObject: anObject ifError: [ self throwTypeConvertionError ]! !!PrimitiveType class methodsFor: 'as yet unclassified'!handleFromObject: object ifError: aBlock	self subclassResponsibility.! !!PrimitiveType class methodsFor: 'as yet unclassified'!objectFromHandle: handle	^ self objectFromHandle: handle ifError: [  self throwTypeConvertionError ]! !!PrimitiveType class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock	self subclassResponsibility.! !!PrimitiveType class methodsFor: 'as yet unclassified'!throwTypeConvertionError	^ TypeConvertionError new signal! !!IntegerType class methodsFor: 'as yet unclassified'!handleFromObject: anInteger ifError: aBlock	| handle |		(self checkType: anInteger) ifFalse: [ ^ aBlock value ].	handle := ExternalValue new.	self store: anInteger in: handle.	^ handle.	! !!IntegerType class methodsFor: 'as yet unclassified'!isBigEndian	^  false! !!IntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	self subclassResponsibility.! !!IntegerType class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: errorBlock	| value |		value := self loadFrom: handle.	(value > self max ) ifTrue: [ ^ errorBlock value ].	^ value.! !!Process methodsFor: 'as yet unclassified'!primitiveBeInitialProcess	<primitive: 196>	self primitiveFailed! !!ProcessorScheduler methodsFor: 'as yet unclassified'!activeProcess	^ self primActiveProcess! !!ProcessorScheduler methodsFor: 'as yet unclassified'!primActiveProcess	<primitive: 195>	self primitiveFail.! !!ProcessorScheduler methodsFor: 'as yet unclassified'!startUp	| firstProcess |"	(processList isNil or: [ processList isEmpty not ]) ifTrue: [ self initialize ]."	self initialize.	firstProcess := Process new.	firstProcess name: 'Init'.	firstProcess priority: self userSchedulingPriority.	firstProcess state: #running."	firstProcess threadData: self activeThreadData."	firstProcess primitiveBeInitialProcess.! !!ReadOnlyAsciiZ methodsFor: 'as yet unclassified'!asString	^ handle toString.! !!ReadOnlyAsciiZ class methodsFor: 'as yet unclassified'!handleFromObject: aByteArray ifError: aBlock	"Can not be used as arguments"	aBlock value.! !!ReadOnlyAsciiZ class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; asString! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!addressRelativeTo: bytecodes	| functionAddress bytecodesAddress |	functionAddress := self function address asInteger.	bytecodesAddress := (ExternalAddress forArray: bytecodes ) asInteger.	^ functionAddress - bytecodesAddress - offset - 4! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!function	^ self library functionNamed: functionName.! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!functionName	^ functionName! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!functionName: aSymbol	^ functionName := aSymbol! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!library	^ Executable default! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!patch: bytecodes	self patch: bytecodes with: (self addressRelativeTo: bytecodes).! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!patch: bytecodes with: value	bytecodes longAt: (offset + 1) put: value bigEndian: false.! !!FunctionRelocation methodsFor: 'as yet unclassified'!addressRelativeTo: bytecodes	^ self primAddressRelativeTo: bytecodes! !!FunctionRelocation methodsFor: 'as yet unclassified'!primAddressRelativeTo: bytecodes	<primitive: 155>	self primitiveFail.! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!defaultLibraryClass	^ NativeLibrary! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!library 		^ self defaultLibraryClass named: libraryName! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!libraryName	^ libraryName! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!libraryName: aSymbol	^ libraryName := aSymbol! !!ExternalFunctionRelocation methodsFor: 'as yet unclassified'!defaultLibraryClass	^ ExternalLibrary2! !!SequenceableCollection methodsFor: 'as yet unclassified'!asTraitComposition	"For convenience the composition {T1. T2 ...} is the same as T1 + T2 + ..."	^self isEmpty		ifFalse: [			self size = 1				ifTrue: [self first asTraitComposition]				ifFalse: [					self copyWithoutFirst 						inject: self first						into: [:left :right | left + right]]]		ifTrue: [			TraitComposition new]! !!Array methodsFor: 'as yet unclassified'!elementsExchangeIdentityWith: otherArray	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsExchangeIdentityWith: otherArray.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!elementsForwardIdentityTo: otherArray	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsForwardIdentityTo: otherArray.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!elementsForwardIdentityTo: otherArray copyHash: copyHash	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsForwardIdentityTo: otherArray copyHash: copyHash.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!primElementsExchangeIdentityWith: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  At the same time, all pointers to the elements of otherArray are replaced by pointers to the corresponding elements of this array.  The identityHashes remain with the pointers rather than with the objects so that objects in hashed structures should still be properly indexed after the mutation."	<primitive: 128>	otherArray class == Array ifFalse: [^ self error: 'arg must be array'].	self size = otherArray size ifFalse: [^ self error: 'arrays must be same size'].	(self anySatisfy: [:obj | obj class == SmallInteger]) ifTrue: [^ self error: 'can''t become SmallIntegers'].	(otherArray anySatisfy: [:obj | obj class == SmallInteger]) ifTrue: [^ self error: 'can''t become SmallIntegers'].	"Must have failed because not enough space in forwarding table (see ObjectMemory-prepareForwardingTableForBecoming:with:twoWay:).  Do GC and try again only once"	(Smalltalk bytesLeft: true) = Smalltalk primitiveGarbageCollect		ifTrue: [^ self primitiveFailed].	^ self elementsExchangeIdentityWith: otherArray! !!Array methodsFor: 'as yet unclassified'!primElementsForwardIdentityTo: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  The identityHashes remain with the pointers rather than with the objects so that the objects in this array should still be properly indexed in any existing hashed structures after the mutation."	<primitive: 72>	self primitiveFailed! !!Array methodsFor: 'as yet unclassified'!primElementsForwardIdentityTo: otherArray copyHash: copyHash	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  The identityHashes remain with the pointers rather than with the objects so that the objects in this array should still be properly indexed in any existing hashed structures after the mutation."	<primitive: 249>	self primitiveFailed! !!ExternalValue methodsFor: 'as yet unclassified'!beNull	"Make the receiver a NULL pointer"	self atAllPut: 0.! !!ExternalValue methodsFor: 'as yet unclassified'!isNull	^(self basicAt: 1) = 0	and: (self basicAt: 2) = 0	and: (self basicAt: 3) = 0	and: (self basicAt: 4) = 0	! !!ExternalValue class methodsFor: 'as yet unclassified'!initialize	Smalltalk addToStartUpList: self.! !!ExternalValue class methodsFor: 'as yet unclassified'!new	"External addresses are always 4 bytes long"	^super new: 4! !!ExternalValue class methodsFor: 'as yet unclassified'!new: n	"You better don't try this..."	^self shouldNotImplement! !!ExternalValue class methodsFor: 'as yet unclassified'!startUp: resuming	resuming ifTrue: [		self allInstancesDo: [ :addr |			addr beNull		]	].! !!SharedPool class methodsFor: 'as yet unclassified'!bindingOf: varName	"Answer the binding of some variable resolved in the scope of the receiver"	| aSymbol binding |	aSymbol := varName asSymbol.	"First look in classVar dictionary."	binding := self classPool bindingOf: aSymbol.	binding ifNotNil:[^binding].	"Next look in shared pools."	self sharedPools do:[:pool | 		binding := pool bindingOf: aSymbol.		binding ifNotNil:[^binding].	].	"subclassing and environment are not preserved"	^nil! !!SharedPool class methodsFor: 'as yet unclassified'!bindingsDo: aBlock	^self classPool bindingsDo: aBlock! !!SharedPool class methodsFor: 'as yet unclassified'!classBindingOf: varName	"For initialization messages grant the regular scope"	^super bindingOf: varName! !!SharedPool class methodsFor: 'as yet unclassified'!hasBindingThatBeginsWith: aString	"Answer true if the receiver has a binding that begins with aString, false otherwise"	"First look in classVar dictionary."	(self classPool hasBindingThatBeginsWith: aString) ifTrue:[^true].	"Next look in shared pools."	self sharedPools do:[:pool | 		(pool hasBindingThatBeginsWith: aString) ifTrue: [^true]].	^false! !!SharedPool class methodsFor: 'as yet unclassified'!includesKey: aName	"does this pool include aName"	^(self bindingOf: aName) notNil! !!SharedPool class methodsFor: 'as yet unclassified'!keysDo: aBlock"A hopefully temporary fix for an issue arising from miss-spelled variable names in code being compiled. The correction code (see Class>possibleVariablesFor:continuedFrom: assumes that sharedPools are Dictionaries. The proper fix would involve making sure all pools are actually subclasses of SharedPool, which they are not currently."	self bindingsDo:[:b|		aBlock value: b key]! !!Shell methodsFor: 'as yet unclassified'!display: string	| buffer |		buffer := AsciiZ fromString: string.	^ FileDescriptor stdout writeBuffer: buffer size: buffer size.! !!Shell methodsFor: 'as yet unclassified'!input: prompt	^ LibReadLine default readline: prompt! !!Shell methodsFor: 'as yet unclassified'!main	| line value failed anotherLine buffer |	LibReadLine default readHistory: self historyFileName.	[		anotherLine := false.		buffer := ''.		[ 	| prompt |			prompt := anotherLine ifTrue: [ '' ] ifFalse: [ '> ' ].			line _ self input: prompt.			line isEmpty				ifTrue: [ true ] 				ifFalse: [					(line last = $\)						ifTrue: [							anotherLine := true.							line at: line size put: Character lf.						]						ifFalse: [ anotherLine := false ].					buffer := buffer, line.					anotherLine				]		] whileTrue. 		buffer = 'quit' or: [ buffer = 'save' ]	] whileFalse: [		self addToHistory: buffer.		failed _ false.		value _ Compiler new evaluate: buffer in: nil to: nil notifying: self ifFail: [ failed _ true].		failed ifFalse: [ self display: (value printString); lf ]	].	LibReadLine default writeHistory: self historyFileName.	buffer = 'save' ifTrue: [ Smalltalk snapshotAndQuit ].	^value.! !!SignedIntegerType class methodsFor: 'as yet unclassified'!checkType: value	^ value isInteger and: [ value >= self min and: [ value <= self max ] ]! !!SignedIntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	^ handle longAt: 1 bigEndian: self isBigEndian.! !!SignedIntegerType class methodsFor: 'as yet unclassified'!store: anInteger in: handle	handle longAt: 1 put: anInteger bigEndian: self isBigEndian.! !!SignedByte class methodsFor: 'as yet unclassified'!max			^ 127! !!SignedByte class methodsFor: 'as yet unclassified'!min			^ -128! !!SignedInteger class methodsFor: 'as yet unclassified'!max			^ 2147483647! !!SignedInteger class methodsFor: 'as yet unclassified'!min			^ -2147483648! !!SignedShortInteger class methodsFor: 'as yet unclassified'!max			^ 32767! !!SignedShortInteger class methodsFor: 'as yet unclassified'!min			^ -32768! !!SourceReference methodsFor: 'as yet unclassified'!sourceFrom: aString	self hasEmptySourceReference ifTrue: [ ^ '' ].	^ aString copyFrom: sourceStart to: sourceStop! !!StandardFileStream class methodsFor: 'as yet unclassified'!retryWithGC: execBlock until: testBlock forFileNamed: fullName	"Re-implemented to only force GC if a file with the given name exists"	| blockValue foundIt |	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	"See if we have a file with the given name"	foundIt := self registry keys "hold on strongly for now" 		anySatisfy:[:file| file name sameAs: fullName].	foundIt ifFalse:[^blockValue].	Smalltalk garbageCollectMost.	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollect.	^execBlock value.! !!SystemDictionary methodsFor: 'as yet unclassified'!forgetClass: aClass logged: aBool 	"Delete the class, aClass, from the system.	Note that this doesn't do everything required to dispose of a class - to do that use Class>>removeFromSystem."	aBool ifTrue: [SystemChangeNotifier uniqueInstance classRemoved: aClass fromCategory: aClass category].			SystemOrganization removeElement: aClass name.	self removeFromStartUpList: aClass.	self removeFromShutDownList: aClass.	self removeKey: aClass name ifAbsent: [].	self flushClassNameCache! !!SystemDictionary methodsFor: 'as yet unclassified'!removeClassNamed: aName	"Invoked from fileouts:  if there is currently a class in the system named aName, then remove it.  If anything untoward happens, report it in the Transcript.  "	| oldClass |	(oldClass _ self at: aName asSymbol ifAbsent: [nil]) == nil		ifTrue:			[Transcript cr; show: 'Removal of class named ', aName, ' ignored because ', aName, ' does not exist.'.			^ self].	oldClass removeFromSystem! !!SystemDictionary methodsFor: 'as yet unclassified'!startUp	Processor startUp.	ProcessorScheduler startUp.	self processStartUpList: true.	self installLowSpaceWatcher.! !!SystemTracer methodsFor: 'as yet unclassified'!getAligned: size	^ (( size + 3 ) bitShift: -2) bitShift: 2.! !!TraitBehavior methodsFor: 'as yet unclassified'!addUser: aClassOrTrait	users add: aClassOrTrait! !!TraitBehavior methodsFor: 'as yet unclassified'!classesComposedWithMe	^users gather: [:u | u classesComposedWithMe]! !!TraitBehavior methodsFor: 'as yet unclassified'!initialize	self methodDict: Dictionary new.	self traitComposition: nil.	users _ IdentitySet new.! !!TraitBehavior methodsFor: 'as yet unclassified'!removeUser: aClassOrTrait	users remove: aClassOrTrait ifAbsent: []! !!TraitBehavior methodsFor: 'as yet unclassified'!users	^users! !!TraitComposition methodsFor: 'as yet unclassified'!assertValidUser: aBehavior	"Assert that this trait composition set for aBehavior	does not introduce a cycle."		(self allTraits includes: aBehavior) ifTrue: [		TraitCompositionException signal: 'Cycle in compositions:  The composition (in)directly includes this trait!!']! !!TraitComposition methodsFor: 'as yet unclassified'!methodDescriptionsForSelector: aSymbol	"Return a collection of TraitMethodDescriptions for aSymbol and all the 	aliases of aSymbol."	| selectors collection |	selectors _ IdentitySet with: aSymbol.	self transformations do: [:each |		selectors addAll: (each aliasesForSelector: aSymbol)].	collection _ OrderedCollection new: selectors size.	selectors do: [:each |		collection add: (self methodDescriptionForSelector: each)].	^collection! !!TraitDescription methodsFor: 'as yet unclassified'!trait	"for compatibility with TraitTransformations"	^ self! !!TraitDescription methodsFor: 'as yet unclassified'!updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil	| currentCategory effectiveCategory sel changedCategories composition |	changedCategories _ IdentitySet new.	composition := self hasTraitComposition		ifTrue: [self traitComposition]		ifFalse: [TraitComposition new].	(composition methodDescriptionsForSelector: aSymbol) do: [:each |		sel _ each selector.		(self includesLocalSelector: sel) ifFalse: [			currentCategory _ self organization categoryOfElement: sel.			effectiveCategory _ each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.			effectiveCategory isNil ifTrue: [				currentCategory ifNotNil: [changedCategories add: currentCategory].				self organization removeElement: sel.			] ifFalse: [				((currentCategory isNil or: [currentCategory == ClassOrganizer ambiguous or: [currentCategory == oldCategoryOrNil]]) and: [currentCategory ~~ effectiveCategory]) ifTrue: [					currentCategory ifNotNil: [changedCategories add: currentCategory].					self organization 						classify: sel 						under: effectiveCategory						suppressIfDefault: false]]]].	^ changedCategories! !!TraitDescription methodsFor: 'as yet unclassified'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	(self includesSelector: aSelector)		ifTrue: [^ self organization categoryOfElement: aSelector]		ifFalse: [^nil]! !!Trait methodsFor: 'as yet unclassified'!initialize	super initialize.	classTrait _ ClassTrait for: self! !!TranscriptCodeView class methodsFor: 'as yet unclassified'!initialize	Smalltalk addToStartUpList: self.! !!TranscriptCodeView class methodsFor: 'as yet unclassified'!startUp: resuming	resuming ifTrue: [		TranscriptCodeBuffer := nil.	].! !!TranscriptStream methodsFor: 'as yet unclassified'!open	TranscriptCodeEditor open.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!atEnd	position ifNil: [ ^ nil ].	^ position >= readLimit! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!close	"Close this file."	fileID ifNotNil: [		fileID close.		fileID := nil.		position := nil.	].! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!open: fileName flags: flags	[ fileID := LibC6 default open: fileName flags: flags ]		on: ExternalFunctionError		do: [ ^ nil ].	name := fileName.	readLimit := fileID size.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!open: fileName forWrite: writeMode 	| flags |	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	flags := writeMode 		ifTrue: [ LibC6 default valueForOpenFlagNamed: 'O_RDWR' ]		ifFalse: [ LibC6 default valueForOpenFlagNamed: 'O_RDONLY' ].	rwmode := writeMode.	^ self open: fileName flags: flags.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!openForOverwrite: fileName	| flags |	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	flags := ((LibC6 default valueForOpenFlagNamed: 'O_RDWR') 			bitOr: ( LibC6 default valueForOpenFlagNamed: 'O_TRUNC' )) 			bitOr: ( LibC6 default valueForOpenFlagNamed: 'O_CREAT' ).	rwmode := true.	^ self open: fileName flags: flags.! !!BufferedFileStream methodsFor: 'as yet unclassified'!close	"Close this file."	self flush.	^ super close.! !!BufferedFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	self subclassResponsibility! !!BufferedFileStream methodsFor: 'as yet unclassified'!defaultBufferSize	^ DefaultBufferSize.! !!BufferedFileStream methodsFor: 'as yet unclassified'!flush	| bufferPosition bufferSize |	fileID ifNil: [ ^ nil ].	rwmode ifFalse: [ ^ nil ].	bufferPosition := position truncateTo: (collection size).	bufferSize := collection size min: ( readLimit - bufferPosition).	fileID position: bufferPosition.	bufferSize > 0 ifTrue: [ fileID writeString: collection size: bufferSize ].	 ! !!BufferedFileStream methodsFor: 'as yet unclassified'!initializeBuffer	| bufferSize |	position := 0.	collection := self defaultBufferClass new: self defaultBufferSize.	bufferSize := collection size min: readLimit.	bufferSize > 0 ifTrue: [ fileID readString: collection size: bufferSize ]. ! !!BufferedFileStream methodsFor: 'as yet unclassified'!next	| byte |	byte := self peek.	self position: position + 1.	^ byte! !!BufferedFileStream methodsFor: 'as yet unclassified'!nextPut: char	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	position ifNil: [ self position: 0 ].	collection at: (position \\ (collection size)) + 1put: char.	self position: position + 1.	^ char! !!BufferedFileStream methodsFor: 'as yet unclassified'!open: fileName flags: flags	(super open: fileName flags: flags) ifNotNil: [ self initializeBuffer ].! !!BufferedFileStream methodsFor: 'as yet unclassified'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	position ifNil: [ self position: 0 ].	self atEnd ifTrue: [^ nil ].	^ collection at: (position \\ (collection size)) + 1.! !!BufferedFileStream methodsFor: 'as yet unclassified'!position: newPosition	| oldBufferPosition newBufferPosition bufferSize |	fileID ifNil: [ ^nil ].	newPosition < 0 ifTrue: [ ^nil ]."	((newPosition > readLimit) and: [ rwmode not ])  ifTrue: [ ^nil ]."	newPosition > readLimit ifTrue: [		rwmode ifTrue: [ readLimit := newPosition ] ifFalse: [ ^nil ]	].	oldBufferPosition := position truncateTo: (collection size).	newBufferPosition := newPosition truncateTo: (collection size).	newBufferPosition = oldBufferPosition ifFalse: [ 		self flush.		fileID position: newBufferPosition.		bufferSize := collection size min: ( readLimit - newBufferPosition).		collection := self defaultBufferClass new: self defaultBufferSize.		bufferSize > 0 ifTrue: [ fileID readString: collection size: bufferSize ].	].	position := newPosition."	rwmode ifTrue: [ readLimit := newPosition ]."	^ position.! !!BinaryFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	^ ByteArray! !!TextFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	^ String! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!concreteStream	"Who should we really direct class queries to?  "	^ UnbufferedFileStream.! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!fileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new open: fileName forWrite: true! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!forceNewFileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new openForOverwrite: fileName! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!readOnlyFileNamed: fileName 	"Open an existing file with the given name for reading."	| f |	f := self new open: fileName forWrite: false.	^ f isNil		ifFalse: [f]		ifTrue: ["File does not exist..."			((FileDoesNotExistException fileName: fileName) readOnly: true) signal].	"StandardFileStream readOnlyFileNamed: 'kjsd.txt' "! !!BufferedFileStream class methodsFor: 'as yet unclassified'!initialize	self initializeDefaultBufferSize.! !!BufferedFileStream class methodsFor: 'as yet unclassified'!initializeDefaultBufferSize	DefaultBufferSize := 4096.! !!BufferedFileStream class methodsFor: 'as yet unclassified'!new	^ TextFileStream new.! !!UnhandledError methodsFor: 'as yet unclassified'!devDefaultAction	"The current computation is terminated. The cause of the error should be logged or reported to the user. If the program is operating in an interactive debugging environment the computation should be suspended and the debugger activated."	(GtkMessageDialog question: exception messageText, ', debug it?' ) = #yes		ifTrue: [ ^Processor activeProcess debugError: exception ]."	^ Processor activeProcess terminate."! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!checkType: value	^ value isInteger and: [ value >= 0 and: [ value <= self max ] ]! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	^ handle unsignedLongAt: 1 bigEndian: self isBigEndian.! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!min	^ 0! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!store: anInteger in: handle	handle unsignedLongAt: 1 put: anInteger bigEndian: self isBigEndian.! !!UnsignedByte class methodsFor: 'as yet unclassified'!max			^ 255! !!UnsignedInteger class methodsFor: 'as yet unclassified'!max			^ 4294967295! !!UnsignedShortInteger class methodsFor: 'as yet unclassified'!max			^ 65535! !!Workspace methodsFor: 'as yet unclassified'!buildMenuBar	| menu  edit  |	menu := GtkMenuBar new.	edit := GtkMenu new.	menu		append: AppLauncher fileMenu;		append: (edit createMenuItem: '_Edit');		append: workspaceView menu;		append: AppLauncher toolsMenu;		append: AppLauncher helpMenu.					^ menu.! !!Workspace methodsFor: 'as yet unclassified'!buildToolBar	| toolBar |	^ GtkToolbar new		appendItems: workspaceView toolBar;		yourself! !!Workspace methodsFor: 'as yet unclassified'!defaultCodeViewClass	^ WorkspaceView! !!Workspace methodsFor: 'as yet unclassified'!initialize	workspaceView := self defaultCodeViewClass new.	self container: (GtkVBox new		packStart: (self buildMenuBar) expand: false;		packStart: (self buildToolBar) expand: false;		packStart: (workspaceView view);		packStart: (GtkStatusbar new) expand: false	).! !!Workspace methodsFor: 'as yet unclassified'!inspectedVar: anObject	workspaceView inspectedVar: anObject.! !!TranscriptCodeEditor methodsFor: 'as yet unclassified'!defaultCodeViewClass	^ TranscriptCodeView! !!Workspace class methodsFor: 'as yet unclassified'!defaultSize	^ 640@480.! !!Workspace class methodsFor: 'as yet unclassified'!title	^'Workspace'! !!TranscriptCodeEditor class methodsFor: 'as yet unclassified'!title	^'Transcript'! !BufferedFileStream initialize!TranscriptCodeView initialize!TraitBehavior removeSelector: #initializeUsers!Application subclass: #Shell	instanceVariableNames: 'bindings'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!ExternalValue initialize!NativeFunctionRelocation removeSelector: #addressRelativeTo:!NativeFunctionRelocation removeSelector: #function!NativeFunctionRelocation removeSelector: #functionName!NativeFunctionRelocation removeSelector: #functionName:!NativeFunctionRelocation removeSelector: #patch:!NativeFunctionRelocation removeSelector: #patch:with:!ReadOnlyAsciiZ class removeSelector: #objectFromHandle:!ProcessorScheduler removeSelector: #activeProcess2!ProcessorScheduler removeSelector: #activeThreadData!ProcessorScheduler removeSelector: #primActiveThreadData!Process removeSelector: #threadData:!PrimitiveType class removeSelector: #defaultHandlerType!PrimitiveType class removeSelector: #instantiateHandler!NativeFunction removeSelector: #address!NativeFunction removeSelector: #bind!NativeFunction removeSelector: #invoke!NativeFunction removeSelector: #invokeAnswering:!NativeFunction removeSelector: #invokeAnswering:with:!NativeFunction removeSelector: #invokeAnswering:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:withArguments:!NativeFunction removeSelector: #invokeWith:!NativeFunction removeSelector: #invokeWith:with:!NativeFunction removeSelector: #invokeWith:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:with:with:!NativeFunction removeSelector: #invokeWithArguments:!NativeFunction removeSelector: #name!NativeFunction removeSelector: #name:!NativeFunction removeSelector: #throwNotKnownError!LibraryData removeSelector: #primitiveGetValue!LibExample initialize!LibC6 initialize!LibC6 removeSelector: #initializeUnistd!LibC6 removeSelector: #openPath:flags:!LibC6 removeSelector: #write2:buffer:size:!LibC removeSelector: #close!GPointer class removeSelector: #instantiateHandler!FileStream removeSelector: #position!FileDescriptor initialize!FileDescriptor removeSelector: #movePositionTo:!FileDescriptor removeSelector: #name!FileDescriptor removeSelector: #name:!FileDescriptor removeSelector: #positionFromEns:!FileDescriptor removeSelector: #setPositionAt:!FileDescriptor removeSelector: #setPositionFromEndAt:!CDeclFunction class removeSelector: #name:libraryNamed:returnType:argTypes:!ExecutableFunction class removeSelector: #name:library:!ExecutableFunction class removeSelector: #name:libraryNamed:!CDeclFunction removeSelector: #classFromType:!CDeclFunction removeSelector: #throwExternalFunctionError!ExecutableFunction removeSelector: #address!ExecutableFunction removeSelector: #bind!ExecutableFunction removeSelector: #invoke!ExecutableFunction removeSelector: #invokeWith:!ExecutableFunction removeSelector: #invokeWith:with:!ExecutableFunction removeSelector: #invokeWith:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithArguments:!ExecutableFunction removeSelector: #invokeWithReceiver:!ExecutableFunction removeSelector: #invokeWithReceiver:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:withArguments:!ExecutableFunction removeSelector: #library!ExecutableFunction removeSelector: #library:!ExecutableFunction removeSelector: #libraryName!ExecutableFunction removeSelector: #libraryNamed:!ExecutableFunction removeSelector: #name!ExecutableFunction removeSelector: #name:!ExecutableFunction removeSelector: #name:library:!ExecutableFunction removeSelector: #name:libraryNamed:!ExecutableFunction removeSelector: #primInvokeReceiver:withArguments:!ExecutableFunction removeSelector: #primInvokeWithArguments:!ExecutableFunction removeSelector: #primInvokeWithReceiver:withArguments:!ExecutableFunction removeSelector: #throwNotKnownError!ExternalSymbol removeSelector: #callingConventionString!ExternalObjectProxy removeSelector: #register!ExternalObjectProxy removeSelector: #unregister!AsciiZ class removeSelector: #objectFromHandle:!Executable class removeSelector: #huenul!DynamicLibrary class removeSelector: #addLibrary:named:!DynamicLibrary class removeSelector: #huemul!DynamicLibrary initialize!DynamicLibrary class removeSelector: #name:!DynamicLibrary class removeSelector: #named:!ExternalObject class removeSelector: #handle:!ExternalObject initialize!ExternalObject class removeSelector: #registry!ExternalObject class removeSelector: #registry:!AsciiZ removeSelector: #setFrom:!ExternalBuffer removeSelector: #finalize!ExternalBuffer removeSelector: #selfCheck!ExternalBuffer removeSelector: #setFrom:!ExternalBuffer removeSelector: #storeInto:size:!Executable removeSelector: #initialize!Executable removeSelector: #instantiateFunctionClass:!Executable removeSelector: #name:!Executable removeSelector: #nativeFunctionNamed:!Executable removeSelector: #primitiveOpen!DynamicLibrary removeSelector: #addExternal:!DynamicLibrary removeSelector: #basicName!DynamicLibrary removeSelector: #bind:!DynamicLibrary removeSelector: #bindFunction:!DynamicLibrary removeSelector: #cDeclFunctionNamed:returnType:argTypes:!DynamicLibrary removeSelector: #primitiveBind:!DynamicLibrary removeSelector: #primitiveBindFunction:!ExternalObject removeSelector: #isNullPointer!Object subclass: #ExternalObject	instanceVariableNames: 'handle'	classVariableNames: 'Registry'	poolDictionaries: ''	category: 'FFI-Types'!ExternalFunctionError class removeSelector: #function:!ExternalFunctionError removeSelector: #function!ExternalFunctionError removeSelector: #function:!ExternalFunctionError removeSelector: #isResumable!Error subclass: #ExternalFunctionError	instanceVariableNames: 'functionName'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!Application class removeSelector: #start!Application class removeSelector: #startWithArguments:!Class removeSelector: #superclass:methodDict:format:name:organization:instVarNames:classPool:sharedPools:!ClassBuilder removeSelector: #computeFormat:instSize:forSuper:ccIndex:!ClassBuilder removeSelector: #format:variable:words:pointers:weak:!Smalltalk removeClassNamed: #SystemChangeNotifierTest!RBProgramNodeVisitor subclass: #ASTChecker	instanceVariableNames: 'scope varsChangedInSend'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!RBProgramNodeVisitor subclass: #ASTTranslator	instanceVariableNames: 'methodBuilder receiverForCascade'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #Application	instanceVariableNames: 'arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!AssembleInstruction subclass: #AssembleCMov	instanceVariableNames: ''	classVariableNames: 'Condition'	poolDictionaries: ''	category: 'Exupery'!Object subclass: #AssemblerExupery	instanceVariableNames: 'stream blockAddresses jumpOffsets bytecodes instructionEncoders plugin relocator picEntries debugCollector source'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #BlockClosure	instanceVariableNames: 'method environment'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Contexts'!PluggableGtkSimpleApplication subclass: #ClassFinder	instanceVariableNames: 'classTrait'	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!Object subclass: #ColouringRegisterAllocator	instanceVariableNames: 'source result machine interferenceGraph registerStack registerFile registerTable spiltRegisters hasSpilt coloursUsed simplifyWorklist spillWorklist moveWorklist coalescedMoves isValidating deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #DebugInfo	instanceVariableNames: 'codeSourceReferences argVarsReferences tempVarsReferences capturedVarsReferences'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!Object subclass: #EventManager	instanceVariableNames: 'actionMap'	classVariableNames: 'ActionMaps'	poolDictionaries: ''	category: 'System-Object'!Error subclass: #ExternalFunctionError	instanceVariableNames: 'functionName '	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!Object subclass: #ExternalObject	instanceVariableNames: 'handle '	classVariableNames: 'Registry '	poolDictionaries: ''	category: 'FFI-Types'!ExternalObject subclass: #DynamicLibrary	instanceVariableNames: 'name symbolCache'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!DynamicLibrary subclass: #Executable	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!ExternalObject subclass: #ExternalBuffer	instanceVariableNames: 'size'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalBuffer subclass: #AsciiZ	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!DynamicLibrary class	instanceVariableNames: 'default'!ExternalObject subclass: #ExternalObjectProxy	instanceVariableNames: 'object'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalObjectProxy subclass: #ExternalArrayProxy	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalObject subclass: #ExternalSymbol	instanceVariableNames: 'name library'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!ExternalSymbol subclass: #ExecutableFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!ExecutableFunction subclass: #CDeclFunction	instanceVariableNames: 'returnType argTypes'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Error subclass: #ExternalSymbolError	instanceVariableNames: 'symbolName'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!ExternalObject subclass: #FileDescriptor	instanceVariableNames: ''	classVariableNames: 'StandardDescriptors'	poolDictionaries: ''	category: 'FFI-Types'!Error subclass: #FileStreamException	instanceVariableNames: 'fileName'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #CannotDeleteFileException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #FileDoesNotExistException	instanceVariableNames: 'readOnly'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #FileExistsException	instanceVariableNames: 'fileClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!AssemblyCopier subclass: #FinalCopier	instanceVariableNames: 'deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!LexicalScope subclass: #FunctionScope	instanceVariableNames: 'thisContextVar thisEnvVar tempVars capturedVars isHome hasInnerFreeVars hideTemps argVars uninitializedTemps capturedParentEnv'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #GIRBuilder	instanceVariableNames: 'ir currentBlock machine relocationInfo primitiveNode literals thisEnvVar cacheMap literalTemp source start stop debugInfo'	classVariableNames: 'InlinedSelectors SpecialConstants SpecialSelectors'	poolDictionaries: ''	category: 'Compiler-IR'!LexicalScope subclass: #InstanceScope	instanceVariableNames: 'vars'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!DynamicLibrary subclass: #LibC6	instanceVariableNames: ''	classVariableNames: 'LSeekDirectives OpenFlags'	poolDictionaries: ''	category: 'FFI-Libraries'!Object subclass: #LibExample	instanceVariableNames: ''	classVariableNames: 'GETPID'	poolDictionaries: ''	category: 'Guille-Test'!DynamicLibrary subclass: #LibReadLine	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!ExternalSymbol subclass: #LibraryData	instanceVariableNames: 'type'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Object subclass: #LivenessAnalyser	instanceVariableNames: 'source hasUpdated isValidating deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #MedLanguage	instanceVariableNames: 'in out start stop'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedCMov	instanceVariableNames: 'type from to'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedEnter	instanceVariableNames: 'argument'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedLeave	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedLiteral	instanceVariableNames: 'literal'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLiteral subclass: #MedFunction	instanceVariableNames: 'block byteCodeAddress'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!ExecutableFunction subclass: #NativeFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Object subclass: #PrimitiveType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!PrimitiveType subclass: #IntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!RBProgramNode subclass: #RBReturnNode	instanceVariableNames: 'return value homeBinding frameBinding'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Nodes'!ExternalObject subclass: #ReadOnlyAsciiZ	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SemanticWarning subclass: #RedeclaredVariableWarning	instanceVariableNames: 'variableNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #RelocationInfo	instanceVariableNames: 'offset'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #ExecutableFunctionRelocation	instanceVariableNames: 'functionName'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #FunctionRelocation	instanceVariableNames: 'function'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #LiteralRelocation	instanceVariableNames: 'literals'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!ExecutableFunctionRelocation subclass: #NativeFunctionRelocation	instanceVariableNames: 'libraryName'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!NativeFunctionRelocation subclass: #ExternalFunctionRelocation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #PrimitiveRelocation	instanceVariableNames: 'number'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!Object subclass: #ScopeVar	instanceVariableNames: 'scope usage'	classVariableNames: 'UsageAutomaton'	poolDictionaries: ''	category: 'Compiler-Semantics'!ScopeVar subclass: #GlobalVar	instanceVariableNames: 'assoc'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!ScopeVar subclass: #LocalVar	instanceVariableNames: 'name index'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!LocalVar subclass: #ArgVar	instanceVariableNames: 'isArg'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!LocalVar subclass: #CapturedVar	instanceVariableNames: 'sourceTemp'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!ByteArray variableByteSubclass: #ExternalValue	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!Object subclass: #SharedPool	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Pools'!Application subclass: #Shell	instanceVariableNames: 'bindings '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!IntegerType subclass: #SignedIntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedByte	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedShortInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!Object subclass: #SourceReference	instanceVariableNames: 'sourceStart sourceStop codeStop'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!RelocationInfo subclass: #SpecialSelectorRelocation	instanceVariableNames: 'specialSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!Model subclass: #StringHolder	instanceVariableNames: 'contents'	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Kernel-Remnants'!Object subclass: #SystemTracer	instanceVariableNames: 'byteStream traceQueue oopMap nextChunk nilOop count'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Tracer'!LocalVar subclass: #TempVar	instanceVariableNames: 'isArg'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Error subclass: #TraitException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Kernel'!TraitException subclass: #TraitCompositionException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Composition'!Error subclass: #TypeConvertionError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!FileStream subclass: #UnbufferedFileStream	instanceVariableNames: 'name fileID'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!Smalltalk renameClassNamed: #BufferedFileStream2 as: #BufferedFileStream!UnbufferedFileStream subclass: #BufferedFileStream	instanceVariableNames: ''	classVariableNames: 'DefaultBufferSize'	poolDictionaries: ''	category: 'Files-Kernel'!BufferedFileStream subclass: #BinaryFileStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!BufferedFileStream subclass: #TextFileStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!IntegerType subclass: #UnsignedIntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedByte	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedShortInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SemanticWarning subclass: #UnusedVariableWarning	instanceVariableNames: 'variableNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #VarReference	instanceVariableNames: 'name'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!RelocationInfo subclass: #VariableRelocation	instanceVariableNames: 'variable'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!PluggableGtkSimpleApplication subclass: #Workspace	instanceVariableNames: 'workspaceView'	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!Workspace subclass: #TranscriptCodeEditor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!!Object methodsFor: 'as yet unclassified'!errorSubscriptBounds: index 	"Create an error notification that an improper integer was used as an index."	self error: 'subscript is out of bounds: ' , index printString! !!Object methodsFor: 'as yet unclassified'!executeMethod: compiledMethod withArgs: argArray	"Execute compiledMethod against the receiver and args in argArray"	| selector |	<primitive: 188>	selector _ Symbol new.	self class addSelectorSilently: selector withMethod: compiledMethod.	^ [self perform: selector withArguments: argArray]		ensure: [self class basicRemoveSelector: selector]! !!Object methodsFor: 'as yet unclassified'!withArgs: argArray executeMethod: compiledMethod	"For compatibility with Aqueak"	self executeMethod: compiledMethod withArgs: argArray! !!Application methodsFor: 'as yet unclassified'!arguments	^ arguments.! !!Application methodsFor: 'as yet unclassified'!arguments: anArray	arguments := anArray.! !!Application methodsFor: 'as yet unclassified'!main	self subclassResponsibility.! !!Application methodsFor: 'as yet unclassified'!startUp	Smalltalk startUp.	^ self main.! !!Behavior methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return true if it is safe to zap the method dictionary on #obsolete"	^true! !!Behavior methodsFor: 'as yet unclassified'!isWeak	^ (format bitAnd: 4) = 1.! !!Behavior methodsFor: 'as yet unclassified'!obsolete	"Invalidate and recycle local methods,	e.g., zap the method dictionary if can be done safely."	self canZapMethodDictionary		ifTrue: [self methodDict: self emptyMethodDictionary].! !!Behavior methodsFor: 'as yet unclassified'!removeSelector: selector	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method."	| oldMethod |		oldMethod _ self methodDict at: selector ifAbsent: [^ self].	self methodDict removeKey: selector.	"Now flush Squeak's method cache, either by selector or by method"	oldMethod flushCache.	selector flushCache! !!Behavior methodsFor: 'as yet unclassified'!selectorsAndMethodsDo: aBlock	"Evaluate selectorBlock for all the message selectors in my method dictionary."	^ self methodDict keysAndValuesDo: aBlock! !!Behavior methodsFor: 'as yet unclassified'!setTraitComposition: aTraitComposition	| oldComposition |	(self hasTraitComposition not and: [aTraitComposition isEmpty]) ifTrue: [^self].	aTraitComposition assertValidUser: self.	oldComposition _ self traitComposition.	self traitComposition: aTraitComposition."	self applyChangesOfNewTraitCompositionReplacing: oldComposition."		oldComposition traits do: [:each | each removeUser: self].	aTraitComposition traits do: [:each | each addUser: self]! !!Behavior methodsFor: 'as yet unclassified'!traitCompositionString	^self hasTraitComposition		ifTrue: [self traitComposition asString]		ifFalse: ['{}']! !!Behavior methodsFor: 'as yet unclassified'!typeOfClass	"Answer a symbol uniquely describing the type of the receiver"	self isWeak ifTrue: [ ^ #weak ].	^ (format bitAnd: 3) caseOf: {		[ 0 ] -> [ #normal ].		[ 1 ] -> [ #variable ].		[ 2 ] -> [ #bytes ].		[ 3 ] -> [ #words ]	}! !!Behavior methodsFor: 'as yet unclassified'!whichSelectorsReferTo: literal	"Answer a set of selectors whose methods access the argument as a literal."	| who |	who _ IdentitySet new.	self selectorsAndMethodsDo: 		[:sel :method |		(method hasLiteral: literal)			ifTrue:				[((literal isVariableBinding) not					or: [method literals allButLast includes: literal])						ifTrue: [who add: sel]]].	^ who! !!BehaviorTest methodsFor: 'as yet unclassified'!testBehaviorSubclasses	"self run: #testBehaviorSubclasses"		| b b2 |"	b := Behavior new.	b superclass: OrderedCollection.	b methodDictionary: Dictionary new.	self shouldnt: [b subclasses ] raise: Error.	self shouldnt: [b withAllSubclasses] raise: Error.	self shouldnt: [b allSubclasses] raise: Error.	b2 := Behavior new.	b2 superclass: b.	b2 methodDictionary: Dictionary new.	self assert: (b subclasses includes: b2).	self assert: (b withAllSubclasses includes: b)."! !!BlockClosure methodsFor: 'as yet unclassified'!valueWithArguments: anArray 	"Evaluate the block with given args. Fail if the block expects other than the given number of arguments."	^ environment executeMethod: method withArgs: anArray ! !!ClassBrowser methodsFor: 'as yet unclassified'!buildClassCategoriesView	| model tree col cell |	tree := nil->nil.	SystemOrganization categories do: [ :each |		| category |		category := tree.		(each subStrings: '-') do: [ :cat |			category value ifNil: [ category value: Dictionary new].			category := category value associationAt: cat ifAbsent: [ category value at: cat put: nil. category value associationAt: cat ]		]	].	model := GtkTreeStore new: {String. String}.	[ self addSubcategoriesFrom: tree fromIter: nil inModel: model ] fork.	classCategoriesTree := GtkTreeView model: model.	col := GtkTreeViewColumn title: 'Class categories'.	cell := GtkCellRendererPixbuf new.	col		packStart: cell expand: false;		addAttribute: #stockId column: 1 on: cell.	cell := GtkCellRendererText new.	col		packStart: cell;		addAttribute: #text column: 0 on: cell.		classCategoriesTree appendColumn: col.	classCategoriesTree selection when: #changed send: #onClassCategoryChanged to: self.	classCategoriesTree enableTreeLines: true.	^ GtkScrolledWindow withChild: classCategoriesTree! !!ClassBrowser methodsFor: 'as yet unclassified'!loadClassMethodsOf: aClassClass	| iter |	classMethodsTree model clear.	aClassClass organization categories do: [ :cat |		iter := classMethodsTree model append: nil->{cat asString. true. 'grey'. 'gtk-info'}.		(aClassClass organization listAtCategoryNamed: cat) asSortedCollection do: [ :sel |			classMethodsTree model append: iter->{sel asString. false. 'grey'. 'gtk-execute'}		]	].	classMethodsTree expandAll.! !!ClassBrowser methodsFor: 'as yet unclassified'!loadInstanceMethodsOf: aClass	| iter |	instanceMethodsTree model clear.	aClass organization categories do: [ :cat |		iter := instanceMethodsTree model append: nil->{cat asString. true. 'grey'. 'gtk-info'}.		(aClass organization listAtCategoryNamed: cat) asSortedCollection do: [ :sel |			instanceMethodsTree model append: iter->{sel asString. false. 'grey'. 'gtk-execute'}		]	].	instanceMethodsTree expandAll.! !!ClassBrowser methodsFor: 'as yet unclassified'!onClassHierarchyChanged	| class iter path newIter aCategory classHierarchySelectedRow classesTreeSelectedRow |	classHierarchySelectedRow := classHierarchyTree selectedRow.	classHierarchySelectedRow ifNotNil: [		class := Smalltalk at: (classHierarchySelectedRow first asSymbol).							aCategory := class category.		( aCategory isNotNil and: [ aCategory ~= selectedClassCategory ] ) ifTrue: [			selectedClassCategory := aCategory.			iter := classCategoriesTree model firstIter.			newIter := nil.			(aCategory subStrings: '-') do: [ :cat |				newIter ifNotNil: [ iter := newIter ].				iter := self classCategoryFor: cat firstIter: iter.				newIter := classCategoriesTree model firstChildAt: iter.			].			path := classCategoriesTree model pathFromIter: iter.			classCategoriesTree expandRowsUpTo: path.			classCategoriesTree moveCursorAt: path.					classesTree model clear.			(SystemOrganization listAtCategoryNamed: aCategory) sort do: [ :ea |				classesTree model append: {ea asString. 'gtk-execute'}			]		].							self selectClass: class.	]! !!ClassBuilder methodsFor: 'as yet unclassified'!formatForType: type	^ type caseOf: {		[ #normal ] -> [ 0 ].		[ #variable ] -> [ 1 ].		[ #bytes ] -> [ 2 ].		[ #words ] -> [ 3 ].		[ #weak ] -> [ 5 "binary: 4 + 0 + 0 + 1" ]	} otherwise: [ self error: 'Unknown class type' ].! !!ClassBuilder methodsFor: 'as yet unclassified'!needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Answer whether we need a new subclass to conform to the requested changes"	"Check if we really need a new subclass"	oldClass ifNil:[^true]. "yes, it's a new class"	newSuper == oldClass superclass ifFalse:[^true]. "yes, it's a superclass change"	type = oldClass typeOfClass ifFalse:[^true]. "yes, it's a format change"	instVars = oldClass instVarNames ifFalse:[^true]. "yes, it's an iVar change"	^false! !!ClassBuilder methodsFor: 'as yet unclassified'!newSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Create a new subclass of the given superclass with the given specification."	| newClass |	(oldClass == nil or:[oldClass isMeta not]) 		ifTrue:[newClass := self privateNewSubclassOf: newSuper from: oldClass]		ifFalse:[newClass := oldClass clone].	newClass 		superclass: newSuper		methodDictionary: "Method"Dictionary new		instanceSize: (newSuper instSize + instVars size)		format: (self formatForType: type);		setInstVarNames: instVars.	oldClass ifNotNil:[		newClass organization: oldClass organization.		"Recompile the new class"		oldClass hasMethods 			ifTrue:[newClass compileAllFrom: oldClass].		oldClass hasTraitComposition ifTrue: [			newClass setTraitComposition: oldClass traitComposition copyTraitExpression ].		oldClass class hasTraitComposition ifTrue: [			newClass class setTraitComposition: oldClass class traitComposition copyTraitExpression ].				self recordClass: oldClass replacedBy: newClass.	].	(oldClass == nil or:[oldClass isObsolete not]) 		ifTrue:[newSuper addSubclass: newClass]		ifFalse:[newSuper addObsoleteSubclass: newClass].	^newClass! !!ClassBuilder methodsFor: 'as yet unclassified'!privateNewSubclassOf: newSuper from: oldClass	"Create a new meta and non-meta subclass of newSuper using oldClass as template"	"WARNING: This method does not preserve the superclass/subclass invariant!!"	| newSuperMeta oldMeta newMeta |	oldClass ifNil:[^self privateNewSubclassOf: newSuper].	newSuperMeta _ newSuper ifNil:[Class] ifNotNil:[newSuper class].	oldMeta _ oldClass class.	newMeta _ oldMeta clone.	newMeta 		superclass: newSuperMeta		methodDictionary: "Method"Dictionary new		instanceSize: oldMeta instSize		format: oldMeta format;		setInstVarNames: oldMeta instVarNames;		organization: oldMeta organization.	"Recompile the meta class"	oldMeta hasMethods 		ifTrue:[newMeta compileAllFrom: oldMeta].	"Record the meta class change"	self recordClass: oldMeta replacedBy: newMeta.	"And create a new instance"	^newMeta adoptInstance: oldClass from: oldMeta! !!ClassBuilder methodsFor: 'as yet unclassified'!reshapeClass: oldClass toSuper: newSuper	"Reshape the given class to the new super class. Recompile all the methods in the newly created class. Answer the new class."	| instVars |	instVars _ instVarMap at: oldClass name ifAbsent:[oldClass instVarNames].	^self newSubclassOf: newSuper 			type: oldClass typeOfClass 			instanceVariables: instVars 			from: oldClass! !!ClassDescription methodsFor: 'as yet unclassified'!classVersion	"Default.  Any class may return a later version to inform readers that use ReferenceStream.  8/17/96 tk"	"This method allows you to distinguish between class versions when the shape of the class 	hasn't changed (when there's no change in the instVar names).	In the conversion methods you usually can tell by the inst var names 	what old version you have. In a few cases, though, the same inst var 	names were kept but their interpretation changed (like in the layoutFrame).	By changing the class version when you keep the same instVars you can 	warn older and newer images that they have to convert."	^ 0! !!ClassDescription methodsFor: 'as yet unclassified'!obsolete	"Make the receiver obsolete."	superclass removeSubclass: self.	self organization: nil.	super obsolete.! !!ClassDescription methodsFor: 'as yet unclassified'!removeSelector: selector 	"Remove the message whose selector is given from the method 	dictionary of the receiver, if it is there. Answer nil otherwise."		| priorMethod priorProtocol | 	priorMethod _ self compiledMethodAt: selector ifAbsent: [^ nil].	priorProtocol _ self whichCategoryIncludesSelector: selector.	SystemChangeNotifier uniqueInstance		doSilently: [self organization removeElement: selector ].	super removeSelector: selector.	SystemChangeNotifier uniqueInstance 			methodRemoved: priorMethod selector: selector inProtocol: priorProtocol class: self.! !!ClassDescription methodsFor: 'as yet unclassified'!updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil	| currentCategory effectiveCategory sel changedCategories composition |	changedCategories _ IdentitySet new.	composition := self hasTraitComposition		ifTrue: [self traitComposition]		ifFalse: [TraitComposition new].	(composition methodDescriptionsForSelector: aSymbol) do: [:each |		sel _ each selector.		(self includesLocalSelector: sel) ifFalse: [			currentCategory _ self organization categoryOfElement: sel.			effectiveCategory _ each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.			effectiveCategory isNil ifTrue: [				currentCategory ifNotNil: [changedCategories add: currentCategory].				self organization removeElement: sel.			] ifFalse: [				((currentCategory isNil or: [currentCategory == ClassOrganizer ambiguous or: [currentCategory == oldCategoryOrNil]]) and: [currentCategory ~~ effectiveCategory]) ifTrue: [					currentCategory ifNotNil: [changedCategories add: currentCategory].					self organization 						classify: sel 						under: effectiveCategory						suppressIfDefault: false]]]].	^ changedCategories! !!ClassDescription methodsFor: 'as yet unclassified'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	(self includesSelector: aSelector)		ifTrue: [^ self organization categoryOfElement: aSelector]		ifFalse: [^nil]! !!Class methodsFor: 'as yet unclassified'!classPool: aDictionary	classPool _ aDictionary! !!Class methodsFor: 'as yet unclassified'!copy 	| newClass |	newClass _ self class copy new		superclass: superclass		methodDict: self methodDict copy		instanceSize: self instSize		format: format		name: name		organization: self organization copy		instVarNames: instanceVariables copy		classPool: classPool copy		sharedPools: sharedPools.	Class instSize+1 to: self class instSize do:		[:offset | newClass instVarAt: offset put: (self instVarAt: offset)].	^ newClass! !!Class methodsFor: 'as yet unclassified'!deactivate	"A remnant from the 3.3a modules work, retained . Does nothing, but may be overridden in Metaclasses."! !!Class methodsFor: 'as yet unclassified'!isSystemDefined	"Answer true if the receiver is a system-defined class, and not a UniClass (an instance-specific lightweight class)"	^ self == self officialClass! !!Class methodsFor: 'as yet unclassified'!obsolete	"Change the receiver and all of its subclasses to an obsolete class."	self == Object 		ifTrue: [^self error: 'Object is NOT obsolete'].	self setName: 'AnObsolete' , self name.	Object class instSize + 1 to: self class instSize do:		[:i | self instVarAt: i put: nil]. "Store nil over class instVars."	self classPool: nil.	self sharedPools: nil.	self class obsolete.	super obsolete.! !!Class methodsFor: 'as yet unclassified'!officialClass	"I am not a UniClass.  (See Player officialClass).  Return the class you use to make new subclasses."	^ self! !!Class methodsFor: 'as yet unclassified'!removeFromSystem	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."	self removeFromSystem: true.! !!Class methodsFor: 'as yet unclassified'!removeFromSystem: logged	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."		"keep the class name and category for triggering the system change message. If we wait to long, then we get obsolete information which is not what we want."	"tell class to deactivate and unload itself-- two separate events in the module system"	self deactivate; unload.	self superclass ifNotNil:		["If we have no superclass there's nothing to be remembered"		self superclass addObsoleteSubclass: self].	self environment forgetClass: self logged: logged.	self obsolete.! !!Class methodsFor: 'as yet unclassified'!sharedPools: aCollection	sharedPools _ aCollection! !!Class methodsFor: 'as yet unclassified'!superclass: sup methodDict: md instanceSize: is format: ft name: nm organization: org instVarNames: nilOrArray classPool: pool sharedPools: poolSet 	"Answer an instance of me, a new class, using the arguments of the 	message as the needed information.	Must only be sent to a new instance; else we would need Object flushCache."	superclass := sup.	methodDict := md.	instanceSize := is.	format := ft.	name := nm.	instanceVariables := nilOrArray.	classPool := pool.	sharedPools := poolSet.	self organization: org.! !!Class methodsFor: 'as yet unclassified'!unload	"Sent when a the class is removed.  Does nothing, but may be overridden by (class-side) subclasses."! !!Class methodsFor: 'as yet unclassified'!variableByteSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable byte-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableByteSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!variableSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable pointer variables."	^(ClassBuilder new)		superclass: self		variableSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!variableWordSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable word-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableWordSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!weakSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have weak indexable pointer variables."	^(ClassBuilder new)		superclass: self		weakSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!AppLauncher class methodsFor: 'as yet unclassified'!openAboutHuemul	| dlg logo |	logo := GdkPixbuf fromFile: 'Huemul.jpg'.	dlg := GtkAboutDialog new.	dlg		aboutDialogName: 'Huemul Smalltalk';		version: '0.8';		license: (StandardFileStream readOnlyFileNamed: 'LICENSE') upToEnd;		website: 'http://www.guillermomolina.com.ar/huemul';		comments: 'This is Huemul Smalltalk';		authors: {'Guillermo Adrian Molina'};		logo: logo.	dlg runAndDestroy! !!AppLauncher class methodsFor: 'as yet unclassified'!openWorkspace	^ Workspace open! !!Application class methodsFor: 'as yet unclassified'!startUp	^ self new startUp.! !!Application class methodsFor: 'as yet unclassified'!startUpWithArguments: arguments	| application |	application := self new.	application arguments: arguments.	^ application startUp.! !!Behavior class methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return false since zapping the method dictionary of Behavior class or its subclasses will cause the system to fail."	^false! !!ClassBrowser class methodsFor: 'as yet unclassified'!defaultSize	^ 640@480.! !!ClassBrowser class methodsFor: 'as yet unclassified'!title	^'Class browser'! !!ClassFinder class methodsFor: 'as yet unclassified'!defaultSize	^ 200@300.! !!ClassFinder class methodsFor: 'as yet unclassified'!title	^'Class finder'! !!CompiledMethod methodsFor: 'as yet unclassified'!hasLiteral: literal	"Answer whether the receiver references the argument, literal."	literals ifNil: [ ^false ].	^ literals hasLiteral: literal.! !!CompiledMethod methodsFor: 'as yet unclassified'!sourcePointer	"Answer the integer which can be used to find the source file and position for this method.	Not sources yet"	^ 0! !!CompiledMethodWithNode class methodsFor: 'as yet unclassified'!method: aCompiledMethod node: aMethodNode	^ self new method: aCompiledMethod; node: aMethodNode.! !!Compiler methodsFor: 'as yet unclassified'!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into a method. In other words, if receiver is not nil, then the text can refer to instance variables of that receiver (the Inspector uses this). If aContext is not nil, the text can refer to temporaries in that context (the Debugger uses this). If aRequestor is not nil, then it will receive a notify:at: message before the attempt to evaluate is aborted. Finally, the compiled method is directly invoked without modifying the receiving-class."	"| methodNode method value |	  	(Preferences compileUseNewCompiler or: 			[aContext ifNotNil: [aContext method isClosureCompiled] ifNil: [false]]) ifTrue: 				[^ self evaluate2: textOrStream 					    in: aContext 					    to: receiver 					    notifying: aRequestor 					    ifFail: failBlock 					    logged: logFlag].		class := (aContext isNil 		ifTrue: [ receiver ] 		ifFalse: [ aContext receiver ])			class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode := self 		translate: sourceStream		noPattern: true 		ifFail: [ ^ failBlock value ].	method := methodNode generate.	self interactive		ifTrue: [ method := method copyWithTempNames: methodNode tempNames ].	value := receiver		executeMethod: method 		withArgs: (context isNil			ifTrue: [ #() ]			ifFalse: [ Array with: aContext ]).	logFlag 		ifTrue: [ SystemChangeNotifier uniqueInstance evaluated: sourceStream contents context: aContext ].	^ value."	| string block |	string _ textOrStream readStream upToEnd.	block := self compileDoIt: string in: aContext to: receiver notifying: aRequestor ifFail: [^ failBlock value] log: logFlag.	^ block value! !!Exception methodsFor: 'as yet unclassified'!messageText	messageText ifNil: [ ^ self class name asString ].	^messageText! !!Exception methodsFor: 'as yet unclassified'!receiver	^ self signalerContext receiver! !!ExternalFunctionError methodsFor: 'as yet unclassified'!functionName	"Answer the function name that was beiing used."	^functionName! !!ExternalFunctionError methodsFor: 'as yet unclassified'!functionName: argument	"Specify the function name that was beiing used."	functionName := argument! !!ExternalFunctionError class methodsFor: 'as yet unclassified'!functionName: argument	^self new functionName: argument; yourself! !!ExternalObject methodsFor: 'as yet unclassified'!= anObject 	(anObject isKindOf: self class)		ifTrue: [^ anObject handle = self handle]		ifFalse: [^ false]! !!ExternalObject methodsFor: 'as yet unclassified'!beNull	^ handle beNull.! !!ExternalObject methodsFor: 'as yet unclassified'!finalize		self free.	self unregister.! !!ExternalObject methodsFor: 'as yet unclassified'!free	"Should override this"! !!ExternalObject methodsFor: 'as yet unclassified'!initialize	handle := self class defaultHandlerClass new.	self register.! !!ExternalObject methodsFor: 'as yet unclassified'!isNull	^ self handle isNull.! !!ExternalObject methodsFor: 'as yet unclassified'!register	Registry add: self.! !!ExternalObject methodsFor: 'as yet unclassified'!unregister		Registry remove: self ifAbsent:[  ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!addSymbol: anExternalSymbol	^ symbolCache at: anExternalSymbol name put: anExternalSymbol.! !!DynamicLibrary methodsFor: 'as yet unclassified'!bindSymbol: anExternalSymbol	self open.	^ self primitiveBindSymbol: anExternalSymbol.! !!DynamicLibrary methodsFor: 'as yet unclassified'!cDeclFunctionNamed: functionName	^ symbolCache at: functionName ifAbsent: [ self error: 'You must initialize the function before using it' ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!close		handle isNull ifFalse: [ 		self primitiveClose		handle beNull.	].! !!DynamicLibrary methodsFor: 'as yet unclassified'!initialize	super initialize.	symbolCache := Dictionary new.! !!DynamicLibrary methodsFor: 'as yet unclassified'!initializeCDeclFunctionNamed: functionName returnType: retType argTypes: argTypesArray	^ symbolCache at: functionName put: 			(CDeclFunction name: functionName library: self  returnType: retType argTypes: argTypesArray)! !!DynamicLibrary methodsFor: 'as yet unclassified'!initializeLibraryDataNamed: symbolName type: type	^ symbolCache at: symbolName put: (LibraryData name: symbolName library: self  type: type)! !!DynamicLibrary methodsFor: 'as yet unclassified'!libraryDataNamed: symbolName	^ symbolCache at: symbolName ifAbsent: [ self error: 'You must initialize the symbol before using it' ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!name	^name! !!DynamicLibrary methodsFor: 'as yet unclassified'!name: aName	name := aName.! !!DynamicLibrary methodsFor: 'as yet unclassified'!nativeFunctionNamed: functionName	^ symbolCache at: functionName ifAbsent: [ 		symbolCache at: functionName put: (NativeFunction name: functionName library: self)	].! !!DynamicLibrary methodsFor: 'as yet unclassified'!open		handle isNull ifTrue: [ self primitiveOpen ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveBindSymbol: anExternalSymbol	"Primitive. Find the given symbol in the library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 203>	^ anExternalSymbol throwNotKnownError.! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveClose	"Primitive. Close the given library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 202>! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveOpen	"Primitive. Open the given library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 198>	self primitiveFailed.! !!DynamicLibrary methodsFor: 'as yet unclassified'!printOn: aStream	aStream nextPutAll: self name.! !!DynamicLibrary methodsFor: 'as yet unclassified'!symbolNamed: symbolName	^ symbolCache at: symbolName ifAbsent: [ self error: 'You must initialize the symbol before using it' ]! !!Executable methodsFor: 'as yet unclassified'!name	^ Utilities executableName ! !!Executable methodsFor: 'as yet unclassified'!primitiveSmallIntegerAdd: receiver with: argument	^ (self nativeFunctionNamed: #primitiveSmallIntegerAdd) invokeReceiver: receiver with: argument.! !!ExternalBuffer methodsFor: 'as yet unclassified'!asByteArray	| array |	size ifNil: [ ^ self class throwTypeConvertionError ].	array := ByteArray new: self basicSize.	self storeInto: array.	^ array	! !!ExternalBuffer methodsFor: 'as yet unclassified'!atAllPut: constant	^ LibC6 default memSet: self constant: constant count: self size.! !!ExternalBuffer methodsFor: 'as yet unclassified'!atAllPutZero	^ self atAllPut: 0.! !!ExternalBuffer methodsFor: 'as yet unclassified'!basicSize	^ size.! !!ExternalBuffer methodsFor: 'as yet unclassified'!byteAt: index	<primitive: 190>	index isNumber		ifTrue: [self errorSubscriptBounds: index]		ifFalse: [self errorNonIntegerIndex].! !!ExternalBuffer methodsFor: 'as yet unclassified'!byteAt: index put: value	<primitive: 191>	index isNumber		ifTrue: [self errorSubscriptBounds: index]		ifFalse: [self errorNonIntegerIndex].! !!ExternalBuffer methodsFor: 'as yet unclassified'!free		handle isNull ifFalse: [ 		LibC6 default free: self.		self beNull.	]! !!ExternalBuffer methodsFor: 'as yet unclassified'!loadFrom: aByteArray	<primitive: 199>	self primitiveFailed.! !!ExternalBuffer methodsFor: 'as yet unclassified'!size	^ self basicSize.! !!ExternalBuffer methodsFor: 'as yet unclassified'!size: anInteger	size := anInteger.! !!ExternalBuffer methodsFor: 'as yet unclassified'!storeInto: aByteArray	<primitive: 218>	^ self class throwTypeConvertionError.! !!AsciiZ methodsFor: 'as yet unclassified'!asString	^ handle toString.! !!AsciiZ methodsFor: 'as yet unclassified'!asString2	| calcSize string |	size ifNil: [ ^ self class throwTypeConvertionError ].	calcSize := self strlen.	calcSize >= self size ifTrue: [ ^ self class throwTypeConvertionError ].	string := String new: calcSize.	self storeInto: string.	^ string! !!AsciiZ methodsFor: 'as yet unclassified'!loadFrom: aString		super loadFrom: aString.	self byteAt: (aString size + 1) put: 0.! !!AsciiZ methodsFor: 'as yet unclassified'!strlen	^ LibC6 default strLen: self.! !!ExternalFunction methodsFor: 'as yet unclassified'!library	^ library! !!ExternalFunction methodsFor: 'as yet unclassified'!library: aLibrary	library := aLibrary! !!ExternalFunction methodsFor: 'as yet unclassified'!name	^name! !!ExternalFunction methodsFor: 'as yet unclassified'!name: aName	name := aName! !!ExternalFunction methodsFor: 'as yet unclassified'!name: aName library: aLibrary	self name: aName.	self library: aLibrary! !!ExternalFunction methodsFor: 'as yet unclassified'!reload	library ifNil: [ ^ self throwNotKnownError ].	self handle: (library findFunction: self)! !!ExternalLibrary methodsFor: 'as yet unclassified'!bindFunction: function	| answer |	answer := self primitiveBindFunction: function.	answer ifNotNil: [ ^ answer ].	self open. "Library may be closed, open it and retry"	answer := self primitiveBindFunction: answer.	answer ifNotNil: [ ^ answer ].	^ function throwNotKnownError.		! !!ExternalLibrary methodsFor: 'as yet unclassified'!closeLibrary		(handle isNotNil and: [ handle isNull not ]) ifTrue: [ self primitiveClose ].	self handle: nil.	functionCache := nil.! !!ExternalLibrary methodsFor: 'as yet unclassified'!openLibrary		self primitiveOpen.	self initializeFunctionCache.! !!ExternalLibrary methodsFor: 'as yet unclassified'!primitiveBindFunction: function	"Primitive. Find the given symbol in the library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 203>	^ nil.! !!ExternalObject class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: self! !!ExternalObject class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalAddress! !!ExternalObject class methodsFor: 'as yet unclassified'!handleFromObject: anObject	^ self handleFromObject: anObject ifError: [ self throwTypeConvertionError ]! !!ExternalObject class methodsFor: 'as yet unclassified'!handleFromObject: anObject ifError: aBlock		(anObject isKindOf: ExternalObject) ifFalse: [ ^ aBlock value ].	^ anObject handle.	! !!ExternalObject class methodsFor: 'as yet unclassified'!initialize	Registry := WeakRegistry new.	Smalltalk addToShutDownList: self.! !!ExternalObject class methodsFor: 'as yet unclassified'!objectFromHandle: handle	^self objectFromHandle: handle ifError: [ self throwTypeConvertionError ]! !!ExternalObject class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; yourself! !!ExternalObject class methodsFor: 'as yet unclassified'!quit	Registry do: [ :each | each free ].	self allSubclassesDo: [ :ea | ea quit ]! !!ExternalObject class methodsFor: 'as yet unclassified'!shutDown: quitting	quitting ifTrue: [ self quit ].! !!ExternalObject class methodsFor: 'as yet unclassified'!throwTypeConvertionError	^ TypeConvertionError new signal! !!DynamicLibrary class methodsFor: 'as yet unclassified'!default	self = DynamicLibrary ifTrue: [ self error: 'Create a class to create its singleton' ].	default ifNil: [	"Represents the executable itself"		default := self new.		default name: self moduleName.		default open.	].	^ default.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!initialize	self = DynamicLibrary ifFalse: [ 		Smalltalk addToShutDownList: self	].! !!DynamicLibrary class methodsFor: 'as yet unclassified'!moduleName	self subClassResponsibility.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!resetLibrary	default := nil.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!shutDown: aBool	default ifNotNil: [ default close ].! !!Executable class methodsFor: 'as yet unclassified'!huemul	^ self default! !!Executable class methodsFor: 'as yet unclassified'!moduleName	^nil.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: ByteArray! !!ExternalBuffer class methodsFor: 'as yet unclassified'!fromByteArray: aByteArray	| anExternalBuffer |		anExternalBuffer := ExternalBuffer new: aByteArray size.	anExternalBuffer setFrom: aByteArray.	^ anExternalBuffer.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!handleFromObject: aByteArray ifError: aBlock		(aByteArray isKindOf: ByteArray) ifFalse: [ 		^ super handleFromObject: aByteArray ifError: aBlock	].	^ ( self fromByteArray: aByteArray ) handle.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!new: size	| anExternalBuffer |	"This space is allocated from the system not 	from Object Memory, you will have to give it back, 	as it is not garbage collected"	anExternalBuffer := LibC6 default malloc: (size +  10).	anExternalBuffer size: size.	^ anExternalBuffer! !!AsciiZ class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: String! !!AsciiZ class methodsFor: 'as yet unclassified'!fromString: aString	| anAsciiZ |		anAsciiZ := AsciiZ new: aString size + 1.	anAsciiZ loadFrom: aString.	^ anAsciiZ.! !!AsciiZ class methodsFor: 'as yet unclassified'!handleFromObject: aString ifError: aBlock		(aString isKindOf: String) ifFalse: [ 		^ super handleFromObject: aString ifError: aBlock	].	^ ( self fromString: aString ) handle.! !!AsciiZ class methodsFor: 'as yet unclassified'!new: size	| buffer asciiZ |	buffer := super new: size.	asciiZ := AsciiZ new handle: buffer handle.	asciiZ size: size.	asciiZ atAllPutZero.	buffer handle: ExternalAddress nullPointer.	^ asciiZ! !!AsciiZ class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; asString! !!ExternalFunction class methodsFor: 'as yet unclassified'!name: aName library: aLibrary	^self new name: aName library: aLibrary! !!ExternalLibrary class methodsFor: 'as yet unclassified'!huemul	Huemul ifNil: [	"Represents the executable itself"		Huemul := self new.		Huemul open.	].	^ Huemul.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!handle	self object ifNil: [ handle beNull ].	^ handle.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!initialize	super initialize.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!initializePointer	self handle forObject: self object.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!object	^ self objectPointer at: 1! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!object: anObject	self objectPointer at: 1 put: anObject.	self initializePointer.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!objectPointer	object ifNil: [ object := WeakArray new: 1 ].	^ object! !!ExternalArrayProxy methodsFor: 'as yet unclassified'!initializePointer	self handle forArray: self object.! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!fromObject: anObject		^ self new object: anObject; yourself! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!handleFromObject: anObject ifError: aBlock		^ ( self fromObject: anObject ) handle.! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		^ aBlock value! !!ExternalSymbol methodsFor: 'as yet unclassified'!address	handle isNull ifTrue: [ self bind ].	^ handle.! !!ExternalSymbol methodsFor: 'as yet unclassified'!bind	^ library bindSymbol: self.! !!ExternalSymbol methodsFor: 'as yet unclassified'!classFromType: aType	^ Smalltalk at: aType ifAbsent: [ self throwExternalSymbolError ].! !!ExternalSymbol methodsFor: 'as yet unclassified'!library	^ library! !!ExternalSymbol methodsFor: 'as yet unclassified'!library: aLibrary	library := aLibrary! !!ExternalSymbol methodsFor: 'as yet unclassified'!libraryName	^ library name.! !!ExternalSymbol methodsFor: 'as yet unclassified'!name	^name! !!ExternalSymbol methodsFor: 'as yet unclassified'!name: aName	name := aName! !!ExternalSymbol methodsFor: 'as yet unclassified'!name: aName library: aLibrary	self name: aName.	self library: aLibrary! !!ExternalSymbol methodsFor: 'as yet unclassified'!throwExternalSymbolError	^(ExternalSymbolError symbolName: name) signal.! !!ExternalSymbol methodsFor: 'as yet unclassified'!throwNotKnownError	^(ExternalSymbolError symbolName: name) signal.! !!ExecutableFunction methodsFor: 'as yet unclassified'!callingConventionString	self subclassResponsibility.! !!CDeclFunction methodsFor: 'as yet unclassified'!argTypes: anArrayOfTypes	argTypes := anArrayOfTypes.! !!CDeclFunction methodsFor: 'as yet unclassified'!callingConventionString	^ 'cdecl'! !!CDeclFunction methodsFor: 'as yet unclassified'!invoke	^self invokeWithArguments: #()! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1	^self invokeWithArguments: (Array with: arg1)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2	^self invokeWithArguments: (Array with: arg1 with: arg2)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4 with: arg5	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWithArguments: argArray	| argSize argHandleArray returnClass returnHandle |	argSize := argArray size.	argSize = argTypes size ifFalse: [ self throwExternalFunctionError ].	argHandleArray := Array new: argSize.	1 to: argSize do: [ :i |		| argType argClass argHandle arg |		argType := argTypes at: i.		argClass := self classFromType: argType.		arg := argArray at: i.		argHandle := argClass handleFromObject: arg.		argHandleArray at: i put: argHandle.	].	returnHandle := nil.	returnType = #Void ifFalse: [		returnClass := self classFromType: returnType.		returnHandle := returnClass defaultHandlerClass new.	].	handle isNull ifTrue: [ self bind ].	self primInvokeAnswering: returnHandle withArguments: argHandleArray.	returnType = #Void ifTrue: [ ^ nil ].	^ returnClass objectFromHandle: returnHandle.! !!CDeclFunction methodsFor: 'as yet unclassified'!primInvokeAnswering: aReturnValue withArguments: argArray	"Manually invoke the receiver, representing an external function."	<primitive: 204>	^self primitiveFailed! !!CDeclFunction methodsFor: 'as yet unclassified'!returnType: aType	returnType := aType.! !!CDeclFunction methodsFor: 'as yet unclassified'!returnType: aType argTypes: anArrayOfTypes	self returnType: aType.	self argTypes: anArrayOfTypes.! !!ExternalSymbol class methodsFor: 'as yet unclassified'!name: aName library: aLibrary	^self new name: aName library: aLibrary; bind! !!CDeclFunction class methodsFor: 'as yet unclassified'!name: aName library: aLibrary returnType: retType argTypes: argTypesArray	^self new name: aName library: aLibrary;		 returnType: retType argTypes: argTypesArray;		bind! !!ExternalSymbolError methodsFor: 'as yet unclassified'!isResumable	"Determine whether an exception is resumable."	^true! !!ExternalSymbolError methodsFor: 'as yet unclassified'!symbolName	^ symbolName! !!ExternalSymbolError methodsFor: 'as yet unclassified'!symbolName: argument	"Specify the function name that was beiing used."	symbolName := argument! !!ExternalSymbolError class methodsFor: 'as yet unclassified'!symbolName: argument	^self new symbolName: argument; yourself! !!FileDescriptor methodsFor: 'as yet unclassified'!close		self fileDescriptor > 2 ifTrue: [ 		LibC6 default close: self.		self fileDescriptor: -1.	]! !!FileDescriptor methodsFor: 'as yet unclassified'!fileDescriptor	^ SignedInteger objectFromHandle: handle. ! !!FileDescriptor methodsFor: 'as yet unclassified'!fileDescriptor: anInteger	handle := SignedInteger handleFromObject: anInteger. ! !!FileDescriptor methodsFor: 'as yet unclassified'!free		self close.! !!FileDescriptor methodsFor: 'as yet unclassified'!movePosition: offset"relative to actual position"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_CUR' ).	! !!FileDescriptor methodsFor: 'as yet unclassified'!position	^ self movePosition: 0.	! !!FileDescriptor methodsFor: 'as yet unclassified'!position: offset"absolute position"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_SET' ).! !!FileDescriptor methodsFor: 'as yet unclassified'!positionFromEnd: offset"relative to end of file"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_END' ).	! !!FileDescriptor methodsFor: 'as yet unclassified'!read: size	| retValue buffer |	buffer := ExternalBuffer new: size.	retValue := self readBuffer: buffer size: size.	! !!FileDescriptor methodsFor: 'as yet unclassified'!readBuffer: buffer size: size	^ LibC6 default read: self buffer: buffer size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!readString: aString	^ LibC6 default read: self string: aString size: aString size! !!FileDescriptor methodsFor: 'as yet unclassified'!readString: aString size: size	| internalSize |	internalSize := size.	aString size < size ifTrue: [ internalSize := aString size ].	^ LibC6 default read: self string: aString size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!size	| position size |	position := self position.	size := self positionFromEnd: 0.	self position: position.	^ size	! !!FileDescriptor methodsFor: 'as yet unclassified'!writeBuffer: buffer size: size	^ LibC6 default write: self buffer: buffer size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!writeString: aString	^ LibC6 default write: self string: aString size: aString size! !!FileDescriptor methodsFor: 'as yet unclassified'!writeString: aString size: size	| internalSize |	internalSize := size.	aString size < size ifTrue: [ internalSize := aString size ].	^ LibC6 default write: self string: aString size: size! !!FileDescriptor class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalValue! !!FileDescriptor class methodsFor: 'as yet unclassified'!initialize	self initializeStandardDescriptors! !!FileDescriptor class methodsFor: 'as yet unclassified'!initializeStandardDescriptors	StandardDescriptors := Dictionary new.	StandardDescriptors at: #stdout put: (self newFileDescriptor: 0).	StandardDescriptors at: #stdin put: (self newFileDescriptor: 1).	StandardDescriptors at: #stderr put: (self newFileDescriptor: 2).! !!FileDescriptor class methodsFor: 'as yet unclassified'!newFileDescriptor: anInteger	^ self new fileDescriptor: anInteger; yourself.! !!FileDescriptor class methodsFor: 'as yet unclassified'!standardDescriptors	^ StandardDescriptors! !!FileDescriptor class methodsFor: 'as yet unclassified'!stderr	^ StandardDescriptors at: #stderr.! !!FileDescriptor class methodsFor: 'as yet unclassified'!stdin	^ StandardDescriptors at: #stdin.! !!FileDescriptor class methodsFor: 'as yet unclassified'!stdout	^ StandardDescriptors at: #stdout.! !!FileStream methodsFor: 'as yet unclassified'!atEnd	"Answer true if the current position is >= the end of file position.	 1/31/96 sw: subclassResponsibility"	self subclassResponsibility! !!FileStream class methodsFor: 'as yet unclassified'!fileDoesNotExistUserHandling: fullFileName	(GtkMessageDialog question: fullFileName, ' does not exist, create it?') = #yes		ifTrue: [ ^ self new open: fullFileName forWrite: true ].! !!FileStream class methodsFor: 'as yet unclassified'!fileExistsUserHandling: fullFileName	(GtkMessageDialog question: fullFileName, ' exist, overwrite it?') = #yes		ifTrue: [ ^ self new openForOverwrite: fullFileName ].! !!FileStream class methodsFor: 'as yet unclassified'!readOnlyFileDoesNotExistUserHandling: fullFileName	GtkMessageDialog error: fullFileName, ' does not exist'! !!FileDoesNotExistException methodsFor: 'as yet unclassified'!defaultAction	"The default action taken if the exception is signaled."	^self readOnly		ifTrue: [FileStream readOnlyFileDoesNotExistUserHandling: self fileName]		ifFalse: [FileStream fileDoesNotExistUserHandling: self fileName]! !!GIRBuilder methodsFor: 'as yet unclassified'!compiledMethod	| bytecodes |	bytecodes := self bytecodes.	bytecodes ifNil: [ ^ nil ].	^ CompiledMethod new		primitive: 0;		numArgs: self numArgs;		numTemps: self numTemps;		literals: self literals;		relocationInfo: self relocationInfo;		bytecodes: bytecodes;		debugInfo: debugInfo;		source: source;		relocate.! !!GPointer methodsFor: 'as yet unclassified'!initialize	handle := self class defaultHandlerClass new.! !!GPointer class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalAddress! !!GPointer class methodsFor: 'as yet unclassified'!handle: aByteArray	^self basicNew handle: aByteArray; yourself! !!GObject class methodsFor: 'as yet unclassified'!handleFromObject: object	^ object handle.	! !!Gtk methodsFor: 'as yet unclassified'!initialize	self initializeGtkLibrary.	self startMainLoop.! !!Gtk class methodsFor: 'as yet unclassified'!shutDown: quiting	"Quits the Gtk main loop"	Default ifNotNil: [		Default quitMainLoop.		Default close.		Default := nil.	].! !!GtkDemoStockIds methodsFor: 'as yet unclassified'!initialize	| model tree |	model := GtkListStore new: {String. String. String. String}.	GtkStockItem allStocks do: [ :ea |		ea ifNotNil: [			model append: {				ea stockId asGtkStockId.				ea stockId.				ea label.				Gtk acceleratorName: ea keyval asCharacter modifier: ea modifier}]].	tree := GtkTreeView model: model.	self createFirstColumn: tree.	tree appendColumns: {		GtkTreeViewColumn title: 'Label' text: 2.		GtkTreeViewColumn title: 'Accel' text: 3.		GtkTreeViewColumn title: 'ID' text: 0}.	tree selection when: #changed send: #onItemChanged: to: self withArgumentsFirst: {tree}.			self container: (GtkHBox spacing: 5).	self container		packStart: (GtkScrolledWindow withChild: tree);		packEnd: self createInfoFrame expand: false fill: false! !!GtkDemoStockIds methodsFor: 'as yet unclassified'!onItemChanged: aTreeView	aTreeView selectedRow in: [:row |		idLabel label: row first.		nameLabel label: '#', row second.		accelLabel label: row third.		iconImage stock: row second iconSize: #dialog]! !!InMidstOfFileinNotification methodsFor: 'as yet unclassified'!defaultAction	^ self resume: false! !!LibC methodsFor: 'as yet unclassified'!closeLibrary	cLibrary closeLibrary.	cLibrary := nil.! !!LibC methodsFor: 'as yet unclassified'!initializeCLibrary	cLibrary := ExternalLibrary new.	cLibrary name: 'libc.so.6'.	cLibrary openLibrary.! !!LibC class methodsFor: 'as yet unclassified'!shutDown: quiting	"Quits the Gtk main loop"	self default closeLibrary.	Default := nil.! !!LibC6 methodsFor: 'as yet unclassified'!close: fd	| retValue |	retValue := ( self cDeclFunctionNamed: #close ) invokeWith: fd.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #close ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!errno	^ (self libraryDataNamed: #errno) value.	! !!LibC6 methodsFor: 'as yet unclassified'!errno: errno	(self libraryDataNamed: #errno) value: errno.	! !!LibC6 methodsFor: 'as yet unclassified'!free: anExternalBuffer	( self cDeclFunctionNamed: #free ) invokeWith: anExternalBuffer.	! !!LibC6 methodsFor: 'as yet unclassified'!getCurrentDirName	| retValue |	[ retValue := ( self cDeclFunctionNamed: 'get_current_dir_name' asSymbol ) invoke ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: 'get_current_dir_name' asSymbol ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!getEnv: envVariable	^ ( self cDeclFunctionNamed: #getenv ) invokeWith: envVariable.! !!LibC6 methodsFor: 'as yet unclassified'!getpid	^ (self cDeclFunctionNamed: #getpid) invoke.	! !!LibC6 methodsFor: 'as yet unclassified'!initialize	super initialize.	self initializeUniStd.	self initializeStdLib.	self initializeString.	self initializeFCntl.	self initializeStdIO.	self initializeErrNO.! !!LibC6 methodsFor: 'as yet unclassified'!initializeErrNO	self initializeLibraryDataNamed: #errno type: #SignedInteger.! !!LibC6 methodsFor: 'as yet unclassified'!initializeFCntl	self initializeCDeclFunctionNamed: #open returnType: #FileDescriptor argTypes: #( AsciiZ SignedInteger UnsignedInteger ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeStdIO	self initializeCDeclFunctionNamed: #printf  returnType: #SignedInteger argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: #perror  returnType: #Void argTypes: #( AsciiZ  ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeStdLib	self initializeCDeclFunctionNamed: #malloc  returnType: #ExternalBuffer argTypes: #( UnsignedInteger  ).	self initializeCDeclFunctionNamed: #free  returnType: #Void argTypes: #( ExternalBuffer  ).	self initializeCDeclFunctionNamed: #getenv  returnType: #AsciiZ argTypes: #( AsciiZ ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeString	self initializeCDeclFunctionNamed: #strlen returnType: #UnsignedInteger argTypes: #( AsciiZ ).	self initializeCDeclFunctionNamed: #strcat returnType: #AsciiZ argTypes: #( AsciiZ AsciiZ ).	self initializeCDeclFunctionNamed: #strcpy returnType: #AsciiZ argTypes: #( AsciiZ AsciiZ ).	self initializeCDeclFunctionNamed: #strerror returnType: #ReadOnlyAsciiZ argTypes: #( SignedInteger ).	self initializeCDeclFunctionNamed: #memset returnType: #ExternalBuffer argTypes: #( ExternalBuffer SignedInteger  UnsignedInteger ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeUniStd	self initializeCDeclFunctionNamed: #getpid  returnType: #UnsignedInteger argTypes: #().	self initializeCDeclFunctionNamed: 'get_current_dir_name' asSymbol  returnType: #AsciiZ argTypes: #().	self initializeCDeclFunctionNamed: #close  returnType: #SignedInteger argTypes: #( FileDescriptor ).	self initializeCDeclFunctionNamed: #lseek  returnType: #UnsignedInteger argTypes: #( FileDescriptor UnsignedInteger SignedInteger ).	self initializeCDeclFunctionNamed: #read  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalBuffer UnsignedInteger ).	self initializeCDeclFunctionNamed: #write  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalBuffer UnsignedInteger )."Redefinition of read for Strings"	symbolCache at: #readString put: (CDeclFunction name: #read library: self  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalArrayProxy UnsignedInteger ) )."Redefinition of write for Strings"	symbolCache at: #writeString put: (CDeclFunction name: #write library: self  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalArrayProxy UnsignedInteger ) ).! !!LibC6 methodsFor: 'as yet unclassified'!lseek: fileDescriptor offset: offset whence: whence	| returnValue |	returnValue := (self cDeclFunctionNamed: #lseek) invokeWith: fileDescriptor with: offset with: whence.	returnValue < 0 ifTrue: [		self throwErrorForExternalFunctionNamed: #lseek.		^ nil.	].	^ returnValue.	! !!LibC6 methodsFor: 'as yet unclassified'!malloc: size	| retValue |	[ retValue := ( self cDeclFunctionNamed: #malloc ) invokeWith: size ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: #malloc withMessage: 'can not allocate memory' ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!memSet: buffer constant: c count: n	^ (self cDeclFunctionNamed: #memset) invokeWith: buffer with: c with: n.	! !!LibC6 methodsFor: 'as yet unclassified'!open: path flags: flags	^ self open: path flags: flags mode: 8r644	! !!LibC6 methodsFor: 'as yet unclassified'!open: path flags: flags mode: mode	| fileDescriptor |	fileDescriptor := (self cDeclFunctionNamed: #open) invokeWith: path with: flags with: mode.	fileDescriptor fileDescriptor < 0 ifTrue: [		self throwErrorForExternalFunctionNamed: #open.		^ nil.	].	^ fileDescriptor.	! !!LibC6 methodsFor: 'as yet unclassified'!perror: aString	( self cDeclFunctionNamed: #perror ) invokeWith: aString.	! !!LibC6 methodsFor: 'as yet unclassified'!printf: aString	^ ( self cDeclFunctionNamed: #printf ) invokeWith: aString.	! !!LibC6 methodsFor: 'as yet unclassified'!read: fd buffer: buffer size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #read ) invokeWith: fd with: buffer with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #read ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!read: fd string: aString size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #readString ) invokeWith: fd with: aString with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #readString ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!strCat: destString with: sourceString	^ ( self cDeclFunctionNamed: #strcat ) invokeWith: destString with: sourceString.	! !!LibC6 methodsFor: 'as yet unclassified'!strCpy: destString with: sourceString	^ ( self cDeclFunctionNamed: #strcpy ) invokeWith: destString with: sourceString.	! !!LibC6 methodsFor: 'as yet unclassified'!strError: errno	| retValue |	[ retValue := ( self cDeclFunctionNamed: #strerror ) invokeWith: errno ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: #strerror ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!strLen: string	^ ( self cDeclFunctionNamed: #strlen ) invokeWith: string	! !!LibC6 methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName	^ self throwErrorForExternalFunctionNamed: functionName withMessage: (self strError: self errno).	! !!LibC6 methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName withMessage: aString	| error |	error := ExternalFunctionError functionName: functionName.	error messageText: aString.	^ error signal.	! !!LibC6 methodsFor: 'as yet unclassified'!valueForLSeekDirectiveNamed: aString	^ LSeekDirectives at: aString asSymbol.	! !!LibC6 methodsFor: 'as yet unclassified'!valueForOpenFlagNamed: aString	^ OpenFlags at: aString asSymbol.	! !!LibC6 methodsFor: 'as yet unclassified'!write: fd buffer: buffer size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #write ) invokeWith: fd with: buffer with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #write ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!write: fd string: aString size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #writeString ) invokeWith: fd with: aString with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #writeString ].	^ retValue.	! !!LibC6 class methodsFor: 'as yet unclassified'!initialize	self initializeOpenFlags.	self initializeLSeekDirectives.! !!LibC6 class methodsFor: 'as yet unclassified'!initializeLSeekDirectives	| lSeekDirectives |		lSeekDirectives := Dictionary new.	lSeekDirectives at: 'SEEK_SET' put: 0.	lSeekDirectives at: 'SEEK_CUR' put: 1.	lSeekDirectives at: 'SEEK_END' put: 2.	LSeekDirectives := lSeekDirectives! !!LibC6 class methodsFor: 'as yet unclassified'!initializeOpenFlags	| flagArray openFlags |		flagArray := #( 		('O_RDONLY'		0)		('O_WRONLY'		8r1)		('O_RDWR'		8r2)		('O_CREAT'		8r100)			('O_EXCL'			8r200)			('O_NOCTTY'		8r400)			('O_TRUNC'		8r1000)			('O_APPEND'		8r2000)		('O_NONBLOCK'	8r4000)		('O_SYNC'		8r10000)		('O_ASYNC'		8r20000)	).	openFlags := Dictionary new.	flagArray do: [ :i |		openFlags at: i first asSymbol put: i second	].	OpenFlags := openFlags! !!LibC6 class methodsFor: 'as yet unclassified'!moduleName	^ 'libc.so.6'.! !!LibExample methodsFor: 'as yet unclassified'!getpid	^ GETPID invoke! !!LibExample class methodsFor: 'as yet unclassified'!getpid	^ GETPID! !!LibExample class methodsFor: 'as yet unclassified'!initialize	GETPID := CDeclFunction name: 'getpid' libraryNamed: 'libc.so.6' returnType: #UnsignedInteger argTypes: #().! !!LibReadLine methodsFor: 'as yet unclassified'!addHistory: aString	( self cDeclFunctionNamed: 'add_history' asSymbol ) invokeWith: aString.! !!LibReadLine methodsFor: 'as yet unclassified'!initialize	super initialize.	self initializeCDeclFunctionNamed: #readline  returnType: #AsciiZ argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'add_history' asSymbol returnType: #Void argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'read_history' asSymbol returnType: #SignedInteger argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'write_history' asSymbol returnType: #SignedInteger argTypes: #( AsciiZ  ).! !!LibReadLine methodsFor: 'as yet unclassified'!readHistory: aFileName	| errno |	errno := ( self cDeclFunctionNamed: 'read_history' asSymbol ) invokeWith: aFileName.	errno = 0 ifFalse: [ self throwErrorForExternalFunctionNamed: 'read_history' asSymbol errno: errno ].	^ errno.! !!LibReadLine methodsFor: 'as yet unclassified'!readline: prompt	^ ( self cDeclFunctionNamed: #readline ) invokeWith: prompt.! !!LibReadLine methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName errno: errno	| error |	error := ExternalFunctionError functionName: functionName.	error messageText: (LibC6 default strError: errno).	^ error signal.! !!LibReadLine methodsFor: 'as yet unclassified'!writeHistory: aFileName	| errno |	errno := ( self cDeclFunctionNamed: 'write_history' asSymbol ) invokeWith: aFileName.	errno = 0 ifFalse: [ self throwErrorForExternalFunctionNamed: 'write_history' asSymbol errno: errno ].	^ errno.! !!LibReadLine class methodsFor: 'as yet unclassified'!moduleName	^ 'libreadline.so.5'.! !!LibraryData methodsFor: 'as yet unclassified'!primitiveGetValue: valueHandle	<primitive: 216>	^self primitiveFailed! !!LibraryData methodsFor: 'as yet unclassified'!primitiveSetValue: valueHandle	<primitive: 217>	^self primitiveFailed! !!LibraryData methodsFor: 'as yet unclassified'!type	^ type.! !!LibraryData methodsFor: 'as yet unclassified'!type: aType	type := aType.! !!LibraryData methodsFor: 'as yet unclassified'!value	| valueClass valueHandle |	valueClass := self classFromType: type.	valueHandle := valueClass defaultHandlerClass new.	handle isNull ifTrue: [ self bind ].	self primitiveGetValue: valueHandle.	^ valueClass objectFromHandle: valueHandle.! !!LibraryData methodsFor: 'as yet unclassified'!value: aValue	| argHandle argClass |	argClass := self classFromType: type.	argHandle := argClass handleFromObject: aValue.	handle isNull ifTrue: [ self bind ].	self primitiveSetValue: argHandle! !!LibraryData class methodsFor: 'as yet unclassified'!name: aName library: aLibrary type: type	^self new name: aName library: aLibrary;		type: type;		bind! !!Metaclass methodsFor: 'as yet unclassified'!addObsoleteSubclass: aClass	"Do nothing."! !!Metaclass methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return true if it is safe to zap the method dictionary on #obsolete"	thisClass == nil		ifTrue:[^true]		ifFalse:[^thisClass canZapMethodDictionary]! !!Metaclass methodsFor: 'as yet unclassified'!isSystemDefined	"Answer false if I am a UniClass (an instance-specific lightweight class)"	^ true! !!NativeFunction methodsFor: 'as yet unclassified'!callingConventionString	^ 'native'! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver	^self invokeReceiver: receiver withArguments: #()! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1	^self invokeReceiver: receiver withArguments: (Array with: arg1)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4 with: arg5	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver withArguments: argArray	handle isNull ifTrue: [ self bind ].	^ self primInvokeReceiver: receiver withArguments: argArray.! !!NativeFunction methodsFor: 'as yet unclassified'!primInvokeReceiver: receiver withArguments: argArray	"Manually invoke the receiver, representing an native function."	<primitive: 197>	^self primitiveFailed! !!ObjectTest methodsFor: 'as yet unclassified'!testBecome	"self debug: #testBecome"	"this test should that all the variables pointing to an object are pointing now to another one, and all      object pointing to the other are pointing to the object"	| pt1 pt2 pt3 |	pt1 := 0@0.	pt2 := pt1.	pt3 := 100@100.	pt1 become: pt3.	self assert: pt2 = (100@100).	self assert: pt3 = (0@0).	self assert: pt1 = (100@100).! !!ObjectTest methodsFor: 'as yet unclassified'!testBecomeForward	"self debug: #testBecomeForward"	"this test should that all the variables pointing to an object are pointing now to another one.	Not that this inverse is not true. This kind of become is called oneWayBecome in VW"	| pt1 pt2 pt3 |	pt1 := 0@0.	pt2 := pt1.	pt3 := 100@100.	pt1 becomeForward: pt3.	self assert: pt2 = (100@100).	self assert: pt3 == pt2.	self assert: pt1 = (100@100)! !!PrimitiveType class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalValue! !!PrimitiveType class methodsFor: 'as yet unclassified'!handleFromObject: anObject	^ self handleFromObject: anObject ifError: [ self throwTypeConvertionError ]! !!PrimitiveType class methodsFor: 'as yet unclassified'!handleFromObject: object ifError: aBlock	self subclassResponsibility.! !!PrimitiveType class methodsFor: 'as yet unclassified'!objectFromHandle: handle	^ self objectFromHandle: handle ifError: [  self throwTypeConvertionError ]! !!PrimitiveType class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock	self subclassResponsibility.! !!PrimitiveType class methodsFor: 'as yet unclassified'!throwTypeConvertionError	^ TypeConvertionError new signal! !!IntegerType class methodsFor: 'as yet unclassified'!handleFromObject: anInteger ifError: aBlock	| handle |		(self checkType: anInteger) ifFalse: [ ^ aBlock value ].	handle := ExternalValue new.	self store: anInteger in: handle.	^ handle.	! !!IntegerType class methodsFor: 'as yet unclassified'!isBigEndian	^  false! !!IntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	self subclassResponsibility.! !!IntegerType class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: errorBlock	| value |		value := self loadFrom: handle.	(value > self max ) ifTrue: [ ^ errorBlock value ].	^ value.! !!Process methodsFor: 'as yet unclassified'!primitiveBeInitialProcess	<primitive: 196>	self primitiveFailed! !!ProcessorScheduler methodsFor: 'as yet unclassified'!activeProcess	^ self primActiveProcess! !!ProcessorScheduler methodsFor: 'as yet unclassified'!primActiveProcess	<primitive: 195>	self primitiveFail.! !!ProcessorScheduler methodsFor: 'as yet unclassified'!startUp	| firstProcess |"	(processList isNil or: [ processList isEmpty not ]) ifTrue: [ self initialize ]."	self initialize.	firstProcess := Process new.	firstProcess name: 'Init'.	firstProcess priority: self userSchedulingPriority.	firstProcess state: #running."	firstProcess threadData: self activeThreadData."	firstProcess primitiveBeInitialProcess.! !!ReadOnlyAsciiZ methodsFor: 'as yet unclassified'!asString	^ handle toString.! !!ReadOnlyAsciiZ class methodsFor: 'as yet unclassified'!handleFromObject: aByteArray ifError: aBlock	"Can not be used as arguments"	aBlock value.! !!ReadOnlyAsciiZ class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; asString! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!addressRelativeTo: bytecodes	| functionAddress bytecodesAddress |	functionAddress := self function address asInteger.	bytecodesAddress := (ExternalAddress forArray: bytecodes ) asInteger.	^ functionAddress - bytecodesAddress - offset - 4! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!function	^ self library functionNamed: functionName.! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!functionName	^ functionName! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!functionName: aSymbol	^ functionName := aSymbol! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!library	^ Executable default! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!patch: bytecodes	self patch: bytecodes with: (self addressRelativeTo: bytecodes).! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!patch: bytecodes with: value	bytecodes longAt: (offset + 1) put: value bigEndian: false.! !!FunctionRelocation methodsFor: 'as yet unclassified'!addressRelativeTo: bytecodes	^ self primAddressRelativeTo: bytecodes! !!FunctionRelocation methodsFor: 'as yet unclassified'!primAddressRelativeTo: bytecodes	<primitive: 155>	self primitiveFail.! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!defaultLibraryClass	^ NativeLibrary! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!library 		^ self defaultLibraryClass named: libraryName! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!libraryName	^ libraryName! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!libraryName: aSymbol	^ libraryName := aSymbol! !!ExternalFunctionRelocation methodsFor: 'as yet unclassified'!defaultLibraryClass	^ ExternalLibrary2! !!SequenceableCollection methodsFor: 'as yet unclassified'!asTraitComposition	"For convenience the composition {T1. T2 ...} is the same as T1 + T2 + ..."	^self isEmpty		ifFalse: [			self size = 1				ifTrue: [self first asTraitComposition]				ifFalse: [					self copyWithoutFirst 						inject: self first						into: [:left :right | left + right]]]		ifTrue: [			TraitComposition new]! !!Array methodsFor: 'as yet unclassified'!elementsExchangeIdentityWith: otherArray	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsExchangeIdentityWith: otherArray.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!elementsForwardIdentityTo: otherArray	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsForwardIdentityTo: otherArray.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!elementsForwardIdentityTo: otherArray copyHash: copyHash	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsForwardIdentityTo: otherArray copyHash: copyHash.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!primElementsExchangeIdentityWith: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  At the same time, all pointers to the elements of otherArray are replaced by pointers to the corresponding elements of this array.  The identityHashes remain with the pointers rather than with the objects so that objects in hashed structures should still be properly indexed after the mutation."	<primitive: 128>	otherArray class == Array ifFalse: [^ self error: 'arg must be array'].	self size = otherArray size ifFalse: [^ self error: 'arrays must be same size'].	(self anySatisfy: [:obj | obj class == SmallInteger]) ifTrue: [^ self error: 'can''t become SmallIntegers'].	(otherArray anySatisfy: [:obj | obj class == SmallInteger]) ifTrue: [^ self error: 'can''t become SmallIntegers'].	"Must have failed because not enough space in forwarding table (see ObjectMemory-prepareForwardingTableForBecoming:with:twoWay:).  Do GC and try again only once"	(Smalltalk bytesLeft: true) = Smalltalk primitiveGarbageCollect		ifTrue: [^ self primitiveFailed].	^ self elementsExchangeIdentityWith: otherArray! !!Array methodsFor: 'as yet unclassified'!primElementsForwardIdentityTo: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  The identityHashes remain with the pointers rather than with the objects so that the objects in this array should still be properly indexed in any existing hashed structures after the mutation."	<primitive: 72>	self primitiveFailed! !!Array methodsFor: 'as yet unclassified'!primElementsForwardIdentityTo: otherArray copyHash: copyHash	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  The identityHashes remain with the pointers rather than with the objects so that the objects in this array should still be properly indexed in any existing hashed structures after the mutation."	<primitive: 249>	self primitiveFailed! !!ExternalValue methodsFor: 'as yet unclassified'!beNull	"Make the receiver a NULL pointer"	self atAllPut: 0.! !!ExternalValue methodsFor: 'as yet unclassified'!isNull	^(self basicAt: 1) = 0	and: (self basicAt: 2) = 0	and: (self basicAt: 3) = 0	and: (self basicAt: 4) = 0	! !!ExternalValue class methodsFor: 'as yet unclassified'!initialize	Smalltalk addToStartUpList: self.! !!ExternalValue class methodsFor: 'as yet unclassified'!new	"External addresses are always 4 bytes long"	^super new: 4! !!ExternalValue class methodsFor: 'as yet unclassified'!new: n	"You better don't try this..."	^self shouldNotImplement! !!ExternalValue class methodsFor: 'as yet unclassified'!startUp: resuming	resuming ifTrue: [		self allInstancesDo: [ :addr |			addr beNull		]	].! !!SharedPool class methodsFor: 'as yet unclassified'!bindingOf: varName	"Answer the binding of some variable resolved in the scope of the receiver"	| aSymbol binding |	aSymbol := varName asSymbol.	"First look in classVar dictionary."	binding := self classPool bindingOf: aSymbol.	binding ifNotNil:[^binding].	"Next look in shared pools."	self sharedPools do:[:pool | 		binding := pool bindingOf: aSymbol.		binding ifNotNil:[^binding].	].	"subclassing and environment are not preserved"	^nil! !!SharedPool class methodsFor: 'as yet unclassified'!bindingsDo: aBlock	^self classPool bindingsDo: aBlock! !!SharedPool class methodsFor: 'as yet unclassified'!classBindingOf: varName	"For initialization messages grant the regular scope"	^super bindingOf: varName! !!SharedPool class methodsFor: 'as yet unclassified'!hasBindingThatBeginsWith: aString	"Answer true if the receiver has a binding that begins with aString, false otherwise"	"First look in classVar dictionary."	(self classPool hasBindingThatBeginsWith: aString) ifTrue:[^true].	"Next look in shared pools."	self sharedPools do:[:pool | 		(pool hasBindingThatBeginsWith: aString) ifTrue: [^true]].	^false! !!SharedPool class methodsFor: 'as yet unclassified'!includesKey: aName	"does this pool include aName"	^(self bindingOf: aName) notNil! !!SharedPool class methodsFor: 'as yet unclassified'!keysDo: aBlock"A hopefully temporary fix for an issue arising from miss-spelled variable names in code being compiled. The correction code (see Class>possibleVariablesFor:continuedFrom: assumes that sharedPools are Dictionaries. The proper fix would involve making sure all pools are actually subclasses of SharedPool, which they are not currently."	self bindingsDo:[:b|		aBlock value: b key]! !!Shell methodsFor: 'as yet unclassified'!display: string	| buffer |		buffer := AsciiZ fromString: string.	^ FileDescriptor stdout writeBuffer: buffer size: buffer size.! !!Shell methodsFor: 'as yet unclassified'!input: prompt	^ LibReadLine default readline: prompt! !!Shell methodsFor: 'as yet unclassified'!main	| line value failed anotherLine buffer |	LibReadLine default readHistory: self historyFileName.	[		anotherLine := false.		buffer := ''.		[ 	| prompt |			prompt := anotherLine ifTrue: [ '' ] ifFalse: [ '> ' ].			line _ self input: prompt.			line isEmpty				ifTrue: [ true ] 				ifFalse: [					(line last = $\)						ifTrue: [							anotherLine := true.							line at: line size put: Character lf.						]						ifFalse: [ anotherLine := false ].					buffer := buffer, line.					anotherLine				]		] whileTrue. 		buffer = 'quit' or: [ buffer = 'save' ]	] whileFalse: [		self addToHistory: buffer.		failed _ false.		value _ Compiler new evaluate: buffer in: nil to: nil notifying: self ifFail: [ failed _ true].		failed ifFalse: [ self display: (value printString); lf ]	].	LibReadLine default writeHistory: self historyFileName.	buffer = 'save' ifTrue: [ Smalltalk snapshotAndQuit ].	^value.! !!SignedIntegerType class methodsFor: 'as yet unclassified'!checkType: value	^ value isInteger and: [ value >= self min and: [ value <= self max ] ]! !!SignedIntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	^ handle longAt: 1 bigEndian: self isBigEndian.! !!SignedIntegerType class methodsFor: 'as yet unclassified'!store: anInteger in: handle	handle longAt: 1 put: anInteger bigEndian: self isBigEndian.! !!SignedByte class methodsFor: 'as yet unclassified'!max			^ 127! !!SignedByte class methodsFor: 'as yet unclassified'!min			^ -128! !!SignedInteger class methodsFor: 'as yet unclassified'!max			^ 2147483647! !!SignedInteger class methodsFor: 'as yet unclassified'!min			^ -2147483648! !!SignedShortInteger class methodsFor: 'as yet unclassified'!max			^ 32767! !!SignedShortInteger class methodsFor: 'as yet unclassified'!min			^ -32768! !!SourceReference methodsFor: 'as yet unclassified'!sourceFrom: aString	self hasEmptySourceReference ifTrue: [ ^ '' ].	^ aString copyFrom: sourceStart to: sourceStop! !!StandardFileStream class methodsFor: 'as yet unclassified'!retryWithGC: execBlock until: testBlock forFileNamed: fullName	"Re-implemented to only force GC if a file with the given name exists"	| blockValue foundIt |	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	"See if we have a file with the given name"	foundIt := self registry keys "hold on strongly for now" 		anySatisfy:[:file| file name sameAs: fullName].	foundIt ifFalse:[^blockValue].	Smalltalk garbageCollectMost.	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollect.	^execBlock value.! !!SystemDictionary methodsFor: 'as yet unclassified'!forgetClass: aClass logged: aBool 	"Delete the class, aClass, from the system.	Note that this doesn't do everything required to dispose of a class - to do that use Class>>removeFromSystem."	aBool ifTrue: [SystemChangeNotifier uniqueInstance classRemoved: aClass fromCategory: aClass category].			SystemOrganization removeElement: aClass name.	self removeFromStartUpList: aClass.	self removeFromShutDownList: aClass.	self removeKey: aClass name ifAbsent: [].	self flushClassNameCache! !!SystemDictionary methodsFor: 'as yet unclassified'!removeClassNamed: aName	"Invoked from fileouts:  if there is currently a class in the system named aName, then remove it.  If anything untoward happens, report it in the Transcript.  "	| oldClass |	(oldClass _ self at: aName asSymbol ifAbsent: [nil]) == nil		ifTrue:			[Transcript cr; show: 'Removal of class named ', aName, ' ignored because ', aName, ' does not exist.'.			^ self].	oldClass removeFromSystem! !!SystemDictionary methodsFor: 'as yet unclassified'!startUp	Processor startUp.	ProcessorScheduler startUp.	self processStartUpList: true.	self installLowSpaceWatcher.! !!SystemTracer methodsFor: 'as yet unclassified'!getAligned: size	^ (( size + 3 ) bitShift: -2) bitShift: 2.! !!TraitBehavior methodsFor: 'as yet unclassified'!addUser: aClassOrTrait	users add: aClassOrTrait! !!TraitBehavior methodsFor: 'as yet unclassified'!classesComposedWithMe	^users gather: [:u | u classesComposedWithMe]! !!TraitBehavior methodsFor: 'as yet unclassified'!initialize	self methodDict: Dictionary new.	self traitComposition: nil.	users _ IdentitySet new.! !!TraitBehavior methodsFor: 'as yet unclassified'!removeUser: aClassOrTrait	users remove: aClassOrTrait ifAbsent: []! !!TraitBehavior methodsFor: 'as yet unclassified'!users	^users! !!TraitComposition methodsFor: 'as yet unclassified'!assertValidUser: aBehavior	"Assert that this trait composition set for aBehavior	does not introduce a cycle."		(self allTraits includes: aBehavior) ifTrue: [		TraitCompositionException signal: 'Cycle in compositions:  The composition (in)directly includes this trait!!']! !!TraitComposition methodsFor: 'as yet unclassified'!methodDescriptionsForSelector: aSymbol	"Return a collection of TraitMethodDescriptions for aSymbol and all the 	aliases of aSymbol."	| selectors collection |	selectors _ IdentitySet with: aSymbol.	self transformations do: [:each |		selectors addAll: (each aliasesForSelector: aSymbol)].	collection _ OrderedCollection new: selectors size.	selectors do: [:each |		collection add: (self methodDescriptionForSelector: each)].	^collection! !!TraitDescription methodsFor: 'as yet unclassified'!trait	"for compatibility with TraitTransformations"	^ self! !!TraitDescription methodsFor: 'as yet unclassified'!updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil	| currentCategory effectiveCategory sel changedCategories composition |	changedCategories _ IdentitySet new.	composition := self hasTraitComposition		ifTrue: [self traitComposition]		ifFalse: [TraitComposition new].	(composition methodDescriptionsForSelector: aSymbol) do: [:each |		sel _ each selector.		(self includesLocalSelector: sel) ifFalse: [			currentCategory _ self organization categoryOfElement: sel.			effectiveCategory _ each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.			effectiveCategory isNil ifTrue: [				currentCategory ifNotNil: [changedCategories add: currentCategory].				self organization removeElement: sel.			] ifFalse: [				((currentCategory isNil or: [currentCategory == ClassOrganizer ambiguous or: [currentCategory == oldCategoryOrNil]]) and: [currentCategory ~~ effectiveCategory]) ifTrue: [					currentCategory ifNotNil: [changedCategories add: currentCategory].					self organization 						classify: sel 						under: effectiveCategory						suppressIfDefault: false]]]].	^ changedCategories! !!TraitDescription methodsFor: 'as yet unclassified'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	(self includesSelector: aSelector)		ifTrue: [^ self organization categoryOfElement: aSelector]		ifFalse: [^nil]! !!Trait methodsFor: 'as yet unclassified'!initialize	super initialize.	classTrait _ ClassTrait for: self! !!TranscriptCodeView class methodsFor: 'as yet unclassified'!initialize	Smalltalk addToStartUpList: self.! !!TranscriptCodeView class methodsFor: 'as yet unclassified'!startUp: resuming	resuming ifTrue: [		TranscriptCodeBuffer := nil.	].! !!TranscriptStream methodsFor: 'as yet unclassified'!open	TranscriptCodeEditor open.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!atEnd	position ifNil: [ ^ nil ].	^ position >= readLimit! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!close	"Close this file."	fileID ifNotNil: [		fileID close.		fileID := nil.		position := nil.	].! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!open: fileName flags: flags	[ fileID := LibC6 default open: fileName flags: flags ]		on: ExternalFunctionError		do: [ ^ nil ].	name := fileName.	readLimit := fileID size.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!open: fileName forWrite: writeMode 	| flags |	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	flags := writeMode 		ifTrue: [ LibC6 default valueForOpenFlagNamed: 'O_RDWR' ]		ifFalse: [ LibC6 default valueForOpenFlagNamed: 'O_RDONLY' ].	rwmode := writeMode.	^ self open: fileName flags: flags.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!openForOverwrite: fileName	| flags |	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	flags := ((LibC6 default valueForOpenFlagNamed: 'O_RDWR') 			bitOr: ( LibC6 default valueForOpenFlagNamed: 'O_TRUNC' )) 			bitOr: ( LibC6 default valueForOpenFlagNamed: 'O_CREAT' ).	rwmode := true.	^ self open: fileName flags: flags.! !!BufferedFileStream methodsFor: 'as yet unclassified'!close	"Close this file."	self flush.	^ super close.! !!BufferedFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	self subclassResponsibility! !!BufferedFileStream methodsFor: 'as yet unclassified'!defaultBufferSize	^ DefaultBufferSize.! !!BufferedFileStream methodsFor: 'as yet unclassified'!flush	| bufferPosition bufferSize |	fileID ifNil: [ ^ nil ].	rwmode ifFalse: [ ^ nil ].	bufferPosition := position truncateTo: (collection size).	bufferSize := collection size min: ( readLimit - bufferPosition).	fileID position: bufferPosition.	bufferSize > 0 ifTrue: [ fileID writeString: collection size: bufferSize ].	 ! !!BufferedFileStream methodsFor: 'as yet unclassified'!initializeBuffer	| bufferSize |	position := 0.	collection := self defaultBufferClass new: self defaultBufferSize.	bufferSize := collection size min: readLimit.	bufferSize > 0 ifTrue: [ fileID readString: collection size: bufferSize ]. ! !!BufferedFileStream methodsFor: 'as yet unclassified'!next	| byte |	byte := self peek.	self position: position + 1.	^ byte! !!BufferedFileStream methodsFor: 'as yet unclassified'!nextPut: char	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	position ifNil: [ self position: 0 ].	collection at: (position \\ (collection size)) + 1put: char.	self position: position + 1.	^ char! !!BufferedFileStream methodsFor: 'as yet unclassified'!open: fileName flags: flags	(super open: fileName flags: flags) ifNotNil: [ self initializeBuffer ].! !!BufferedFileStream methodsFor: 'as yet unclassified'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	position ifNil: [ self position: 0 ].	self atEnd ifTrue: [^ nil ].	^ collection at: (position \\ (collection size)) + 1.! !!BufferedFileStream methodsFor: 'as yet unclassified'!position: newPosition	| oldBufferPosition newBufferPosition bufferSize |	fileID ifNil: [ ^nil ].	newPosition < 0 ifTrue: [ ^nil ]."	((newPosition > readLimit) and: [ rwmode not ])  ifTrue: [ ^nil ]."	newPosition > readLimit ifTrue: [		rwmode ifTrue: [ readLimit := newPosition ] ifFalse: [ ^nil ]	].	oldBufferPosition := position truncateTo: (collection size).	newBufferPosition := newPosition truncateTo: (collection size).	newBufferPosition = oldBufferPosition ifFalse: [ 		self flush.		fileID position: newBufferPosition.		bufferSize := collection size min: ( readLimit - newBufferPosition).		collection := self defaultBufferClass new: self defaultBufferSize.		bufferSize > 0 ifTrue: [ fileID readString: collection size: bufferSize ].	].	position := newPosition."	rwmode ifTrue: [ readLimit := newPosition ]."	^ position.! !!BinaryFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	^ ByteArray! !!TextFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	^ String! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!concreteStream	"Who should we really direct class queries to?  "	^ UnbufferedFileStream.! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!fileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new open: fileName forWrite: true! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!forceNewFileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new openForOverwrite: fileName! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!readOnlyFileNamed: fileName 	"Open an existing file with the given name for reading."	| f |	f := self new open: fileName forWrite: false.	^ f isNil		ifFalse: [f]		ifTrue: ["File does not exist..."			((FileDoesNotExistException fileName: fileName) readOnly: true) signal].	"StandardFileStream readOnlyFileNamed: 'kjsd.txt' "! !!BufferedFileStream class methodsFor: 'as yet unclassified'!initialize	self initializeDefaultBufferSize.! !!BufferedFileStream class methodsFor: 'as yet unclassified'!initializeDefaultBufferSize	DefaultBufferSize := 4096.! !!BufferedFileStream class methodsFor: 'as yet unclassified'!new	^ TextFileStream new.! !!UnhandledError methodsFor: 'as yet unclassified'!devDefaultAction	"The current computation is terminated. The cause of the error should be logged or reported to the user. If the program is operating in an interactive debugging environment the computation should be suspended and the debugger activated."	(GtkMessageDialog question: exception messageText, ', debug it?' ) = #yes		ifTrue: [ ^Processor activeProcess debugError: exception ]."	^ Processor activeProcess terminate."! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!checkType: value	^ value isInteger and: [ value >= 0 and: [ value <= self max ] ]! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	^ handle unsignedLongAt: 1 bigEndian: self isBigEndian.! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!min	^ 0! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!store: anInteger in: handle	handle unsignedLongAt: 1 put: anInteger bigEndian: self isBigEndian.! !!UnsignedByte class methodsFor: 'as yet unclassified'!max			^ 255! !!UnsignedInteger class methodsFor: 'as yet unclassified'!max			^ 4294967295! !!UnsignedShortInteger class methodsFor: 'as yet unclassified'!max			^ 65535! !!Workspace methodsFor: 'as yet unclassified'!buildMenuBar	| menu  edit  |	menu := GtkMenuBar new.	edit := GtkMenu new.	menu		append: AppLauncher fileMenu;		append: (edit createMenuItem: '_Edit');		append: workspaceView menu;		append: AppLauncher toolsMenu;		append: AppLauncher helpMenu.					^ menu.! !!Workspace methodsFor: 'as yet unclassified'!buildToolBar	| toolBar |	^ GtkToolbar new		appendItems: workspaceView toolBar;		yourself! !!Workspace methodsFor: 'as yet unclassified'!defaultCodeViewClass	^ WorkspaceView! !!Workspace methodsFor: 'as yet unclassified'!initialize	workspaceView := self defaultCodeViewClass new.	self container: (GtkVBox new		packStart: (self buildMenuBar) expand: false;		packStart: (self buildToolBar) expand: false;		packStart: (workspaceView view);		packStart: (GtkStatusbar new) expand: false	).! !!Workspace methodsFor: 'as yet unclassified'!inspectedVar: anObject	workspaceView inspectedVar: anObject.! !!TranscriptCodeEditor methodsFor: 'as yet unclassified'!defaultCodeViewClass	^ TranscriptCodeView! !!Workspace class methodsFor: 'as yet unclassified'!defaultSize	^ 640@480.! !!Workspace class methodsFor: 'as yet unclassified'!title	^'Workspace'! !!TranscriptCodeEditor class methodsFor: 'as yet unclassified'!title	^'Transcript'! !BufferedFileStream initialize!TranscriptCodeView initialize!TraitBehavior removeSelector: #initializeUsers!Application subclass: #Shell	instanceVariableNames: 'bindings'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!ExternalValue initialize!NativeFunctionRelocation removeSelector: #addressRelativeTo:!NativeFunctionRelocation removeSelector: #function!NativeFunctionRelocation removeSelector: #functionName!NativeFunctionRelocation removeSelector: #functionName:!NativeFunctionRelocation removeSelector: #patch:!NativeFunctionRelocation removeSelector: #patch:with:!ReadOnlyAsciiZ class removeSelector: #objectFromHandle:!ProcessorScheduler removeSelector: #activeProcess2!ProcessorScheduler removeSelector: #activeThreadData!ProcessorScheduler removeSelector: #primActiveThreadData!Process removeSelector: #threadData:!PrimitiveType class removeSelector: #defaultHandlerType!PrimitiveType class removeSelector: #instantiateHandler!NativeFunction removeSelector: #address!NativeFunction removeSelector: #bind!NativeFunction removeSelector: #invoke!NativeFunction removeSelector: #invokeAnswering:!NativeFunction removeSelector: #invokeAnswering:with:!NativeFunction removeSelector: #invokeAnswering:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:withArguments:!NativeFunction removeSelector: #invokeWith:!NativeFunction removeSelector: #invokeWith:with:!NativeFunction removeSelector: #invokeWith:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:with:with:!NativeFunction removeSelector: #invokeWithArguments:!NativeFunction removeSelector: #name!NativeFunction removeSelector: #name:!NativeFunction removeSelector: #throwNotKnownError!LibraryData removeSelector: #primitiveGetValue!LibExample initialize!LibC6 initialize!LibC6 removeSelector: #initializeUnistd!LibC6 removeSelector: #openPath:flags:!LibC6 removeSelector: #write2:buffer:size:!LibC removeSelector: #close!GPointer class removeSelector: #instantiateHandler!FileStream removeSelector: #position!FileDescriptor initialize!FileDescriptor removeSelector: #movePositionTo:!FileDescriptor removeSelector: #name!FileDescriptor removeSelector: #name:!FileDescriptor removeSelector: #positionFromEns:!FileDescriptor removeSelector: #setPositionAt:!FileDescriptor removeSelector: #setPositionFromEndAt:!CDeclFunction class removeSelector: #name:libraryNamed:returnType:argTypes:!ExecutableFunction class removeSelector: #name:library:!ExecutableFunction class removeSelector: #name:libraryNamed:!CDeclFunction removeSelector: #classFromType:!CDeclFunction removeSelector: #throwExternalFunctionError!ExecutableFunction removeSelector: #address!ExecutableFunction removeSelector: #bind!ExecutableFunction removeSelector: #invoke!ExecutableFunction removeSelector: #invokeWith:!ExecutableFunction removeSelector: #invokeWith:with:!ExecutableFunction removeSelector: #invokeWith:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithArguments:!ExecutableFunction removeSelector: #invokeWithReceiver:!ExecutableFunction removeSelector: #invokeWithReceiver:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:withArguments:!ExecutableFunction removeSelector: #library!ExecutableFunction removeSelector: #library:!ExecutableFunction removeSelector: #libraryName!ExecutableFunction removeSelector: #libraryNamed:!ExecutableFunction removeSelector: #name!ExecutableFunction removeSelector: #name:!ExecutableFunction removeSelector: #name:library:!ExecutableFunction removeSelector: #name:libraryNamed:!ExecutableFunction removeSelector: #primInvokeReceiver:withArguments:!ExecutableFunction removeSelector: #primInvokeWithArguments:!ExecutableFunction removeSelector: #primInvokeWithReceiver:withArguments:!ExecutableFunction removeSelector: #throwNotKnownError!ExternalSymbol removeSelector: #callingConventionString!ExternalObjectProxy removeSelector: #register!ExternalObjectProxy removeSelector: #unregister!AsciiZ class removeSelector: #objectFromHandle:!Executable class removeSelector: #huenul!DynamicLibrary class removeSelector: #addLibrary:named:!DynamicLibrary class removeSelector: #huemul!DynamicLibrary initialize!DynamicLibrary class removeSelector: #name:!DynamicLibrary class removeSelector: #named:!ExternalObject class removeSelector: #handle:!ExternalObject initialize!ExternalObject class removeSelector: #registry!ExternalObject class removeSelector: #registry:!AsciiZ removeSelector: #setFrom:!ExternalBuffer removeSelector: #finalize!ExternalBuffer removeSelector: #selfCheck!ExternalBuffer removeSelector: #setFrom:!ExternalBuffer removeSelector: #storeInto:size:!Executable removeSelector: #initialize!Executable removeSelector: #instantiateFunctionClass:!Executable removeSelector: #name:!Executable removeSelector: #nativeFunctionNamed:!Executable removeSelector: #primitiveOpen!DynamicLibrary removeSelector: #addExternal:!DynamicLibrary removeSelector: #basicName!DynamicLibrary removeSelector: #bind:!DynamicLibrary removeSelector: #bindFunction:!DynamicLibrary removeSelector: #cDeclFunctionNamed:returnType:argTypes:!DynamicLibrary removeSelector: #primitiveBind:!DynamicLibrary removeSelector: #primitiveBindFunction:!ExternalObject removeSelector: #isNullPointer!Object subclass: #ExternalObject	instanceVariableNames: 'handle'	classVariableNames: 'Registry'	poolDictionaries: ''	category: 'FFI-Types'!ExternalFunctionError class removeSelector: #function:!ExternalFunctionError removeSelector: #function!ExternalFunctionError removeSelector: #function:!ExternalFunctionError removeSelector: #isResumable!Error subclass: #ExternalFunctionError	instanceVariableNames: 'functionName'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!Application class removeSelector: #start!Application class removeSelector: #startWithArguments:!Class removeSelector: #superclass:methodDict:format:name:organization:instVarNames:classPool:sharedPools:!ClassBuilder removeSelector: #computeFormat:instSize:forSuper:ccIndex:!ClassBuilder removeSelector: #format:variable:words:pointers:weak:!Smalltalk removeClassNamed: #SystemChangeNotifierTest!RBProgramNodeVisitor subclass: #ASTChecker	instanceVariableNames: 'scope varsChangedInSend'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!RBProgramNodeVisitor subclass: #ASTTranslator	instanceVariableNames: 'methodBuilder receiverForCascade'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #Application	instanceVariableNames: 'arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!AssembleInstruction subclass: #AssembleCMov	instanceVariableNames: ''	classVariableNames: 'Condition'	poolDictionaries: ''	category: 'Exupery'!Object subclass: #AssemblerExupery	instanceVariableNames: 'stream blockAddresses jumpOffsets bytecodes instructionEncoders plugin relocator picEntries debugCollector source'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #BlockClosure	instanceVariableNames: 'method environment'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Contexts'!PluggableGtkSimpleApplication subclass: #ClassFinder	instanceVariableNames: 'classTrait'	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!Object subclass: #ColouringRegisterAllocator	instanceVariableNames: 'source result machine interferenceGraph registerStack registerFile registerTable spiltRegisters hasSpilt coloursUsed simplifyWorklist spillWorklist moveWorklist coalescedMoves isValidating deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #DebugInfo	instanceVariableNames: 'codeSourceReferences argVarsReferences tempVarsReferences capturedVarsReferences'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!Object subclass: #EventManager	instanceVariableNames: 'actionMap'	classVariableNames: 'ActionMaps'	poolDictionaries: ''	category: 'System-Object'!Error subclass: #ExternalFunctionError	instanceVariableNames: 'functionName '	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!Object subclass: #ExternalObject	instanceVariableNames: 'handle '	classVariableNames: 'Registry '	poolDictionaries: ''	category: 'FFI-Types'!ExternalObject subclass: #DynamicLibrary	instanceVariableNames: 'name symbolCache'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!DynamicLibrary subclass: #Executable	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!ExternalObject subclass: #ExternalBuffer	instanceVariableNames: 'size'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalBuffer subclass: #AsciiZ	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!DynamicLibrary class	instanceVariableNames: 'default'!ExternalObject subclass: #ExternalObjectProxy	instanceVariableNames: 'object'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalObjectProxy subclass: #ExternalArrayProxy	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalObject subclass: #ExternalSymbol	instanceVariableNames: 'name library'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!ExternalSymbol subclass: #ExecutableFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!ExecutableFunction subclass: #CDeclFunction	instanceVariableNames: 'returnType argTypes'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Error subclass: #ExternalSymbolError	instanceVariableNames: 'symbolName'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!ExternalObject subclass: #FileDescriptor	instanceVariableNames: ''	classVariableNames: 'StandardDescriptors'	poolDictionaries: ''	category: 'FFI-Types'!Error subclass: #FileStreamException	instanceVariableNames: 'fileName'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #CannotDeleteFileException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #FileDoesNotExistException	instanceVariableNames: 'readOnly'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #FileExistsException	instanceVariableNames: 'fileClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!AssemblyCopier subclass: #FinalCopier	instanceVariableNames: 'deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!LexicalScope subclass: #FunctionScope	instanceVariableNames: 'thisContextVar thisEnvVar tempVars capturedVars isHome hasInnerFreeVars hideTemps argVars uninitializedTemps capturedParentEnv'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #GIRBuilder	instanceVariableNames: 'ir currentBlock machine relocationInfo primitiveNode literals thisEnvVar cacheMap literalTemp source start stop debugInfo'	classVariableNames: 'InlinedSelectors SpecialConstants SpecialSelectors'	poolDictionaries: ''	category: 'Compiler-IR'!LexicalScope subclass: #InstanceScope	instanceVariableNames: 'vars'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!DynamicLibrary subclass: #LibC6	instanceVariableNames: ''	classVariableNames: 'LSeekDirectives OpenFlags'	poolDictionaries: ''	category: 'FFI-Libraries'!Object subclass: #LibExample	instanceVariableNames: ''	classVariableNames: 'GETPID'	poolDictionaries: ''	category: 'Guille-Test'!DynamicLibrary subclass: #LibReadLine	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!ExternalSymbol subclass: #LibraryData	instanceVariableNames: 'type'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Object subclass: #LivenessAnalyser	instanceVariableNames: 'source hasUpdated isValidating deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #MedLanguage	instanceVariableNames: 'in out start stop'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedCMov	instanceVariableNames: 'type from to'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedEnter	instanceVariableNames: 'argument'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedLeave	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedLiteral	instanceVariableNames: 'literal'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLiteral subclass: #MedFunction	instanceVariableNames: 'block byteCodeAddress'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!ExecutableFunction subclass: #NativeFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Object subclass: #PrimitiveType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!PrimitiveType subclass: #IntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!RBProgramNode subclass: #RBReturnNode	instanceVariableNames: 'return value homeBinding frameBinding'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Nodes'!ExternalObject subclass: #ReadOnlyAsciiZ	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SemanticWarning subclass: #RedeclaredVariableWarning	instanceVariableNames: 'variableNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #RelocationInfo	instanceVariableNames: 'offset'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #ExecutableFunctionRelocation	instanceVariableNames: 'functionName'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #FunctionRelocation	instanceVariableNames: 'function'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #LiteralRelocation	instanceVariableNames: 'literals'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!ExecutableFunctionRelocation subclass: #NativeFunctionRelocation	instanceVariableNames: 'libraryName'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!NativeFunctionRelocation subclass: #ExternalFunctionRelocation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #PrimitiveRelocation	instanceVariableNames: 'number'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!Object subclass: #ScopeVar	instanceVariableNames: 'scope usage'	classVariableNames: 'UsageAutomaton'	poolDictionaries: ''	category: 'Compiler-Semantics'!ScopeVar subclass: #GlobalVar	instanceVariableNames: 'assoc'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!ScopeVar subclass: #LocalVar	instanceVariableNames: 'name index'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!LocalVar subclass: #ArgVar	instanceVariableNames: 'isArg'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!LocalVar subclass: #CapturedVar	instanceVariableNames: 'sourceTemp'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!ByteArray variableByteSubclass: #ExternalValue	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!Object subclass: #SharedPool	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Pools'!Application subclass: #Shell	instanceVariableNames: 'bindings '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!IntegerType subclass: #SignedIntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedByte	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedShortInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!Object subclass: #SourceReference	instanceVariableNames: 'sourceStart sourceStop codeStop'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!RelocationInfo subclass: #SpecialSelectorRelocation	instanceVariableNames: 'specialSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!Model subclass: #StringHolder	instanceVariableNames: 'contents'	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Kernel-Remnants'!Object subclass: #SystemTracer	instanceVariableNames: 'byteStream traceQueue oopMap nextChunk nilOop count'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Tracer'!LocalVar subclass: #TempVar	instanceVariableNames: 'isArg'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Error subclass: #TraitException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Kernel'!TraitException subclass: #TraitCompositionException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Composition'!Error subclass: #TypeConvertionError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!FileStream subclass: #UnbufferedFileStream	instanceVariableNames: 'name fileID'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!Smalltalk renameClassNamed: #BufferedFileStream2 as: #BufferedFileStream!UnbufferedFileStream subclass: #BufferedFileStream	instanceVariableNames: ''	classVariableNames: 'DefaultBufferSize'	poolDictionaries: ''	category: 'Files-Kernel'!BufferedFileStream subclass: #BinaryFileStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!BufferedFileStream subclass: #TextFileStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!IntegerType subclass: #UnsignedIntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedByte	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedShortInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SemanticWarning subclass: #UnusedVariableWarning	instanceVariableNames: 'variableNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #VarReference	instanceVariableNames: 'name'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!RelocationInfo subclass: #VariableRelocation	instanceVariableNames: 'variable'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!PluggableGtkSimpleApplication subclass: #Workspace	instanceVariableNames: 'workspaceView'	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!Workspace subclass: #TranscriptCodeEditor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!!Object methodsFor: 'as yet unclassified'!errorSubscriptBounds: index 	"Create an error notification that an improper integer was used as an index."	self error: 'subscript is out of bounds: ' , index printString! !!Object methodsFor: 'as yet unclassified'!executeMethod: compiledMethod withArgs: argArray	"Execute compiledMethod against the receiver and args in argArray"	| selector |	<primitive: 188>	selector _ Symbol new.	self class addSelectorSilently: selector withMethod: compiledMethod.	^ [self perform: selector withArguments: argArray]		ensure: [self class basicRemoveSelector: selector]! !!Object methodsFor: 'as yet unclassified'!withArgs: argArray executeMethod: compiledMethod	"For compatibility with Aqueak"	self executeMethod: compiledMethod withArgs: argArray! !!Application methodsFor: 'as yet unclassified'!arguments	^ arguments.! !!Application methodsFor: 'as yet unclassified'!arguments: anArray	arguments := anArray.! !!Application methodsFor: 'as yet unclassified'!main	self subclassResponsibility.! !!Application methodsFor: 'as yet unclassified'!startUp	Smalltalk startUp.	^ self main.! !!Behavior methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return true if it is safe to zap the method dictionary on #obsolete"	^true! !!Behavior methodsFor: 'as yet unclassified'!isWeak	^ (format bitAnd: 4) = 1.! !!Behavior methodsFor: 'as yet unclassified'!obsolete	"Invalidate and recycle local methods,	e.g., zap the method dictionary if can be done safely."	self canZapMethodDictionary		ifTrue: [self methodDict: self emptyMethodDictionary].! !!Behavior methodsFor: 'as yet unclassified'!removeSelector: selector	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method."	| oldMethod |		oldMethod _ self methodDict at: selector ifAbsent: [^ self].	self methodDict removeKey: selector.	"Now flush Squeak's method cache, either by selector or by method"	oldMethod flushCache.	selector flushCache! !!Behavior methodsFor: 'as yet unclassified'!selectorsAndMethodsDo: aBlock	"Evaluate selectorBlock for all the message selectors in my method dictionary."	^ self methodDict keysAndValuesDo: aBlock! !!Behavior methodsFor: 'as yet unclassified'!setTraitComposition: aTraitComposition	| oldComposition |	(self hasTraitComposition not and: [aTraitComposition isEmpty]) ifTrue: [^self].	aTraitComposition assertValidUser: self.	oldComposition _ self traitComposition.	self traitComposition: aTraitComposition."	self applyChangesOfNewTraitCompositionReplacing: oldComposition."		oldComposition traits do: [:each | each removeUser: self].	aTraitComposition traits do: [:each | each addUser: self]! !!Behavior methodsFor: 'as yet unclassified'!traitCompositionString	^self hasTraitComposition		ifTrue: [self traitComposition asString]		ifFalse: ['{}']! !!Behavior methodsFor: 'as yet unclassified'!typeOfClass	"Answer a symbol uniquely describing the type of the receiver"	self isWeak ifTrue: [ ^ #weak ].	^ (format bitAnd: 3) caseOf: {		[ 0 ] -> [ #normal ].		[ 1 ] -> [ #variable ].		[ 2 ] -> [ #bytes ].		[ 3 ] -> [ #words ]	}! !!Behavior methodsFor: 'as yet unclassified'!whichSelectorsReferTo: literal	"Answer a set of selectors whose methods access the argument as a literal."	| who |	who _ IdentitySet new.	self selectorsAndMethodsDo: 		[:sel :method |		(method hasLiteral: literal)			ifTrue:				[((literal isVariableBinding) not					or: [method literals allButLast includes: literal])						ifTrue: [who add: sel]]].	^ who! !!BehaviorTest methodsFor: 'as yet unclassified'!testBehaviorSubclasses	"self run: #testBehaviorSubclasses"		| b b2 |"	b := Behavior new.	b superclass: OrderedCollection.	b methodDictionary: Dictionary new.	self shouldnt: [b subclasses ] raise: Error.	self shouldnt: [b withAllSubclasses] raise: Error.	self shouldnt: [b allSubclasses] raise: Error.	b2 := Behavior new.	b2 superclass: b.	b2 methodDictionary: Dictionary new.	self assert: (b subclasses includes: b2).	self assert: (b withAllSubclasses includes: b)."! !!BlockClosure methodsFor: 'as yet unclassified'!valueWithArguments: anArray 	"Evaluate the block with given args. Fail if the block expects other than the given number of arguments."	^ environment executeMethod: method withArgs: anArray ! !!ClassBrowser methodsFor: 'as yet unclassified'!buildClassCategoriesView	| model tree col cell |	tree := nil->nil.	SystemOrganization categories do: [ :each |		| category |		category := tree.		(each subStrings: '-') do: [ :cat |			category value ifNil: [ category value: Dictionary new].			category := category value associationAt: cat ifAbsent: [ category value at: cat put: nil. category value associationAt: cat ]		]	].	model := GtkTreeStore new: {String. String}.	[ self addSubcategoriesFrom: tree fromIter: nil inModel: model ] fork.	classCategoriesTree := GtkTreeView model: model.	col := GtkTreeViewColumn title: 'Class categories'.	cell := GtkCellRendererPixbuf new.	col		packStart: cell expand: false;		addAttribute: #stockId column: 1 on: cell.	cell := GtkCellRendererText new.	col		packStart: cell;		addAttribute: #text column: 0 on: cell.		classCategoriesTree appendColumn: col.	classCategoriesTree selection when: #changed send: #onClassCategoryChanged to: self.	classCategoriesTree enableTreeLines: true.	^ GtkScrolledWindow withChild: classCategoriesTree! !!ClassBrowser methodsFor: 'as yet unclassified'!loadClassMethodsOf: aClassClass	| iter |	classMethodsTree model clear.	aClassClass organization categories do: [ :cat |		iter := classMethodsTree model append: nil->{cat asString. true. 'grey'. 'gtk-info'}.		(aClassClass organization listAtCategoryNamed: cat) asSortedCollection do: [ :sel |			classMethodsTree model append: iter->{sel asString. false. 'grey'. 'gtk-execute'}		]	].	classMethodsTree expandAll.! !!ClassBrowser methodsFor: 'as yet unclassified'!loadInstanceMethodsOf: aClass	| iter |	instanceMethodsTree model clear.	aClass organization categories do: [ :cat |		iter := instanceMethodsTree model append: nil->{cat asString. true. 'grey'. 'gtk-info'}.		(aClass organization listAtCategoryNamed: cat) asSortedCollection do: [ :sel |			instanceMethodsTree model append: iter->{sel asString. false. 'grey'. 'gtk-execute'}		]	].	instanceMethodsTree expandAll.! !!ClassBrowser methodsFor: 'as yet unclassified'!onClassHierarchyChanged	| class iter path newIter aCategory classHierarchySelectedRow classesTreeSelectedRow |	classHierarchySelectedRow := classHierarchyTree selectedRow.	classHierarchySelectedRow ifNotNil: [		class := Smalltalk at: (classHierarchySelectedRow first asSymbol).							aCategory := class category.		( aCategory isNotNil and: [ aCategory ~= selectedClassCategory ] ) ifTrue: [			selectedClassCategory := aCategory.			iter := classCategoriesTree model firstIter.			newIter := nil.			(aCategory subStrings: '-') do: [ :cat |				newIter ifNotNil: [ iter := newIter ].				iter := self classCategoryFor: cat firstIter: iter.				newIter := classCategoriesTree model firstChildAt: iter.			].			path := classCategoriesTree model pathFromIter: iter.			classCategoriesTree expandRowsUpTo: path.			classCategoriesTree moveCursorAt: path.					classesTree model clear.			(SystemOrganization listAtCategoryNamed: aCategory) sort do: [ :ea |				classesTree model append: {ea asString. 'gtk-execute'}			]		].							self selectClass: class.	]! !!ClassBuilder methodsFor: 'as yet unclassified'!formatForType: type	^ type caseOf: {		[ #normal ] -> [ 0 ].		[ #variable ] -> [ 1 ].		[ #bytes ] -> [ 2 ].		[ #words ] -> [ 3 ].		[ #weak ] -> [ 5 "binary: 4 + 0 + 0 + 1" ]	} otherwise: [ self error: 'Unknown class type' ].! !!ClassBuilder methodsFor: 'as yet unclassified'!needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Answer whether we need a new subclass to conform to the requested changes"	"Check if we really need a new subclass"	oldClass ifNil:[^true]. "yes, it's a new class"	newSuper == oldClass superclass ifFalse:[^true]. "yes, it's a superclass change"	type = oldClass typeOfClass ifFalse:[^true]. "yes, it's a format change"	instVars = oldClass instVarNames ifFalse:[^true]. "yes, it's an iVar change"	^false! !!ClassBuilder methodsFor: 'as yet unclassified'!newSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Create a new subclass of the given superclass with the given specification."	| newClass |	(oldClass == nil or:[oldClass isMeta not]) 		ifTrue:[newClass := self privateNewSubclassOf: newSuper from: oldClass]		ifFalse:[newClass := oldClass clone].	newClass 		superclass: newSuper		methodDictionary: "Method"Dictionary new		instanceSize: (newSuper instSize + instVars size)		format: (self formatForType: type);		setInstVarNames: instVars.	oldClass ifNotNil:[		newClass organization: oldClass organization.		"Recompile the new class"		oldClass hasMethods 			ifTrue:[newClass compileAllFrom: oldClass].		oldClass hasTraitComposition ifTrue: [			newClass setTraitComposition: oldClass traitComposition copyTraitExpression ].		oldClass class hasTraitComposition ifTrue: [			newClass class setTraitComposition: oldClass class traitComposition copyTraitExpression ].				self recordClass: oldClass replacedBy: newClass.	].	(oldClass == nil or:[oldClass isObsolete not]) 		ifTrue:[newSuper addSubclass: newClass]		ifFalse:[newSuper addObsoleteSubclass: newClass].	^newClass! !!ClassBuilder methodsFor: 'as yet unclassified'!privateNewSubclassOf: newSuper from: oldClass	"Create a new meta and non-meta subclass of newSuper using oldClass as template"	"WARNING: This method does not preserve the superclass/subclass invariant!!"	| newSuperMeta oldMeta newMeta |	oldClass ifNil:[^self privateNewSubclassOf: newSuper].	newSuperMeta _ newSuper ifNil:[Class] ifNotNil:[newSuper class].	oldMeta _ oldClass class.	newMeta _ oldMeta clone.	newMeta 		superclass: newSuperMeta		methodDictionary: "Method"Dictionary new		instanceSize: oldMeta instSize		format: oldMeta format;		setInstVarNames: oldMeta instVarNames;		organization: oldMeta organization.	"Recompile the meta class"	oldMeta hasMethods 		ifTrue:[newMeta compileAllFrom: oldMeta].	"Record the meta class change"	self recordClass: oldMeta replacedBy: newMeta.	"And create a new instance"	^newMeta adoptInstance: oldClass from: oldMeta! !!ClassBuilder methodsFor: 'as yet unclassified'!reshapeClass: oldClass toSuper: newSuper	"Reshape the given class to the new super class. Recompile all the methods in the newly created class. Answer the new class."	| instVars |	instVars _ instVarMap at: oldClass name ifAbsent:[oldClass instVarNames].	^self newSubclassOf: newSuper 			type: oldClass typeOfClass 			instanceVariables: instVars 			from: oldClass! !!ClassDescription methodsFor: 'as yet unclassified'!classVersion	"Default.  Any class may return a later version to inform readers that use ReferenceStream.  8/17/96 tk"	"This method allows you to distinguish between class versions when the shape of the class 	hasn't changed (when there's no change in the instVar names).	In the conversion methods you usually can tell by the inst var names 	what old version you have. In a few cases, though, the same inst var 	names were kept but their interpretation changed (like in the layoutFrame).	By changing the class version when you keep the same instVars you can 	warn older and newer images that they have to convert."	^ 0! !!ClassDescription methodsFor: 'as yet unclassified'!obsolete	"Make the receiver obsolete."	superclass removeSubclass: self.	self organization: nil.	super obsolete.! !!ClassDescription methodsFor: 'as yet unclassified'!removeSelector: selector 	"Remove the message whose selector is given from the method 	dictionary of the receiver, if it is there. Answer nil otherwise."		| priorMethod priorProtocol | 	priorMethod _ self compiledMethodAt: selector ifAbsent: [^ nil].	priorProtocol _ self whichCategoryIncludesSelector: selector.	SystemChangeNotifier uniqueInstance		doSilently: [self organization removeElement: selector ].	super removeSelector: selector.	SystemChangeNotifier uniqueInstance 			methodRemoved: priorMethod selector: selector inProtocol: priorProtocol class: self.! !!ClassDescription methodsFor: 'as yet unclassified'!updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil	| currentCategory effectiveCategory sel changedCategories composition |	changedCategories _ IdentitySet new.	composition := self hasTraitComposition		ifTrue: [self traitComposition]		ifFalse: [TraitComposition new].	(composition methodDescriptionsForSelector: aSymbol) do: [:each |		sel _ each selector.		(self includesLocalSelector: sel) ifFalse: [			currentCategory _ self organization categoryOfElement: sel.			effectiveCategory _ each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.			effectiveCategory isNil ifTrue: [				currentCategory ifNotNil: [changedCategories add: currentCategory].				self organization removeElement: sel.			] ifFalse: [				((currentCategory isNil or: [currentCategory == ClassOrganizer ambiguous or: [currentCategory == oldCategoryOrNil]]) and: [currentCategory ~~ effectiveCategory]) ifTrue: [					currentCategory ifNotNil: [changedCategories add: currentCategory].					self organization 						classify: sel 						under: effectiveCategory						suppressIfDefault: false]]]].	^ changedCategories! !!ClassDescription methodsFor: 'as yet unclassified'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	(self includesSelector: aSelector)		ifTrue: [^ self organization categoryOfElement: aSelector]		ifFalse: [^nil]! !!Class methodsFor: 'as yet unclassified'!classPool: aDictionary	classPool _ aDictionary! !!Class methodsFor: 'as yet unclassified'!copy 	| newClass |	newClass _ self class copy new		superclass: superclass		methodDict: self methodDict copy		instanceSize: self instSize		format: format		name: name		organization: self organization copy		instVarNames: instanceVariables copy		classPool: classPool copy		sharedPools: sharedPools.	Class instSize+1 to: self class instSize do:		[:offset | newClass instVarAt: offset put: (self instVarAt: offset)].	^ newClass! !!Class methodsFor: 'as yet unclassified'!deactivate	"A remnant from the 3.3a modules work, retained . Does nothing, but may be overridden in Metaclasses."! !!Class methodsFor: 'as yet unclassified'!isSystemDefined	"Answer true if the receiver is a system-defined class, and not a UniClass (an instance-specific lightweight class)"	^ self == self officialClass! !!Class methodsFor: 'as yet unclassified'!obsolete	"Change the receiver and all of its subclasses to an obsolete class."	self == Object 		ifTrue: [^self error: 'Object is NOT obsolete'].	self setName: 'AnObsolete' , self name.	Object class instSize + 1 to: self class instSize do:		[:i | self instVarAt: i put: nil]. "Store nil over class instVars."	self classPool: nil.	self sharedPools: nil.	self class obsolete.	super obsolete.! !!Class methodsFor: 'as yet unclassified'!officialClass	"I am not a UniClass.  (See Player officialClass).  Return the class you use to make new subclasses."	^ self! !!Class methodsFor: 'as yet unclassified'!removeFromSystem	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."	self removeFromSystem: true.! !!Class methodsFor: 'as yet unclassified'!removeFromSystem: logged	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."		"keep the class name and category for triggering the system change message. If we wait to long, then we get obsolete information which is not what we want."	"tell class to deactivate and unload itself-- two separate events in the module system"	self deactivate; unload.	self superclass ifNotNil:		["If we have no superclass there's nothing to be remembered"		self superclass addObsoleteSubclass: self].	self environment forgetClass: self logged: logged.	self obsolete.! !!Class methodsFor: 'as yet unclassified'!sharedPools: aCollection	sharedPools _ aCollection! !!Class methodsFor: 'as yet unclassified'!superclass: sup methodDict: md instanceSize: is format: ft name: nm organization: org instVarNames: nilOrArray classPool: pool sharedPools: poolSet 	"Answer an instance of me, a new class, using the arguments of the 	message as the needed information.	Must only be sent to a new instance; else we would need Object flushCache."	superclass := sup.	methodDict := md.	instanceSize := is.	format := ft.	name := nm.	instanceVariables := nilOrArray.	classPool := pool.	sharedPools := poolSet.	self organization: org.! !!Class methodsFor: 'as yet unclassified'!unload	"Sent when a the class is removed.  Does nothing, but may be overridden by (class-side) subclasses."! !!Class methodsFor: 'as yet unclassified'!variableByteSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable byte-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableByteSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!variableSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable pointer variables."	^(ClassBuilder new)		superclass: self		variableSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!variableWordSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable word-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableWordSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!weakSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have weak indexable pointer variables."	^(ClassBuilder new)		superclass: self		weakSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!AppLauncher class methodsFor: 'as yet unclassified'!openAboutHuemul	| dlg logo |	logo := GdkPixbuf fromFile: 'Huemul.jpg'.	dlg := GtkAboutDialog new.	dlg		aboutDialogName: 'Huemul Smalltalk';		version: '0.8';		license: (StandardFileStream readOnlyFileNamed: 'LICENSE') upToEnd;		website: 'http://www.guillermomolina.com.ar/huemul';		comments: 'This is Huemul Smalltalk';		authors: {'Guillermo Adrian Molina'};		logo: logo.	dlg runAndDestroy! !!AppLauncher class methodsFor: 'as yet unclassified'!openWorkspace	^ Workspace open! !!Application class methodsFor: 'as yet unclassified'!startUp	^ self new startUp.! !!Application class methodsFor: 'as yet unclassified'!startUpWithArguments: arguments	| application |	application := self new.	application arguments: arguments.	^ application startUp.! !!Behavior class methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return false since zapping the method dictionary of Behavior class or its subclasses will cause the system to fail."	^false! !!ClassBrowser class methodsFor: 'as yet unclassified'!defaultSize	^ 640@480.! !!ClassBrowser class methodsFor: 'as yet unclassified'!title	^'Class browser'! !!ClassFinder class methodsFor: 'as yet unclassified'!defaultSize	^ 200@300.! !!ClassFinder class methodsFor: 'as yet unclassified'!title	^'Class finder'! !!CompiledMethod methodsFor: 'as yet unclassified'!hasLiteral: literal	"Answer whether the receiver references the argument, literal."	literals ifNil: [ ^false ].	^ literals hasLiteral: literal.! !!CompiledMethod methodsFor: 'as yet unclassified'!sourcePointer	"Answer the integer which can be used to find the source file and position for this method.	Not sources yet"	^ 0! !!CompiledMethodWithNode class methodsFor: 'as yet unclassified'!method: aCompiledMethod node: aMethodNode	^ self new method: aCompiledMethod; node: aMethodNode.! !!Compiler methodsFor: 'as yet unclassified'!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into a method. In other words, if receiver is not nil, then the text can refer to instance variables of that receiver (the Inspector uses this). If aContext is not nil, the text can refer to temporaries in that context (the Debugger uses this). If aRequestor is not nil, then it will receive a notify:at: message before the attempt to evaluate is aborted. Finally, the compiled method is directly invoked without modifying the receiving-class."	"| methodNode method value |	  	(Preferences compileUseNewCompiler or: 			[aContext ifNotNil: [aContext method isClosureCompiled] ifNil: [false]]) ifTrue: 				[^ self evaluate2: textOrStream 					    in: aContext 					    to: receiver 					    notifying: aRequestor 					    ifFail: failBlock 					    logged: logFlag].		class := (aContext isNil 		ifTrue: [ receiver ] 		ifFalse: [ aContext receiver ])			class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode := self 		translate: sourceStream		noPattern: true 		ifFail: [ ^ failBlock value ].	method := methodNode generate.	self interactive		ifTrue: [ method := method copyWithTempNames: methodNode tempNames ].	value := receiver		executeMethod: method 		withArgs: (context isNil			ifTrue: [ #() ]			ifFalse: [ Array with: aContext ]).	logFlag 		ifTrue: [ SystemChangeNotifier uniqueInstance evaluated: sourceStream contents context: aContext ].	^ value."	| string block |	string _ textOrStream readStream upToEnd.	block := self compileDoIt: string in: aContext to: receiver notifying: aRequestor ifFail: [^ failBlock value] log: logFlag.	^ block value! !!Exception methodsFor: 'as yet unclassified'!messageText	messageText ifNil: [ ^ self class name asString ].	^messageText! !!Exception methodsFor: 'as yet unclassified'!receiver	^ self signalerContext receiver! !!ExternalFunctionError methodsFor: 'as yet unclassified'!functionName	"Answer the function name that was beiing used."	^functionName! !!ExternalFunctionError methodsFor: 'as yet unclassified'!functionName: argument	"Specify the function name that was beiing used."	functionName := argument! !!ExternalFunctionError class methodsFor: 'as yet unclassified'!functionName: argument	^self new functionName: argument; yourself! !!ExternalObject methodsFor: 'as yet unclassified'!= anObject 	(anObject isKindOf: self class)		ifTrue: [^ anObject handle = self handle]		ifFalse: [^ false]! !!ExternalObject methodsFor: 'as yet unclassified'!beNull	^ handle beNull.! !!ExternalObject methodsFor: 'as yet unclassified'!finalize		self free.	self unregister.! !!ExternalObject methodsFor: 'as yet unclassified'!free	"Should override this"! !!ExternalObject methodsFor: 'as yet unclassified'!initialize	handle := self class defaultHandlerClass new.	self register.! !!ExternalObject methodsFor: 'as yet unclassified'!isNull	^ self handle isNull.! !!ExternalObject methodsFor: 'as yet unclassified'!register	Registry add: self.! !!ExternalObject methodsFor: 'as yet unclassified'!unregister		Registry remove: self ifAbsent:[  ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!addSymbol: anExternalSymbol	^ symbolCache at: anExternalSymbol name put: anExternalSymbol.! !!DynamicLibrary methodsFor: 'as yet unclassified'!bindSymbol: anExternalSymbol	self open.	^ self primitiveBindSymbol: anExternalSymbol.! !!DynamicLibrary methodsFor: 'as yet unclassified'!cDeclFunctionNamed: functionName	^ symbolCache at: functionName ifAbsent: [ self error: 'You must initialize the function before using it' ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!close		handle isNull ifFalse: [ 		self primitiveClose		handle beNull.	].! !!DynamicLibrary methodsFor: 'as yet unclassified'!initialize	super initialize.	symbolCache := Dictionary new.! !!DynamicLibrary methodsFor: 'as yet unclassified'!initializeCDeclFunctionNamed: functionName returnType: retType argTypes: argTypesArray	^ symbolCache at: functionName put: 			(CDeclFunction name: functionName library: self  returnType: retType argTypes: argTypesArray)! !!DynamicLibrary methodsFor: 'as yet unclassified'!initializeLibraryDataNamed: symbolName type: type	^ symbolCache at: symbolName put: (LibraryData name: symbolName library: self  type: type)! !!DynamicLibrary methodsFor: 'as yet unclassified'!libraryDataNamed: symbolName	^ symbolCache at: symbolName ifAbsent: [ self error: 'You must initialize the symbol before using it' ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!name	^name! !!DynamicLibrary methodsFor: 'as yet unclassified'!name: aName	name := aName.! !!DynamicLibrary methodsFor: 'as yet unclassified'!nativeFunctionNamed: functionName	^ symbolCache at: functionName ifAbsent: [ 		symbolCache at: functionName put: (NativeFunction name: functionName library: self)	].! !!DynamicLibrary methodsFor: 'as yet unclassified'!open		handle isNull ifTrue: [ self primitiveOpen ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveBindSymbol: anExternalSymbol	"Primitive. Find the given symbol in the library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 203>	^ anExternalSymbol throwNotKnownError.! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveClose	"Primitive. Close the given library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 202>! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveOpen	"Primitive. Open the given library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 198>	self primitiveFailed.! !!DynamicLibrary methodsFor: 'as yet unclassified'!printOn: aStream	aStream nextPutAll: self name.! !!DynamicLibrary methodsFor: 'as yet unclassified'!symbolNamed: symbolName	^ symbolCache at: symbolName ifAbsent: [ self error: 'You must initialize the symbol before using it' ]! !!Executable methodsFor: 'as yet unclassified'!name	^ Utilities executableName ! !!Executable methodsFor: 'as yet unclassified'!primitiveSmallIntegerAdd: receiver with: argument	^ (self nativeFunctionNamed: #primitiveSmallIntegerAdd) invokeReceiver: receiver with: argument.! !!ExternalBuffer methodsFor: 'as yet unclassified'!asByteArray	| array |	size ifNil: [ ^ self class throwTypeConvertionError ].	array := ByteArray new: self basicSize.	self storeInto: array.	^ array	! !!ExternalBuffer methodsFor: 'as yet unclassified'!atAllPut: constant	^ LibC6 default memSet: self constant: constant count: self size.! !!ExternalBuffer methodsFor: 'as yet unclassified'!atAllPutZero	^ self atAllPut: 0.! !!ExternalBuffer methodsFor: 'as yet unclassified'!basicSize	^ size.! !!ExternalBuffer methodsFor: 'as yet unclassified'!byteAt: index	<primitive: 190>	index isNumber		ifTrue: [self errorSubscriptBounds: index]		ifFalse: [self errorNonIntegerIndex].! !!ExternalBuffer methodsFor: 'as yet unclassified'!byteAt: index put: value	<primitive: 191>	index isNumber		ifTrue: [self errorSubscriptBounds: index]		ifFalse: [self errorNonIntegerIndex].! !!ExternalBuffer methodsFor: 'as yet unclassified'!free		handle isNull ifFalse: [ 		LibC6 default free: self.		self beNull.	]! !!ExternalBuffer methodsFor: 'as yet unclassified'!loadFrom: aByteArray	<primitive: 199>	self primitiveFailed.! !!ExternalBuffer methodsFor: 'as yet unclassified'!size	^ self basicSize.! !!ExternalBuffer methodsFor: 'as yet unclassified'!size: anInteger	size := anInteger.! !!ExternalBuffer methodsFor: 'as yet unclassified'!storeInto: aByteArray	<primitive: 218>	^ self class throwTypeConvertionError.! !!AsciiZ methodsFor: 'as yet unclassified'!asString	^ handle toString.! !!AsciiZ methodsFor: 'as yet unclassified'!asString2	| calcSize string |	size ifNil: [ ^ self class throwTypeConvertionError ].	calcSize := self strlen.	calcSize >= self size ifTrue: [ ^ self class throwTypeConvertionError ].	string := String new: calcSize.	self storeInto: string.	^ string! !!AsciiZ methodsFor: 'as yet unclassified'!loadFrom: aString		super loadFrom: aString.	self byteAt: (aString size + 1) put: 0.! !!AsciiZ methodsFor: 'as yet unclassified'!strlen	^ LibC6 default strLen: self.! !!ExternalFunction methodsFor: 'as yet unclassified'!library	^ library! !!ExternalFunction methodsFor: 'as yet unclassified'!library: aLibrary	library := aLibrary! !!ExternalFunction methodsFor: 'as yet unclassified'!name	^name! !!ExternalFunction methodsFor: 'as yet unclassified'!name: aName	name := aName! !!ExternalFunction methodsFor: 'as yet unclassified'!name: aName library: aLibrary	self name: aName.	self library: aLibrary! !!ExternalFunction methodsFor: 'as yet unclassified'!reload	library ifNil: [ ^ self throwNotKnownError ].	self handle: (library findFunction: self)! !!ExternalLibrary methodsFor: 'as yet unclassified'!bindFunction: function	| answer |	answer := self primitiveBindFunction: function.	answer ifNotNil: [ ^ answer ].	self open. "Library may be closed, open it and retry"	answer := self primitiveBindFunction: answer.	answer ifNotNil: [ ^ answer ].	^ function throwNotKnownError.		! !!ExternalLibrary methodsFor: 'as yet unclassified'!closeLibrary		(handle isNotNil and: [ handle isNull not ]) ifTrue: [ self primitiveClose ].	self handle: nil.	functionCache := nil.! !!ExternalLibrary methodsFor: 'as yet unclassified'!openLibrary		self primitiveOpen.	self initializeFunctionCache.! !!ExternalLibrary methodsFor: 'as yet unclassified'!primitiveBindFunction: function	"Primitive. Find the given symbol in the library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 203>	^ nil.! !!ExternalObject class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: self! !!ExternalObject class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalAddress! !!ExternalObject class methodsFor: 'as yet unclassified'!handleFromObject: anObject	^ self handleFromObject: anObject ifError: [ self throwTypeConvertionError ]! !!ExternalObject class methodsFor: 'as yet unclassified'!handleFromObject: anObject ifError: aBlock		(anObject isKindOf: ExternalObject) ifFalse: [ ^ aBlock value ].	^ anObject handle.	! !!ExternalObject class methodsFor: 'as yet unclassified'!initialize	Registry := WeakRegistry new.	Smalltalk addToShutDownList: self.! !!ExternalObject class methodsFor: 'as yet unclassified'!objectFromHandle: handle	^self objectFromHandle: handle ifError: [ self throwTypeConvertionError ]! !!ExternalObject class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; yourself! !!ExternalObject class methodsFor: 'as yet unclassified'!quit	Registry do: [ :each | each free ].	self allSubclassesDo: [ :ea | ea quit ]! !!ExternalObject class methodsFor: 'as yet unclassified'!shutDown: quitting	quitting ifTrue: [ self quit ].! !!ExternalObject class methodsFor: 'as yet unclassified'!throwTypeConvertionError	^ TypeConvertionError new signal! !!DynamicLibrary class methodsFor: 'as yet unclassified'!default	self = DynamicLibrary ifTrue: [ self error: 'Create a class to create its singleton' ].	default ifNil: [	"Represents the executable itself"		default := self new.		default name: self moduleName.		default open.	].	^ default.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!initialize	self = DynamicLibrary ifFalse: [ 		Smalltalk addToShutDownList: self	].! !!DynamicLibrary class methodsFor: 'as yet unclassified'!moduleName	self subClassResponsibility.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!resetLibrary	default := nil.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!shutDown: aBool	default ifNotNil: [ default close ].! !!Executable class methodsFor: 'as yet unclassified'!huemul	^ self default! !!Executable class methodsFor: 'as yet unclassified'!moduleName	^nil.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: ByteArray! !!ExternalBuffer class methodsFor: 'as yet unclassified'!fromByteArray: aByteArray	| anExternalBuffer |		anExternalBuffer := ExternalBuffer new: aByteArray size.	anExternalBuffer setFrom: aByteArray.	^ anExternalBuffer.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!handleFromObject: aByteArray ifError: aBlock		(aByteArray isKindOf: ByteArray) ifFalse: [ 		^ super handleFromObject: aByteArray ifError: aBlock	].	^ ( self fromByteArray: aByteArray ) handle.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!new: size	| anExternalBuffer |	"This space is allocated from the system not 	from Object Memory, you will have to give it back, 	as it is not garbage collected"	anExternalBuffer := LibC6 default malloc: (size +  10).	anExternalBuffer size: size.	^ anExternalBuffer! !!AsciiZ class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: String! !!AsciiZ class methodsFor: 'as yet unclassified'!fromString: aString	| anAsciiZ |		anAsciiZ := AsciiZ new: aString size + 1.	anAsciiZ loadFrom: aString.	^ anAsciiZ.! !!AsciiZ class methodsFor: 'as yet unclassified'!handleFromObject: aString ifError: aBlock		(aString isKindOf: String) ifFalse: [ 		^ super handleFromObject: aString ifError: aBlock	].	^ ( self fromString: aString ) handle.! !!AsciiZ class methodsFor: 'as yet unclassified'!new: size	| buffer asciiZ |	buffer := super new: size.	asciiZ := AsciiZ new handle: buffer handle.	asciiZ size: size.	asciiZ atAllPutZero.	buffer handle: ExternalAddress nullPointer.	^ asciiZ! !!AsciiZ class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; asString! !!ExternalFunction class methodsFor: 'as yet unclassified'!name: aName library: aLibrary	^self new name: aName library: aLibrary! !!ExternalLibrary class methodsFor: 'as yet unclassified'!huemul	Huemul ifNil: [	"Represents the executable itself"		Huemul := self new.		Huemul open.	].	^ Huemul.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!handle	self object ifNil: [ handle beNull ].	^ handle.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!initialize	super initialize.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!initializePointer	self handle forObject: self object.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!object	^ self objectPointer at: 1! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!object: anObject	self objectPointer at: 1 put: anObject.	self initializePointer.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!objectPointer	object ifNil: [ object := WeakArray new: 1 ].	^ object! !!ExternalArrayProxy methodsFor: 'as yet unclassified'!initializePointer	self handle forArray: self object.! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!fromObject: anObject		^ self new object: anObject; yourself! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!handleFromObject: anObject ifError: aBlock		^ ( self fromObject: anObject ) handle.! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		^ aBlock value! !!ExternalSymbol methodsFor: 'as yet unclassified'!address	handle isNull ifTrue: [ self bind ].	^ handle.! !!ExternalSymbol methodsFor: 'as yet unclassified'!bind	^ library bindSymbol: self.! !!ExternalSymbol methodsFor: 'as yet unclassified'!classFromType: aType	^ Smalltalk at: aType ifAbsent: [ self throwExternalSymbolError ].! !!ExternalSymbol methodsFor: 'as yet unclassified'!library	^ library! !!ExternalSymbol methodsFor: 'as yet unclassified'!library: aLibrary	library := aLibrary! !!ExternalSymbol methodsFor: 'as yet unclassified'!libraryName	^ library name.! !!ExternalSymbol methodsFor: 'as yet unclassified'!name	^name! !!ExternalSymbol methodsFor: 'as yet unclassified'!name: aName	name := aName! !!ExternalSymbol methodsFor: 'as yet unclassified'!name: aName library: aLibrary	self name: aName.	self library: aLibrary! !!ExternalSymbol methodsFor: 'as yet unclassified'!throwExternalSymbolError	^(ExternalSymbolError symbolName: name) signal.! !!ExternalSymbol methodsFor: 'as yet unclassified'!throwNotKnownError	^(ExternalSymbolError symbolName: name) signal.! !!ExecutableFunction methodsFor: 'as yet unclassified'!callingConventionString	self subclassResponsibility.! !!CDeclFunction methodsFor: 'as yet unclassified'!argTypes: anArrayOfTypes	argTypes := anArrayOfTypes.! !!CDeclFunction methodsFor: 'as yet unclassified'!callingConventionString	^ 'cdecl'! !!CDeclFunction methodsFor: 'as yet unclassified'!invoke	^self invokeWithArguments: #()! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1	^self invokeWithArguments: (Array with: arg1)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2	^self invokeWithArguments: (Array with: arg1 with: arg2)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4 with: arg5	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWithArguments: argArray	| argSize argHandleArray returnClass returnHandle |	argSize := argArray size.	argSize = argTypes size ifFalse: [ self throwExternalFunctionError ].	argHandleArray := Array new: argSize.	1 to: argSize do: [ :i |		| argType argClass argHandle arg |		argType := argTypes at: i.		argClass := self classFromType: argType.		arg := argArray at: i.		argHandle := argClass handleFromObject: arg.		argHandleArray at: i put: argHandle.	].	returnHandle := nil.	returnType = #Void ifFalse: [		returnClass := self classFromType: returnType.		returnHandle := returnClass defaultHandlerClass new.	].	handle isNull ifTrue: [ self bind ].	self primInvokeAnswering: returnHandle withArguments: argHandleArray.	returnType = #Void ifTrue: [ ^ nil ].	^ returnClass objectFromHandle: returnHandle.! !!CDeclFunction methodsFor: 'as yet unclassified'!primInvokeAnswering: aReturnValue withArguments: argArray	"Manually invoke the receiver, representing an external function."	<primitive: 204>	^self primitiveFailed! !!CDeclFunction methodsFor: 'as yet unclassified'!returnType: aType	returnType := aType.! !!CDeclFunction methodsFor: 'as yet unclassified'!returnType: aType argTypes: anArrayOfTypes	self returnType: aType.	self argTypes: anArrayOfTypes.! !!ExternalSymbol class methodsFor: 'as yet unclassified'!name: aName library: aLibrary	^self new name: aName library: aLibrary; bind! !!CDeclFunction class methodsFor: 'as yet unclassified'!name: aName library: aLibrary returnType: retType argTypes: argTypesArray	^self new name: aName library: aLibrary;		 returnType: retType argTypes: argTypesArray;		bind! !!ExternalSymbolError methodsFor: 'as yet unclassified'!isResumable	"Determine whether an exception is resumable."	^true! !!ExternalSymbolError methodsFor: 'as yet unclassified'!symbolName	^ symbolName! !!ExternalSymbolError methodsFor: 'as yet unclassified'!symbolName: argument	"Specify the function name that was beiing used."	symbolName := argument! !!ExternalSymbolError class methodsFor: 'as yet unclassified'!symbolName: argument	^self new symbolName: argument; yourself! !!FileDescriptor methodsFor: 'as yet unclassified'!close		self fileDescriptor > 2 ifTrue: [ 		LibC6 default close: self.		self fileDescriptor: -1.	]! !!FileDescriptor methodsFor: 'as yet unclassified'!fileDescriptor	^ SignedInteger objectFromHandle: handle. ! !!FileDescriptor methodsFor: 'as yet unclassified'!fileDescriptor: anInteger	handle := SignedInteger handleFromObject: anInteger. ! !!FileDescriptor methodsFor: 'as yet unclassified'!free		self close.! !!FileDescriptor methodsFor: 'as yet unclassified'!movePosition: offset"relative to actual position"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_CUR' ).	! !!FileDescriptor methodsFor: 'as yet unclassified'!position	^ self movePosition: 0.	! !!FileDescriptor methodsFor: 'as yet unclassified'!position: offset"absolute position"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_SET' ).! !!FileDescriptor methodsFor: 'as yet unclassified'!positionFromEnd: offset"relative to end of file"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_END' ).	! !!FileDescriptor methodsFor: 'as yet unclassified'!read: size	| retValue buffer |	buffer := ExternalBuffer new: size.	retValue := self readBuffer: buffer size: size.	! !!FileDescriptor methodsFor: 'as yet unclassified'!readBuffer: buffer size: size	^ LibC6 default read: self buffer: buffer size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!readString: aString	^ LibC6 default read: self string: aString size: aString size! !!FileDescriptor methodsFor: 'as yet unclassified'!readString: aString size: size	| internalSize |	internalSize := size.	aString size < size ifTrue: [ internalSize := aString size ].	^ LibC6 default read: self string: aString size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!size	| position size |	position := self position.	size := self positionFromEnd: 0.	self position: position.	^ size	! !!FileDescriptor methodsFor: 'as yet unclassified'!writeBuffer: buffer size: size	^ LibC6 default write: self buffer: buffer size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!writeString: aString	^ LibC6 default write: self string: aString size: aString size! !!FileDescriptor methodsFor: 'as yet unclassified'!writeString: aString size: size	| internalSize |	internalSize := size.	aString size < size ifTrue: [ internalSize := aString size ].	^ LibC6 default write: self string: aString size: size! !!FileDescriptor class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalValue! !!FileDescriptor class methodsFor: 'as yet unclassified'!initialize	self initializeStandardDescriptors! !!FileDescriptor class methodsFor: 'as yet unclassified'!initializeStandardDescriptors	StandardDescriptors := Dictionary new.	StandardDescriptors at: #stdout put: (self newFileDescriptor: 0).	StandardDescriptors at: #stdin put: (self newFileDescriptor: 1).	StandardDescriptors at: #stderr put: (self newFileDescriptor: 2).! !!FileDescriptor class methodsFor: 'as yet unclassified'!newFileDescriptor: anInteger	^ self new fileDescriptor: anInteger; yourself.! !!FileDescriptor class methodsFor: 'as yet unclassified'!standardDescriptors	^ StandardDescriptors! !!FileDescriptor class methodsFor: 'as yet unclassified'!stderr	^ StandardDescriptors at: #stderr.! !!FileDescriptor class methodsFor: 'as yet unclassified'!stdin	^ StandardDescriptors at: #stdin.! !!FileDescriptor class methodsFor: 'as yet unclassified'!stdout	^ StandardDescriptors at: #stdout.! !!FileStream methodsFor: 'as yet unclassified'!atEnd	"Answer true if the current position is >= the end of file position.	 1/31/96 sw: subclassResponsibility"	self subclassResponsibility! !!FileStream class methodsFor: 'as yet unclassified'!fileDoesNotExistUserHandling: fullFileName	(GtkMessageDialog question: fullFileName, ' does not exist, create it?') = #yes		ifTrue: [ ^ self new open: fullFileName forWrite: true ].! !!FileStream class methodsFor: 'as yet unclassified'!fileExistsUserHandling: fullFileName	(GtkMessageDialog question: fullFileName, ' exist, overwrite it?') = #yes		ifTrue: [ ^ self new openForOverwrite: fullFileName ].! !!FileStream class methodsFor: 'as yet unclassified'!readOnlyFileDoesNotExistUserHandling: fullFileName	GtkMessageDialog error: fullFileName, ' does not exist'! !!FileDoesNotExistException methodsFor: 'as yet unclassified'!defaultAction	"The default action taken if the exception is signaled."	^self readOnly		ifTrue: [FileStream readOnlyFileDoesNotExistUserHandling: self fileName]		ifFalse: [FileStream fileDoesNotExistUserHandling: self fileName]! !!GIRBuilder methodsFor: 'as yet unclassified'!compiledMethod	| bytecodes |	bytecodes := self bytecodes.	bytecodes ifNil: [ ^ nil ].	^ CompiledMethod new		primitive: 0;		numArgs: self numArgs;		numTemps: self numTemps;		literals: self literals;		relocationInfo: self relocationInfo;		bytecodes: bytecodes;		debugInfo: debugInfo;		source: source;		relocate.! !!GPointer methodsFor: 'as yet unclassified'!initialize	handle := self class defaultHandlerClass new.! !!GPointer class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalAddress! !!GPointer class methodsFor: 'as yet unclassified'!handle: aByteArray	^self basicNew handle: aByteArray; yourself! !!GObject class methodsFor: 'as yet unclassified'!handleFromObject: object	^ object handle.	! !!Gtk methodsFor: 'as yet unclassified'!initialize	self initializeGtkLibrary.	self startMainLoop.! !!Gtk class methodsFor: 'as yet unclassified'!shutDown: quiting	"Quits the Gtk main loop"	Default ifNotNil: [		Default quitMainLoop.		Default close.		Default := nil.	].! !!GtkDemoStockIds methodsFor: 'as yet unclassified'!initialize	| model tree |	model := GtkListStore new: {String. String. String. String}.	GtkStockItem allStocks do: [ :ea |		ea ifNotNil: [			model append: {				ea stockId asGtkStockId.				ea stockId.				ea label.				Gtk acceleratorName: ea keyval asCharacter modifier: ea modifier}]].	tree := GtkTreeView model: model.	self createFirstColumn: tree.	tree appendColumns: {		GtkTreeViewColumn title: 'Label' text: 2.		GtkTreeViewColumn title: 'Accel' text: 3.		GtkTreeViewColumn title: 'ID' text: 0}.	tree selection when: #changed send: #onItemChanged: to: self withArgumentsFirst: {tree}.			self container: (GtkHBox spacing: 5).	self container		packStart: (GtkScrolledWindow withChild: tree);		packEnd: self createInfoFrame expand: false fill: false! !!GtkDemoStockIds methodsFor: 'as yet unclassified'!onItemChanged: aTreeView	aTreeView selectedRow in: [:row |		idLabel label: row first.		nameLabel label: '#', row second.		accelLabel label: row third.		iconImage stock: row second iconSize: #dialog]! !!InMidstOfFileinNotification methodsFor: 'as yet unclassified'!defaultAction	^ self resume: false! !!LibC methodsFor: 'as yet unclassified'!closeLibrary	cLibrary closeLibrary.	cLibrary := nil.! !!LibC methodsFor: 'as yet unclassified'!initializeCLibrary	cLibrary := ExternalLibrary new.	cLibrary name: 'libc.so.6'.	cLibrary openLibrary.! !!LibC class methodsFor: 'as yet unclassified'!shutDown: quiting	"Quits the Gtk main loop"	self default closeLibrary.	Default := nil.! !!LibC6 methodsFor: 'as yet unclassified'!close: fd	| retValue |	retValue := ( self cDeclFunctionNamed: #close ) invokeWith: fd.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #close ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!errno	^ (self libraryDataNamed: #errno) value.	! !!LibC6 methodsFor: 'as yet unclassified'!errno: errno	(self libraryDataNamed: #errno) value: errno.	! !!LibC6 methodsFor: 'as yet unclassified'!free: anExternalBuffer	( self cDeclFunctionNamed: #free ) invokeWith: anExternalBuffer.	! !!LibC6 methodsFor: 'as yet unclassified'!getCurrentDirName	| retValue |	[ retValue := ( self cDeclFunctionNamed: 'get_current_dir_name' asSymbol ) invoke ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: 'get_current_dir_name' asSymbol ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!getEnv: envVariable	^ ( self cDeclFunctionNamed: #getenv ) invokeWith: envVariable.! !!LibC6 methodsFor: 'as yet unclassified'!getpid	^ (self cDeclFunctionNamed: #getpid) invoke.	! !!LibC6 methodsFor: 'as yet unclassified'!initialize	super initialize.	self initializeUniStd.	self initializeStdLib.	self initializeString.	self initializeFCntl.	self initializeStdIO.	self initializeErrNO.! !!LibC6 methodsFor: 'as yet unclassified'!initializeErrNO	self initializeLibraryDataNamed: #errno type: #SignedInteger.! !!LibC6 methodsFor: 'as yet unclassified'!initializeFCntl	self initializeCDeclFunctionNamed: #open returnType: #FileDescriptor argTypes: #( AsciiZ SignedInteger UnsignedInteger ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeStdIO	self initializeCDeclFunctionNamed: #printf  returnType: #SignedInteger argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: #perror  returnType: #Void argTypes: #( AsciiZ  ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeStdLib	self initializeCDeclFunctionNamed: #malloc  returnType: #ExternalBuffer argTypes: #( UnsignedInteger  ).	self initializeCDeclFunctionNamed: #free  returnType: #Void argTypes: #( ExternalBuffer  ).	self initializeCDeclFunctionNamed: #getenv  returnType: #AsciiZ argTypes: #( AsciiZ ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeString	self initializeCDeclFunctionNamed: #strlen returnType: #UnsignedInteger argTypes: #( AsciiZ ).	self initializeCDeclFunctionNamed: #strcat returnType: #AsciiZ argTypes: #( AsciiZ AsciiZ ).	self initializeCDeclFunctionNamed: #strcpy returnType: #AsciiZ argTypes: #( AsciiZ AsciiZ ).	self initializeCDeclFunctionNamed: #strerror returnType: #ReadOnlyAsciiZ argTypes: #( SignedInteger ).	self initializeCDeclFunctionNamed: #memset returnType: #ExternalBuffer argTypes: #( ExternalBuffer SignedInteger  UnsignedInteger ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeUniStd	self initializeCDeclFunctionNamed: #getpid  returnType: #UnsignedInteger argTypes: #().	self initializeCDeclFunctionNamed: 'get_current_dir_name' asSymbol  returnType: #AsciiZ argTypes: #().	self initializeCDeclFunctionNamed: #close  returnType: #SignedInteger argTypes: #( FileDescriptor ).	self initializeCDeclFunctionNamed: #lseek  returnType: #UnsignedInteger argTypes: #( FileDescriptor UnsignedInteger SignedInteger ).	self initializeCDeclFunctionNamed: #read  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalBuffer UnsignedInteger ).	self initializeCDeclFunctionNamed: #write  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalBuffer UnsignedInteger )."Redefinition of read for Strings"	symbolCache at: #readString put: (CDeclFunction name: #read library: self  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalArrayProxy UnsignedInteger ) )."Redefinition of write for Strings"	symbolCache at: #writeString put: (CDeclFunction name: #write library: self  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalArrayProxy UnsignedInteger ) ).! !!LibC6 methodsFor: 'as yet unclassified'!lseek: fileDescriptor offset: offset whence: whence	| returnValue |	returnValue := (self cDeclFunctionNamed: #lseek) invokeWith: fileDescriptor with: offset with: whence.	returnValue < 0 ifTrue: [		self throwErrorForExternalFunctionNamed: #lseek.		^ nil.	].	^ returnValue.	! !!LibC6 methodsFor: 'as yet unclassified'!malloc: size	| retValue |	[ retValue := ( self cDeclFunctionNamed: #malloc ) invokeWith: size ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: #malloc withMessage: 'can not allocate memory' ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!memSet: buffer constant: c count: n	^ (self cDeclFunctionNamed: #memset) invokeWith: buffer with: c with: n.	! !!LibC6 methodsFor: 'as yet unclassified'!open: path flags: flags	^ self open: path flags: flags mode: 8r644	! !!LibC6 methodsFor: 'as yet unclassified'!open: path flags: flags mode: mode	| fileDescriptor |	fileDescriptor := (self cDeclFunctionNamed: #open) invokeWith: path with: flags with: mode.	fileDescriptor fileDescriptor < 0 ifTrue: [		self throwErrorForExternalFunctionNamed: #open.		^ nil.	].	^ fileDescriptor.	! !!LibC6 methodsFor: 'as yet unclassified'!perror: aString	( self cDeclFunctionNamed: #perror ) invokeWith: aString.	! !!LibC6 methodsFor: 'as yet unclassified'!printf: aString	^ ( self cDeclFunctionNamed: #printf ) invokeWith: aString.	! !!LibC6 methodsFor: 'as yet unclassified'!read: fd buffer: buffer size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #read ) invokeWith: fd with: buffer with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #read ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!read: fd string: aString size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #readString ) invokeWith: fd with: aString with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #readString ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!strCat: destString with: sourceString	^ ( self cDeclFunctionNamed: #strcat ) invokeWith: destString with: sourceString.	! !!LibC6 methodsFor: 'as yet unclassified'!strCpy: destString with: sourceString	^ ( self cDeclFunctionNamed: #strcpy ) invokeWith: destString with: sourceString.	! !!LibC6 methodsFor: 'as yet unclassified'!strError: errno	| retValue |	[ retValue := ( self cDeclFunctionNamed: #strerror ) invokeWith: errno ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: #strerror ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!strLen: string	^ ( self cDeclFunctionNamed: #strlen ) invokeWith: string	! !!LibC6 methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName	^ self throwErrorForExternalFunctionNamed: functionName withMessage: (self strError: self errno).	! !!LibC6 methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName withMessage: aString	| error |	error := ExternalFunctionError functionName: functionName.	error messageText: aString.	^ error signal.	! !!LibC6 methodsFor: 'as yet unclassified'!valueForLSeekDirectiveNamed: aString	^ LSeekDirectives at: aString asSymbol.	! !!LibC6 methodsFor: 'as yet unclassified'!valueForOpenFlagNamed: aString	^ OpenFlags at: aString asSymbol.	! !!LibC6 methodsFor: 'as yet unclassified'!write: fd buffer: buffer size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #write ) invokeWith: fd with: buffer with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #write ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!write: fd string: aString size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #writeString ) invokeWith: fd with: aString with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #writeString ].	^ retValue.	! !!LibC6 class methodsFor: 'as yet unclassified'!initialize	self initializeOpenFlags.	self initializeLSeekDirectives.! !!LibC6 class methodsFor: 'as yet unclassified'!initializeLSeekDirectives	| lSeekDirectives |		lSeekDirectives := Dictionary new.	lSeekDirectives at: 'SEEK_SET' put: 0.	lSeekDirectives at: 'SEEK_CUR' put: 1.	lSeekDirectives at: 'SEEK_END' put: 2.	LSeekDirectives := lSeekDirectives! !!LibC6 class methodsFor: 'as yet unclassified'!initializeOpenFlags	| flagArray openFlags |		flagArray := #( 		('O_RDONLY'		0)		('O_WRONLY'		8r1)		('O_RDWR'		8r2)		('O_CREAT'		8r100)			('O_EXCL'			8r200)			('O_NOCTTY'		8r400)			('O_TRUNC'		8r1000)			('O_APPEND'		8r2000)		('O_NONBLOCK'	8r4000)		('O_SYNC'		8r10000)		('O_ASYNC'		8r20000)	).	openFlags := Dictionary new.	flagArray do: [ :i |		openFlags at: i first asSymbol put: i second	].	OpenFlags := openFlags! !!LibC6 class methodsFor: 'as yet unclassified'!moduleName	^ 'libc.so.6'.! !!LibExample methodsFor: 'as yet unclassified'!getpid	^ GETPID invoke! !!LibExample class methodsFor: 'as yet unclassified'!getpid	^ GETPID! !!LibExample class methodsFor: 'as yet unclassified'!initialize	GETPID := CDeclFunction name: 'getpid' libraryNamed: 'libc.so.6' returnType: #UnsignedInteger argTypes: #().! !!LibReadLine methodsFor: 'as yet unclassified'!addHistory: aString	( self cDeclFunctionNamed: 'add_history' asSymbol ) invokeWith: aString.! !!LibReadLine methodsFor: 'as yet unclassified'!initialize	super initialize.	self initializeCDeclFunctionNamed: #readline  returnType: #AsciiZ argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'add_history' asSymbol returnType: #Void argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'read_history' asSymbol returnType: #SignedInteger argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'write_history' asSymbol returnType: #SignedInteger argTypes: #( AsciiZ  ).! !!LibReadLine methodsFor: 'as yet unclassified'!readHistory: aFileName	| errno |	errno := ( self cDeclFunctionNamed: 'read_history' asSymbol ) invokeWith: aFileName.	errno = 0 ifFalse: [ self throwErrorForExternalFunctionNamed: 'read_history' asSymbol errno: errno ].	^ errno.! !!LibReadLine methodsFor: 'as yet unclassified'!readline: prompt	^ ( self cDeclFunctionNamed: #readline ) invokeWith: prompt.! !!LibReadLine methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName errno: errno	| error |	error := ExternalFunctionError functionName: functionName.	error messageText: (LibC6 default strError: errno).	^ error signal.! !!LibReadLine methodsFor: 'as yet unclassified'!writeHistory: aFileName	| errno |	errno := ( self cDeclFunctionNamed: 'write_history' asSymbol ) invokeWith: aFileName.	errno = 0 ifFalse: [ self throwErrorForExternalFunctionNamed: 'write_history' asSymbol errno: errno ].	^ errno.! !!LibReadLine class methodsFor: 'as yet unclassified'!moduleName	^ 'libreadline.so.5'.! !!LibraryData methodsFor: 'as yet unclassified'!primitiveGetValue: valueHandle	<primitive: 216>	^self primitiveFailed! !!LibraryData methodsFor: 'as yet unclassified'!primitiveSetValue: valueHandle	<primitive: 217>	^self primitiveFailed! !!LibraryData methodsFor: 'as yet unclassified'!type	^ type.! !!LibraryData methodsFor: 'as yet unclassified'!type: aType	type := aType.! !!LibraryData methodsFor: 'as yet unclassified'!value	| valueClass valueHandle |	valueClass := self classFromType: type.	valueHandle := valueClass defaultHandlerClass new.	handle isNull ifTrue: [ self bind ].	self primitiveGetValue: valueHandle.	^ valueClass objectFromHandle: valueHandle.! !!LibraryData methodsFor: 'as yet unclassified'!value: aValue	| argHandle argClass |	argClass := self classFromType: type.	argHandle := argClass handleFromObject: aValue.	handle isNull ifTrue: [ self bind ].	self primitiveSetValue: argHandle! !!LibraryData class methodsFor: 'as yet unclassified'!name: aName library: aLibrary type: type	^self new name: aName library: aLibrary;		type: type;		bind! !!Metaclass methodsFor: 'as yet unclassified'!addObsoleteSubclass: aClass	"Do nothing."! !!Metaclass methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return true if it is safe to zap the method dictionary on #obsolete"	thisClass == nil		ifTrue:[^true]		ifFalse:[^thisClass canZapMethodDictionary]! !!Metaclass methodsFor: 'as yet unclassified'!isSystemDefined	"Answer false if I am a UniClass (an instance-specific lightweight class)"	^ true! !!NativeFunction methodsFor: 'as yet unclassified'!callingConventionString	^ 'native'! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver	^self invokeReceiver: receiver withArguments: #()! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1	^self invokeReceiver: receiver withArguments: (Array with: arg1)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4 with: arg5	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver withArguments: argArray	handle isNull ifTrue: [ self bind ].	^ self primInvokeReceiver: receiver withArguments: argArray.! !!NativeFunction methodsFor: 'as yet unclassified'!primInvokeReceiver: receiver withArguments: argArray	"Manually invoke the receiver, representing an native function."	<primitive: 197>	^self primitiveFailed! !!ObjectTest methodsFor: 'as yet unclassified'!testBecome	"self debug: #testBecome"	"this test should that all the variables pointing to an object are pointing now to another one, and all      object pointing to the other are pointing to the object"	| pt1 pt2 pt3 |	pt1 := 0@0.	pt2 := pt1.	pt3 := 100@100.	pt1 become: pt3.	self assert: pt2 = (100@100).	self assert: pt3 = (0@0).	self assert: pt1 = (100@100).! !!ObjectTest methodsFor: 'as yet unclassified'!testBecomeForward	"self debug: #testBecomeForward"	"this test should that all the variables pointing to an object are pointing now to another one.	Not that this inverse is not true. This kind of become is called oneWayBecome in VW"	| pt1 pt2 pt3 |	pt1 := 0@0.	pt2 := pt1.	pt3 := 100@100.	pt1 becomeForward: pt3.	self assert: pt2 = (100@100).	self assert: pt3 == pt2.	self assert: pt1 = (100@100)! !!PrimitiveType class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalValue! !!PrimitiveType class methodsFor: 'as yet unclassified'!handleFromObject: anObject	^ self handleFromObject: anObject ifError: [ self throwTypeConvertionError ]! !!PrimitiveType class methodsFor: 'as yet unclassified'!handleFromObject: object ifError: aBlock	self subclassResponsibility.! !!PrimitiveType class methodsFor: 'as yet unclassified'!objectFromHandle: handle	^ self objectFromHandle: handle ifError: [  self throwTypeConvertionError ]! !!PrimitiveType class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock	self subclassResponsibility.! !!PrimitiveType class methodsFor: 'as yet unclassified'!throwTypeConvertionError	^ TypeConvertionError new signal! !!IntegerType class methodsFor: 'as yet unclassified'!handleFromObject: anInteger ifError: aBlock	| handle |		(self checkType: anInteger) ifFalse: [ ^ aBlock value ].	handle := ExternalValue new.	self store: anInteger in: handle.	^ handle.	! !!IntegerType class methodsFor: 'as yet unclassified'!isBigEndian	^  false! !!IntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	self subclassResponsibility.! !!IntegerType class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: errorBlock	| value |		value := self loadFrom: handle.	(value > self max ) ifTrue: [ ^ errorBlock value ].	^ value.! !!Process methodsFor: 'as yet unclassified'!primitiveBeInitialProcess	<primitive: 196>	self primitiveFailed! !!ProcessorScheduler methodsFor: 'as yet unclassified'!activeProcess	^ self primActiveProcess! !!ProcessorScheduler methodsFor: 'as yet unclassified'!primActiveProcess	<primitive: 195>	self primitiveFail.! !!ProcessorScheduler methodsFor: 'as yet unclassified'!startUp	| firstProcess |"	(processList isNil or: [ processList isEmpty not ]) ifTrue: [ self initialize ]."	self initialize.	firstProcess := Process new.	firstProcess name: 'Init'.	firstProcess priority: self userSchedulingPriority.	firstProcess state: #running."	firstProcess threadData: self activeThreadData."	firstProcess primitiveBeInitialProcess.! !!ReadOnlyAsciiZ methodsFor: 'as yet unclassified'!asString	^ handle toString.! !!ReadOnlyAsciiZ class methodsFor: 'as yet unclassified'!handleFromObject: aByteArray ifError: aBlock	"Can not be used as arguments"	aBlock value.! !!ReadOnlyAsciiZ class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; asString! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!addressRelativeTo: bytecodes	| functionAddress bytecodesAddress |	functionAddress := self function address asInteger.	bytecodesAddress := (ExternalAddress forArray: bytecodes ) asInteger.	^ functionAddress - bytecodesAddress - offset - 4! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!function	^ self library functionNamed: functionName.! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!functionName	^ functionName! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!functionName: aSymbol	^ functionName := aSymbol! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!library	^ Executable default! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!patch: bytecodes	self patch: bytecodes with: (self addressRelativeTo: bytecodes).! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!patch: bytecodes with: value	bytecodes longAt: (offset + 1) put: value bigEndian: false.! !!FunctionRelocation methodsFor: 'as yet unclassified'!addressRelativeTo: bytecodes	^ self primAddressRelativeTo: bytecodes! !!FunctionRelocation methodsFor: 'as yet unclassified'!primAddressRelativeTo: bytecodes	<primitive: 155>	self primitiveFail.! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!defaultLibraryClass	^ NativeLibrary! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!library 		^ self defaultLibraryClass named: libraryName! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!libraryName	^ libraryName! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!libraryName: aSymbol	^ libraryName := aSymbol! !!ExternalFunctionRelocation methodsFor: 'as yet unclassified'!defaultLibraryClass	^ ExternalLibrary2! !!SequenceableCollection methodsFor: 'as yet unclassified'!asTraitComposition	"For convenience the composition {T1. T2 ...} is the same as T1 + T2 + ..."	^self isEmpty		ifFalse: [			self size = 1				ifTrue: [self first asTraitComposition]				ifFalse: [					self copyWithoutFirst 						inject: self first						into: [:left :right | left + right]]]		ifTrue: [			TraitComposition new]! !!Array methodsFor: 'as yet unclassified'!elementsExchangeIdentityWith: otherArray	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsExchangeIdentityWith: otherArray.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!elementsForwardIdentityTo: otherArray	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsForwardIdentityTo: otherArray.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!elementsForwardIdentityTo: otherArray copyHash: copyHash	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsForwardIdentityTo: otherArray copyHash: copyHash.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!primElementsExchangeIdentityWith: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  At the same time, all pointers to the elements of otherArray are replaced by pointers to the corresponding elements of this array.  The identityHashes remain with the pointers rather than with the objects so that objects in hashed structures should still be properly indexed after the mutation."	<primitive: 128>	otherArray class == Array ifFalse: [^ self error: 'arg must be array'].	self size = otherArray size ifFalse: [^ self error: 'arrays must be same size'].	(self anySatisfy: [:obj | obj class == SmallInteger]) ifTrue: [^ self error: 'can''t become SmallIntegers'].	(otherArray anySatisfy: [:obj | obj class == SmallInteger]) ifTrue: [^ self error: 'can''t become SmallIntegers'].	"Must have failed because not enough space in forwarding table (see ObjectMemory-prepareForwardingTableForBecoming:with:twoWay:).  Do GC and try again only once"	(Smalltalk bytesLeft: true) = Smalltalk primitiveGarbageCollect		ifTrue: [^ self primitiveFailed].	^ self elementsExchangeIdentityWith: otherArray! !!Array methodsFor: 'as yet unclassified'!primElementsForwardIdentityTo: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  The identityHashes remain with the pointers rather than with the objects so that the objects in this array should still be properly indexed in any existing hashed structures after the mutation."	<primitive: 72>	self primitiveFailed! !!Array methodsFor: 'as yet unclassified'!primElementsForwardIdentityTo: otherArray copyHash: copyHash	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  The identityHashes remain with the pointers rather than with the objects so that the objects in this array should still be properly indexed in any existing hashed structures after the mutation."	<primitive: 249>	self primitiveFailed! !!ExternalValue methodsFor: 'as yet unclassified'!beNull	"Make the receiver a NULL pointer"	self atAllPut: 0.! !!ExternalValue methodsFor: 'as yet unclassified'!isNull	^(self basicAt: 1) = 0	and: (self basicAt: 2) = 0	and: (self basicAt: 3) = 0	and: (self basicAt: 4) = 0	! !!ExternalValue class methodsFor: 'as yet unclassified'!initialize	Smalltalk addToStartUpList: self.! !!ExternalValue class methodsFor: 'as yet unclassified'!new	"External addresses are always 4 bytes long"	^super new: 4! !!ExternalValue class methodsFor: 'as yet unclassified'!new: n	"You better don't try this..."	^self shouldNotImplement! !!ExternalValue class methodsFor: 'as yet unclassified'!startUp: resuming	resuming ifTrue: [		self allInstancesDo: [ :addr |			addr beNull		]	].! !!SharedPool class methodsFor: 'as yet unclassified'!bindingOf: varName	"Answer the binding of some variable resolved in the scope of the receiver"	| aSymbol binding |	aSymbol := varName asSymbol.	"First look in classVar dictionary."	binding := self classPool bindingOf: aSymbol.	binding ifNotNil:[^binding].	"Next look in shared pools."	self sharedPools do:[:pool | 		binding := pool bindingOf: aSymbol.		binding ifNotNil:[^binding].	].	"subclassing and environment are not preserved"	^nil! !!SharedPool class methodsFor: 'as yet unclassified'!bindingsDo: aBlock	^self classPool bindingsDo: aBlock! !!SharedPool class methodsFor: 'as yet unclassified'!classBindingOf: varName	"For initialization messages grant the regular scope"	^super bindingOf: varName! !!SharedPool class methodsFor: 'as yet unclassified'!hasBindingThatBeginsWith: aString	"Answer true if the receiver has a binding that begins with aString, false otherwise"	"First look in classVar dictionary."	(self classPool hasBindingThatBeginsWith: aString) ifTrue:[^true].	"Next look in shared pools."	self sharedPools do:[:pool | 		(pool hasBindingThatBeginsWith: aString) ifTrue: [^true]].	^false! !!SharedPool class methodsFor: 'as yet unclassified'!includesKey: aName	"does this pool include aName"	^(self bindingOf: aName) notNil! !!SharedPool class methodsFor: 'as yet unclassified'!keysDo: aBlock"A hopefully temporary fix for an issue arising from miss-spelled variable names in code being compiled. The correction code (see Class>possibleVariablesFor:continuedFrom: assumes that sharedPools are Dictionaries. The proper fix would involve making sure all pools are actually subclasses of SharedPool, which they are not currently."	self bindingsDo:[:b|		aBlock value: b key]! !!Shell methodsFor: 'as yet unclassified'!display: string	| buffer |		buffer := AsciiZ fromString: string.	^ FileDescriptor stdout writeBuffer: buffer size: buffer size.! !!Shell methodsFor: 'as yet unclassified'!input: prompt	^ LibReadLine default readline: prompt! !!Shell methodsFor: 'as yet unclassified'!main	| line value failed anotherLine buffer |	LibReadLine default readHistory: self historyFileName.	[		anotherLine := false.		buffer := ''.		[ 	| prompt |			prompt := anotherLine ifTrue: [ '' ] ifFalse: [ '> ' ].			line _ self input: prompt.			line isEmpty				ifTrue: [ true ] 				ifFalse: [					(line last = $\)						ifTrue: [							anotherLine := true.							line at: line size put: Character lf.						]						ifFalse: [ anotherLine := false ].					buffer := buffer, line.					anotherLine				]		] whileTrue. 		buffer = 'quit' or: [ buffer = 'save' ]	] whileFalse: [		self addToHistory: buffer.		failed _ false.		value _ Compiler new evaluate: buffer in: nil to: nil notifying: self ifFail: [ failed _ true].		failed ifFalse: [ self display: (value printString); lf ]	].	LibReadLine default writeHistory: self historyFileName.	buffer = 'save' ifTrue: [ Smalltalk snapshotAndQuit ].	^value.! !!SignedIntegerType class methodsFor: 'as yet unclassified'!checkType: value	^ value isInteger and: [ value >= self min and: [ value <= self max ] ]! !!SignedIntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	^ handle longAt: 1 bigEndian: self isBigEndian.! !!SignedIntegerType class methodsFor: 'as yet unclassified'!store: anInteger in: handle	handle longAt: 1 put: anInteger bigEndian: self isBigEndian.! !!SignedByte class methodsFor: 'as yet unclassified'!max			^ 127! !!SignedByte class methodsFor: 'as yet unclassified'!min			^ -128! !!SignedInteger class methodsFor: 'as yet unclassified'!max			^ 2147483647! !!SignedInteger class methodsFor: 'as yet unclassified'!min			^ -2147483648! !!SignedShortInteger class methodsFor: 'as yet unclassified'!max			^ 32767! !!SignedShortInteger class methodsFor: 'as yet unclassified'!min			^ -32768! !!SourceReference methodsFor: 'as yet unclassified'!sourceFrom: aString	self hasEmptySourceReference ifTrue: [ ^ '' ].	^ aString copyFrom: sourceStart to: sourceStop! !!StandardFileStream class methodsFor: 'as yet unclassified'!retryWithGC: execBlock until: testBlock forFileNamed: fullName	"Re-implemented to only force GC if a file with the given name exists"	| blockValue foundIt |	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	"See if we have a file with the given name"	foundIt := self registry keys "hold on strongly for now" 		anySatisfy:[:file| file name sameAs: fullName].	foundIt ifFalse:[^blockValue].	Smalltalk garbageCollectMost.	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollect.	^execBlock value.! !!SystemDictionary methodsFor: 'as yet unclassified'!forgetClass: aClass logged: aBool 	"Delete the class, aClass, from the system.	Note that this doesn't do everything required to dispose of a class - to do that use Class>>removeFromSystem."	aBool ifTrue: [SystemChangeNotifier uniqueInstance classRemoved: aClass fromCategory: aClass category].			SystemOrganization removeElement: aClass name.	self removeFromStartUpList: aClass.	self removeFromShutDownList: aClass.	self removeKey: aClass name ifAbsent: [].	self flushClassNameCache! !!SystemDictionary methodsFor: 'as yet unclassified'!removeClassNamed: aName	"Invoked from fileouts:  if there is currently a class in the system named aName, then remove it.  If anything untoward happens, report it in the Transcript.  "	| oldClass |	(oldClass _ self at: aName asSymbol ifAbsent: [nil]) == nil		ifTrue:			[Transcript cr; show: 'Removal of class named ', aName, ' ignored because ', aName, ' does not exist.'.			^ self].	oldClass removeFromSystem! !!SystemDictionary methodsFor: 'as yet unclassified'!startUp	Processor startUp.	ProcessorScheduler startUp.	self processStartUpList: true.	self installLowSpaceWatcher.! !!SystemTracer methodsFor: 'as yet unclassified'!getAligned: size	^ (( size + 3 ) bitShift: -2) bitShift: 2.! !!TraitBehavior methodsFor: 'as yet unclassified'!addUser: aClassOrTrait	users add: aClassOrTrait! !!TraitBehavior methodsFor: 'as yet unclassified'!classesComposedWithMe	^users gather: [:u | u classesComposedWithMe]! !!TraitBehavior methodsFor: 'as yet unclassified'!initialize	self methodDict: Dictionary new.	self traitComposition: nil.	users _ IdentitySet new.! !!TraitBehavior methodsFor: 'as yet unclassified'!removeUser: aClassOrTrait	users remove: aClassOrTrait ifAbsent: []! !!TraitBehavior methodsFor: 'as yet unclassified'!users	^users! !!TraitComposition methodsFor: 'as yet unclassified'!assertValidUser: aBehavior	"Assert that this trait composition set for aBehavior	does not introduce a cycle."		(self allTraits includes: aBehavior) ifTrue: [		TraitCompositionException signal: 'Cycle in compositions:  The composition (in)directly includes this trait!!']! !!TraitComposition methodsFor: 'as yet unclassified'!methodDescriptionsForSelector: aSymbol	"Return a collection of TraitMethodDescriptions for aSymbol and all the 	aliases of aSymbol."	| selectors collection |	selectors _ IdentitySet with: aSymbol.	self transformations do: [:each |		selectors addAll: (each aliasesForSelector: aSymbol)].	collection _ OrderedCollection new: selectors size.	selectors do: [:each |		collection add: (self methodDescriptionForSelector: each)].	^collection! !!TraitDescription methodsFor: 'as yet unclassified'!trait	"for compatibility with TraitTransformations"	^ self! !!TraitDescription methodsFor: 'as yet unclassified'!updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil	| currentCategory effectiveCategory sel changedCategories composition |	changedCategories _ IdentitySet new.	composition := self hasTraitComposition		ifTrue: [self traitComposition]		ifFalse: [TraitComposition new].	(composition methodDescriptionsForSelector: aSymbol) do: [:each |		sel _ each selector.		(self includesLocalSelector: sel) ifFalse: [			currentCategory _ self organization categoryOfElement: sel.			effectiveCategory _ each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.			effectiveCategory isNil ifTrue: [				currentCategory ifNotNil: [changedCategories add: currentCategory].				self organization removeElement: sel.			] ifFalse: [				((currentCategory isNil or: [currentCategory == ClassOrganizer ambiguous or: [currentCategory == oldCategoryOrNil]]) and: [currentCategory ~~ effectiveCategory]) ifTrue: [					currentCategory ifNotNil: [changedCategories add: currentCategory].					self organization 						classify: sel 						under: effectiveCategory						suppressIfDefault: false]]]].	^ changedCategories! !!TraitDescription methodsFor: 'as yet unclassified'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	(self includesSelector: aSelector)		ifTrue: [^ self organization categoryOfElement: aSelector]		ifFalse: [^nil]! !!Trait methodsFor: 'as yet unclassified'!initialize	super initialize.	classTrait _ ClassTrait for: self! !!TranscriptCodeView class methodsFor: 'as yet unclassified'!initialize	Smalltalk addToStartUpList: self.! !!TranscriptCodeView class methodsFor: 'as yet unclassified'!startUp: resuming	resuming ifTrue: [		TranscriptCodeBuffer := nil.	].! !!TranscriptStream methodsFor: 'as yet unclassified'!open	TranscriptCodeEditor open.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!atEnd	position ifNil: [ ^ nil ].	^ position >= readLimit! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!close	"Close this file."	fileID ifNotNil: [		fileID close.		fileID := nil.		position := nil.	].! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!open: fileName flags: flags	[ fileID := LibC6 default open: fileName flags: flags ]		on: ExternalFunctionError		do: [ ^ nil ].	name := fileName.	readLimit := fileID size.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!open: fileName forWrite: writeMode 	| flags |	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	flags := writeMode 		ifTrue: [ LibC6 default valueForOpenFlagNamed: 'O_RDWR' ]		ifFalse: [ LibC6 default valueForOpenFlagNamed: 'O_RDONLY' ].	rwmode := writeMode.	^ self open: fileName flags: flags.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!openForOverwrite: fileName	| flags |	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	flags := ((LibC6 default valueForOpenFlagNamed: 'O_RDWR') 			bitOr: ( LibC6 default valueForOpenFlagNamed: 'O_TRUNC' )) 			bitOr: ( LibC6 default valueForOpenFlagNamed: 'O_CREAT' ).	rwmode := true.	^ self open: fileName flags: flags.! !!BufferedFileStream methodsFor: 'as yet unclassified'!close	"Close this file."	self flush.	^ super close.! !!BufferedFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	self subclassResponsibility! !!BufferedFileStream methodsFor: 'as yet unclassified'!defaultBufferSize	^ DefaultBufferSize.! !!BufferedFileStream methodsFor: 'as yet unclassified'!flush	| bufferPosition bufferSize |	fileID ifNil: [ ^ nil ].	rwmode ifFalse: [ ^ nil ].	bufferPosition := position truncateTo: (collection size).	bufferSize := collection size min: ( readLimit - bufferPosition).	fileID position: bufferPosition.	bufferSize > 0 ifTrue: [ fileID writeString: collection size: bufferSize ].	 ! !!BufferedFileStream methodsFor: 'as yet unclassified'!initializeBuffer	| bufferSize |	position := 0.	collection := self defaultBufferClass new: self defaultBufferSize.	bufferSize := collection size min: readLimit.	bufferSize > 0 ifTrue: [ fileID readString: collection size: bufferSize ]. ! !!BufferedFileStream methodsFor: 'as yet unclassified'!next	| byte |	byte := self peek.	self position: position + 1.	^ byte! !!BufferedFileStream methodsFor: 'as yet unclassified'!nextPut: char	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	position ifNil: [ self position: 0 ].	collection at: (position \\ (collection size)) + 1put: char.	self position: position + 1.	^ char! !!BufferedFileStream methodsFor: 'as yet unclassified'!open: fileName flags: flags	(super open: fileName flags: flags) ifNotNil: [ self initializeBuffer ].! !!BufferedFileStream methodsFor: 'as yet unclassified'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	position ifNil: [ self position: 0 ].	self atEnd ifTrue: [^ nil ].	^ collection at: (position \\ (collection size)) + 1.! !!BufferedFileStream methodsFor: 'as yet unclassified'!position: newPosition	| oldBufferPosition newBufferPosition bufferSize |	fileID ifNil: [ ^nil ].	newPosition < 0 ifTrue: [ ^nil ]."	((newPosition > readLimit) and: [ rwmode not ])  ifTrue: [ ^nil ]."	newPosition > readLimit ifTrue: [		rwmode ifTrue: [ readLimit := newPosition ] ifFalse: [ ^nil ]	].	oldBufferPosition := position truncateTo: (collection size).	newBufferPosition := newPosition truncateTo: (collection size).	newBufferPosition = oldBufferPosition ifFalse: [ 		self flush.		fileID position: newBufferPosition.		bufferSize := collection size min: ( readLimit - newBufferPosition).		collection := self defaultBufferClass new: self defaultBufferSize.		bufferSize > 0 ifTrue: [ fileID readString: collection size: bufferSize ].	].	position := newPosition."	rwmode ifTrue: [ readLimit := newPosition ]."	^ position.! !!BinaryFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	^ ByteArray! !!TextFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	^ String! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!concreteStream	"Who should we really direct class queries to?  "	^ UnbufferedFileStream.! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!fileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new open: fileName forWrite: true! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!forceNewFileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new openForOverwrite: fileName! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!readOnlyFileNamed: fileName 	"Open an existing file with the given name for reading."	| f |	f := self new open: fileName forWrite: false.	^ f isNil		ifFalse: [f]		ifTrue: ["File does not exist..."			((FileDoesNotExistException fileName: fileName) readOnly: true) signal].	"StandardFileStream readOnlyFileNamed: 'kjsd.txt' "! !!BufferedFileStream class methodsFor: 'as yet unclassified'!initialize	self initializeDefaultBufferSize.! !!BufferedFileStream class methodsFor: 'as yet unclassified'!initializeDefaultBufferSize	DefaultBufferSize := 4096.! !!BufferedFileStream class methodsFor: 'as yet unclassified'!new	^ TextFileStream new.! !!UnhandledError methodsFor: 'as yet unclassified'!devDefaultAction	"The current computation is terminated. The cause of the error should be logged or reported to the user. If the program is operating in an interactive debugging environment the computation should be suspended and the debugger activated."	(GtkMessageDialog question: exception messageText, ', debug it?' ) = #yes		ifTrue: [ ^Processor activeProcess debugError: exception ]."	^ Processor activeProcess terminate."! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!checkType: value	^ value isInteger and: [ value >= 0 and: [ value <= self max ] ]! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	^ handle unsignedLongAt: 1 bigEndian: self isBigEndian.! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!min	^ 0! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!store: anInteger in: handle	handle unsignedLongAt: 1 put: anInteger bigEndian: self isBigEndian.! !!UnsignedByte class methodsFor: 'as yet unclassified'!max			^ 255! !!UnsignedInteger class methodsFor: 'as yet unclassified'!max			^ 4294967295! !!UnsignedShortInteger class methodsFor: 'as yet unclassified'!max			^ 65535! !!Workspace methodsFor: 'as yet unclassified'!buildMenuBar	| menu  edit  |	menu := GtkMenuBar new.	edit := GtkMenu new.	menu		append: AppLauncher fileMenu;		append: (edit createMenuItem: '_Edit');		append: workspaceView menu;		append: AppLauncher toolsMenu;		append: AppLauncher helpMenu.					^ menu.! !!Workspace methodsFor: 'as yet unclassified'!buildToolBar	| toolBar |	^ GtkToolbar new		appendItems: workspaceView toolBar;		yourself! !!Workspace methodsFor: 'as yet unclassified'!defaultCodeViewClass	^ WorkspaceView! !!Workspace methodsFor: 'as yet unclassified'!initialize	workspaceView := self defaultCodeViewClass new.	self container: (GtkVBox new		packStart: (self buildMenuBar) expand: false;		packStart: (self buildToolBar) expand: false;		packStart: (workspaceView view);		packStart: (GtkStatusbar new) expand: false	).! !!Workspace methodsFor: 'as yet unclassified'!inspectedVar: anObject	workspaceView inspectedVar: anObject.! !!TranscriptCodeEditor methodsFor: 'as yet unclassified'!defaultCodeViewClass	^ TranscriptCodeView! !!Workspace class methodsFor: 'as yet unclassified'!defaultSize	^ 640@480.! !!Workspace class methodsFor: 'as yet unclassified'!title	^'Workspace'! !!TranscriptCodeEditor class methodsFor: 'as yet unclassified'!title	^'Transcript'! !BufferedFileStream initialize!TranscriptCodeView initialize!TraitBehavior removeSelector: #initializeUsers!Application subclass: #Shell	instanceVariableNames: 'bindings'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!ExternalValue initialize!NativeFunctionRelocation removeSelector: #addressRelativeTo:!NativeFunctionRelocation removeSelector: #function!NativeFunctionRelocation removeSelector: #functionName!NativeFunctionRelocation removeSelector: #functionName:!NativeFunctionRelocation removeSelector: #patch:!NativeFunctionRelocation removeSelector: #patch:with:!ReadOnlyAsciiZ class removeSelector: #objectFromHandle:!ProcessorScheduler removeSelector: #activeProcess2!ProcessorScheduler removeSelector: #activeThreadData!ProcessorScheduler removeSelector: #primActiveThreadData!Process removeSelector: #threadData:!PrimitiveType class removeSelector: #defaultHandlerType!PrimitiveType class removeSelector: #instantiateHandler!NativeFunction removeSelector: #address!NativeFunction removeSelector: #bind!NativeFunction removeSelector: #invoke!NativeFunction removeSelector: #invokeAnswering:!NativeFunction removeSelector: #invokeAnswering:with:!NativeFunction removeSelector: #invokeAnswering:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:withArguments:!NativeFunction removeSelector: #invokeWith:!NativeFunction removeSelector: #invokeWith:with:!NativeFunction removeSelector: #invokeWith:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:with:with:!NativeFunction removeSelector: #invokeWithArguments:!NativeFunction removeSelector: #name!NativeFunction removeSelector: #name:!NativeFunction removeSelector: #throwNotKnownError!LibraryData removeSelector: #primitiveGetValue!LibExample initialize!LibC6 initialize!LibC6 removeSelector: #initializeUnistd!LibC6 removeSelector: #openPath:flags:!LibC6 removeSelector: #write2:buffer:size:!LibC removeSelector: #close!GPointer class removeSelector: #instantiateHandler!FileStream removeSelector: #position!FileDescriptor initialize!FileDescriptor removeSelector: #movePositionTo:!FileDescriptor removeSelector: #name!FileDescriptor removeSelector: #name:!FileDescriptor removeSelector: #positionFromEns:!FileDescriptor removeSelector: #setPositionAt:!FileDescriptor removeSelector: #setPositionFromEndAt:!CDeclFunction class removeSelector: #name:libraryNamed:returnType:argTypes:!ExecutableFunction class removeSelector: #name:library:!ExecutableFunction class removeSelector: #name:libraryNamed:!CDeclFunction removeSelector: #classFromType:!CDeclFunction removeSelector: #throwExternalFunctionError!ExecutableFunction removeSelector: #address!ExecutableFunction removeSelector: #bind!ExecutableFunction removeSelector: #invoke!ExecutableFunction removeSelector: #invokeWith:!ExecutableFunction removeSelector: #invokeWith:with:!ExecutableFunction removeSelector: #invokeWith:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithArguments:!ExecutableFunction removeSelector: #invokeWithReceiver:!ExecutableFunction removeSelector: #invokeWithReceiver:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:withArguments:!ExecutableFunction removeSelector: #library!ExecutableFunction removeSelector: #library:!ExecutableFunction removeSelector: #libraryName!ExecutableFunction removeSelector: #libraryNamed:!ExecutableFunction removeSelector: #name!ExecutableFunction removeSelector: #name:!ExecutableFunction removeSelector: #name:library:!ExecutableFunction removeSelector: #name:libraryNamed:!ExecutableFunction removeSelector: #primInvokeReceiver:withArguments:!ExecutableFunction removeSelector: #primInvokeWithArguments:!ExecutableFunction removeSelector: #primInvokeWithReceiver:withArguments:!ExecutableFunction removeSelector: #throwNotKnownError!ExternalSymbol removeSelector: #callingConventionString!ExternalObjectProxy removeSelector: #register!ExternalObjectProxy removeSelector: #unregister!AsciiZ class removeSelector: #objectFromHandle:!Executable class removeSelector: #huenul!DynamicLibrary class removeSelector: #addLibrary:named:!DynamicLibrary class removeSelector: #huemul!DynamicLibrary initialize!DynamicLibrary class removeSelector: #name:!DynamicLibrary class removeSelector: #named:!ExternalObject class removeSelector: #handle:!ExternalObject initialize!ExternalObject class removeSelector: #registry!ExternalObject class removeSelector: #registry:!AsciiZ removeSelector: #setFrom:!ExternalBuffer removeSelector: #finalize!ExternalBuffer removeSelector: #selfCheck!ExternalBuffer removeSelector: #setFrom:!ExternalBuffer removeSelector: #storeInto:size:!Executable removeSelector: #initialize!Executable removeSelector: #instantiateFunctionClass:!Executable removeSelector: #name:!Executable removeSelector: #nativeFunctionNamed:!Executable removeSelector: #primitiveOpen!DynamicLibrary removeSelector: #addExternal:!DynamicLibrary removeSelector: #basicName!DynamicLibrary removeSelector: #bind:!DynamicLibrary removeSelector: #bindFunction:!DynamicLibrary removeSelector: #cDeclFunctionNamed:returnType:argTypes:!DynamicLibrary removeSelector: #primitiveBind:!DynamicLibrary removeSelector: #primitiveBindFunction:!ExternalObject removeSelector: #isNullPointer!Object subclass: #ExternalObject	instanceVariableNames: 'handle'	classVariableNames: 'Registry'	poolDictionaries: ''	category: 'FFI-Types'!ExternalFunctionError class removeSelector: #function:!ExternalFunctionError removeSelector: #function!ExternalFunctionError removeSelector: #function:!ExternalFunctionError removeSelector: #isResumable!Error subclass: #ExternalFunctionError	instanceVariableNames: 'functionName'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!Application class removeSelector: #start!Application class removeSelector: #startWithArguments:!Class removeSelector: #superclass:methodDict:format:name:organization:instVarNames:classPool:sharedPools:!ClassBuilder removeSelector: #computeFormat:instSize:forSuper:ccIndex:!ClassBuilder removeSelector: #format:variable:words:pointers:weak:!Smalltalk removeClassNamed: #SystemChangeNotifierTest!RBProgramNodeVisitor subclass: #ASTChecker	instanceVariableNames: 'scope varsChangedInSend'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!RBProgramNodeVisitor subclass: #ASTTranslator	instanceVariableNames: 'methodBuilder receiverForCascade'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #Application	instanceVariableNames: 'arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!AssembleInstruction subclass: #AssembleCMov	instanceVariableNames: ''	classVariableNames: 'Condition'	poolDictionaries: ''	category: 'Exupery'!Object subclass: #AssemblerExupery	instanceVariableNames: 'stream blockAddresses jumpOffsets bytecodes instructionEncoders plugin relocator picEntries debugCollector source'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #BlockClosure	instanceVariableNames: 'method environment'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Contexts'!PluggableGtkSimpleApplication subclass: #ClassFinder	instanceVariableNames: 'classTrait'	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!Object subclass: #ColouringRegisterAllocator	instanceVariableNames: 'source result machine interferenceGraph registerStack registerFile registerTable spiltRegisters hasSpilt coloursUsed simplifyWorklist spillWorklist moveWorklist coalescedMoves isValidating deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #DebugInfo	instanceVariableNames: 'codeSourceReferences argVarsReferences tempVarsReferences capturedVarsReferences'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!Object subclass: #EventManager	instanceVariableNames: 'actionMap'	classVariableNames: 'ActionMaps'	poolDictionaries: ''	category: 'System-Object'!Error subclass: #ExternalFunctionError	instanceVariableNames: 'functionName '	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!Object subclass: #ExternalObject	instanceVariableNames: 'handle '	classVariableNames: 'Registry '	poolDictionaries: ''	category: 'FFI-Types'!ExternalObject subclass: #DynamicLibrary	instanceVariableNames: 'name symbolCache'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!DynamicLibrary subclass: #Executable	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!ExternalObject subclass: #ExternalBuffer	instanceVariableNames: 'size'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalBuffer subclass: #AsciiZ	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!DynamicLibrary class	instanceVariableNames: 'default'!ExternalObject subclass: #ExternalObjectProxy	instanceVariableNames: 'object'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalObjectProxy subclass: #ExternalArrayProxy	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalObject subclass: #ExternalSymbol	instanceVariableNames: 'name library'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!ExternalSymbol subclass: #ExecutableFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!ExecutableFunction subclass: #CDeclFunction	instanceVariableNames: 'returnType argTypes'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Error subclass: #ExternalSymbolError	instanceVariableNames: 'symbolName'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!ExternalObject subclass: #FileDescriptor	instanceVariableNames: ''	classVariableNames: 'StandardDescriptors'	poolDictionaries: ''	category: 'FFI-Types'!Error subclass: #FileStreamException	instanceVariableNames: 'fileName'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #CannotDeleteFileException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #FileDoesNotExistException	instanceVariableNames: 'readOnly'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #FileExistsException	instanceVariableNames: 'fileClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!AssemblyCopier subclass: #FinalCopier	instanceVariableNames: 'deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!LexicalScope subclass: #FunctionScope	instanceVariableNames: 'thisContextVar thisEnvVar tempVars capturedVars isHome hasInnerFreeVars hideTemps argVars uninitializedTemps capturedParentEnv'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #GIRBuilder	instanceVariableNames: 'ir currentBlock machine relocationInfo primitiveNode literals thisEnvVar cacheMap literalTemp source start stop debugInfo'	classVariableNames: 'InlinedSelectors SpecialConstants SpecialSelectors'	poolDictionaries: ''	category: 'Compiler-IR'!LexicalScope subclass: #InstanceScope	instanceVariableNames: 'vars'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!DynamicLibrary subclass: #LibC6	instanceVariableNames: ''	classVariableNames: 'LSeekDirectives OpenFlags'	poolDictionaries: ''	category: 'FFI-Libraries'!Object subclass: #LibExample	instanceVariableNames: ''	classVariableNames: 'GETPID'	poolDictionaries: ''	category: 'Guille-Test'!DynamicLibrary subclass: #LibReadLine	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!ExternalSymbol subclass: #LibraryData	instanceVariableNames: 'type'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Object subclass: #LivenessAnalyser	instanceVariableNames: 'source hasUpdated isValidating deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #MedLanguage	instanceVariableNames: 'in out start stop'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedCMov	instanceVariableNames: 'type from to'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedEnter	instanceVariableNames: 'argument'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedLeave	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedLiteral	instanceVariableNames: 'literal'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLiteral subclass: #MedFunction	instanceVariableNames: 'block byteCodeAddress'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!ExecutableFunction subclass: #NativeFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Object subclass: #PrimitiveType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!PrimitiveType subclass: #IntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!RBProgramNode subclass: #RBReturnNode	instanceVariableNames: 'return value homeBinding frameBinding'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Nodes'!ExternalObject subclass: #ReadOnlyAsciiZ	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SemanticWarning subclass: #RedeclaredVariableWarning	instanceVariableNames: 'variableNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #RelocationInfo	instanceVariableNames: 'offset'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #ExecutableFunctionRelocation	instanceVariableNames: 'functionName'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #FunctionRelocation	instanceVariableNames: 'function'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #LiteralRelocation	instanceVariableNames: 'literals'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!ExecutableFunctionRelocation subclass: #NativeFunctionRelocation	instanceVariableNames: 'libraryName'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!NativeFunctionRelocation subclass: #ExternalFunctionRelocation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #PrimitiveRelocation	instanceVariableNames: 'number'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!Object subclass: #ScopeVar	instanceVariableNames: 'scope usage'	classVariableNames: 'UsageAutomaton'	poolDictionaries: ''	category: 'Compiler-Semantics'!ScopeVar subclass: #GlobalVar	instanceVariableNames: 'assoc'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!ScopeVar subclass: #LocalVar	instanceVariableNames: 'name index'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!LocalVar subclass: #ArgVar	instanceVariableNames: 'isArg'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!LocalVar subclass: #CapturedVar	instanceVariableNames: 'sourceTemp'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!ByteArray variableByteSubclass: #ExternalValue	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!Object subclass: #SharedPool	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Pools'!Application subclass: #Shell	instanceVariableNames: 'bindings '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!IntegerType subclass: #SignedIntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedByte	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedShortInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!Object subclass: #SourceReference	instanceVariableNames: 'sourceStart sourceStop codeStop'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!RelocationInfo subclass: #SpecialSelectorRelocation	instanceVariableNames: 'specialSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!Model subclass: #StringHolder	instanceVariableNames: 'contents'	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Kernel-Remnants'!Object subclass: #SystemTracer	instanceVariableNames: 'byteStream traceQueue oopMap nextChunk nilOop count'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Tracer'!LocalVar subclass: #TempVar	instanceVariableNames: 'isArg'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Error subclass: #TraitException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Kernel'!TraitException subclass: #TraitCompositionException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Composition'!Error subclass: #TypeConvertionError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!FileStream subclass: #UnbufferedFileStream	instanceVariableNames: 'name fileID'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!Smalltalk renameClassNamed: #BufferedFileStream2 as: #BufferedFileStream!UnbufferedFileStream subclass: #BufferedFileStream	instanceVariableNames: ''	classVariableNames: 'DefaultBufferSize'	poolDictionaries: ''	category: 'Files-Kernel'!BufferedFileStream subclass: #BinaryFileStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!BufferedFileStream subclass: #TextFileStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!IntegerType subclass: #UnsignedIntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedByte	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedShortInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SemanticWarning subclass: #UnusedVariableWarning	instanceVariableNames: 'variableNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #VarReference	instanceVariableNames: 'name'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!RelocationInfo subclass: #VariableRelocation	instanceVariableNames: 'variable'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!PluggableGtkSimpleApplication subclass: #Workspace	instanceVariableNames: 'workspaceView'	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!Workspace subclass: #TranscriptCodeEditor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!!Object methodsFor: 'as yet unclassified'!errorSubscriptBounds: index 	"Create an error notification that an improper integer was used as an index."	self error: 'subscript is out of bounds: ' , index printString! !!Object methodsFor: 'as yet unclassified'!executeMethod: compiledMethod withArgs: argArray	"Execute compiledMethod against the receiver and args in argArray"	| selector |	<primitive: 188>	selector _ Symbol new.	self class addSelectorSilently: selector withMethod: compiledMethod.	^ [self perform: selector withArguments: argArray]		ensure: [self class basicRemoveSelector: selector]! !!Object methodsFor: 'as yet unclassified'!withArgs: argArray executeMethod: compiledMethod	"For compatibility with Aqueak"	self executeMethod: compiledMethod withArgs: argArray! !!Application methodsFor: 'as yet unclassified'!arguments	^ arguments.! !!Application methodsFor: 'as yet unclassified'!arguments: anArray	arguments := anArray.! !!Application methodsFor: 'as yet unclassified'!main	self subclassResponsibility.! !!Application methodsFor: 'as yet unclassified'!startUp	Smalltalk startUp.	^ self main.! !!Behavior methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return true if it is safe to zap the method dictionary on #obsolete"	^true! !!Behavior methodsFor: 'as yet unclassified'!isWeak	^ (format bitAnd: 4) = 1.! !!Behavior methodsFor: 'as yet unclassified'!obsolete	"Invalidate and recycle local methods,	e.g., zap the method dictionary if can be done safely."	self canZapMethodDictionary		ifTrue: [self methodDict: self emptyMethodDictionary].! !!Behavior methodsFor: 'as yet unclassified'!removeSelector: selector	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method."	| oldMethod |		oldMethod _ self methodDict at: selector ifAbsent: [^ self].	self methodDict removeKey: selector.	"Now flush Squeak's method cache, either by selector or by method"	oldMethod flushCache.	selector flushCache! !!Behavior methodsFor: 'as yet unclassified'!selectorsAndMethodsDo: aBlock	"Evaluate selectorBlock for all the message selectors in my method dictionary."	^ self methodDict keysAndValuesDo: aBlock! !!Behavior methodsFor: 'as yet unclassified'!setTraitComposition: aTraitComposition	| oldComposition |	(self hasTraitComposition not and: [aTraitComposition isEmpty]) ifTrue: [^self].	aTraitComposition assertValidUser: self.	oldComposition _ self traitComposition.	self traitComposition: aTraitComposition."	self applyChangesOfNewTraitCompositionReplacing: oldComposition."		oldComposition traits do: [:each | each removeUser: self].	aTraitComposition traits do: [:each | each addUser: self]! !!Behavior methodsFor: 'as yet unclassified'!traitCompositionString	^self hasTraitComposition		ifTrue: [self traitComposition asString]		ifFalse: ['{}']! !!Behavior methodsFor: 'as yet unclassified'!typeOfClass	"Answer a symbol uniquely describing the type of the receiver"	self isWeak ifTrue: [ ^ #weak ].	^ (format bitAnd: 3) caseOf: {		[ 0 ] -> [ #normal ].		[ 1 ] -> [ #variable ].		[ 2 ] -> [ #bytes ].		[ 3 ] -> [ #words ]	}! !!Behavior methodsFor: 'as yet unclassified'!whichSelectorsReferTo: literal	"Answer a set of selectors whose methods access the argument as a literal."	| who |	who _ IdentitySet new.	self selectorsAndMethodsDo: 		[:sel :method |		(method hasLiteral: literal)			ifTrue:				[((literal isVariableBinding) not					or: [method literals allButLast includes: literal])						ifTrue: [who add: sel]]].	^ who! !!BehaviorTest methodsFor: 'as yet unclassified'!testBehaviorSubclasses	"self run: #testBehaviorSubclasses"		| b b2 |"	b := Behavior new.	b superclass: OrderedCollection.	b methodDictionary: Dictionary new.	self shouldnt: [b subclasses ] raise: Error.	self shouldnt: [b withAllSubclasses] raise: Error.	self shouldnt: [b allSubclasses] raise: Error.	b2 := Behavior new.	b2 superclass: b.	b2 methodDictionary: Dictionary new.	self assert: (b subclasses includes: b2).	self assert: (b withAllSubclasses includes: b)."! !!BlockClosure methodsFor: 'as yet unclassified'!valueWithArguments: anArray 	"Evaluate the block with given args. Fail if the block expects other than the given number of arguments."	^ environment executeMethod: method withArgs: anArray ! !!ClassBrowser methodsFor: 'as yet unclassified'!buildClassCategoriesView	| model tree col cell |	tree := nil->nil.	SystemOrganization categories do: [ :each |		| category |		category := tree.		(each subStrings: '-') do: [ :cat |			category value ifNil: [ category value: Dictionary new].			category := category value associationAt: cat ifAbsent: [ category value at: cat put: nil. category value associationAt: cat ]		]	].	model := GtkTreeStore new: {String. String}.	[ self addSubcategoriesFrom: tree fromIter: nil inModel: model ] fork.	classCategoriesTree := GtkTreeView model: model.	col := GtkTreeViewColumn title: 'Class categories'.	cell := GtkCellRendererPixbuf new.	col		packStart: cell expand: false;		addAttribute: #stockId column: 1 on: cell.	cell := GtkCellRendererText new.	col		packStart: cell;		addAttribute: #text column: 0 on: cell.		classCategoriesTree appendColumn: col.	classCategoriesTree selection when: #changed send: #onClassCategoryChanged to: self.	classCategoriesTree enableTreeLines: true.	^ GtkScrolledWindow withChild: classCategoriesTree! !!ClassBrowser methodsFor: 'as yet unclassified'!loadClassMethodsOf: aClassClass	| iter |	classMethodsTree model clear.	aClassClass organization categories do: [ :cat |		iter := classMethodsTree model append: nil->{cat asString. true. 'grey'. 'gtk-info'}.		(aClassClass organization listAtCategoryNamed: cat) asSortedCollection do: [ :sel |			classMethodsTree model append: iter->{sel asString. false. 'grey'. 'gtk-execute'}		]	].	classMethodsTree expandAll.! !!ClassBrowser methodsFor: 'as yet unclassified'!loadInstanceMethodsOf: aClass	| iter |	instanceMethodsTree model clear.	aClass organization categories do: [ :cat |		iter := instanceMethodsTree model append: nil->{cat asString. true. 'grey'. 'gtk-info'}.		(aClass organization listAtCategoryNamed: cat) asSortedCollection do: [ :sel |			instanceMethodsTree model append: iter->{sel asString. false. 'grey'. 'gtk-execute'}		]	].	instanceMethodsTree expandAll.! !!ClassBrowser methodsFor: 'as yet unclassified'!onClassHierarchyChanged	| class iter path newIter aCategory classHierarchySelectedRow classesTreeSelectedRow |	classHierarchySelectedRow := classHierarchyTree selectedRow.	classHierarchySelectedRow ifNotNil: [		class := Smalltalk at: (classHierarchySelectedRow first asSymbol).							aCategory := class category.		( aCategory isNotNil and: [ aCategory ~= selectedClassCategory ] ) ifTrue: [			selectedClassCategory := aCategory.			iter := classCategoriesTree model firstIter.			newIter := nil.			(aCategory subStrings: '-') do: [ :cat |				newIter ifNotNil: [ iter := newIter ].				iter := self classCategoryFor: cat firstIter: iter.				newIter := classCategoriesTree model firstChildAt: iter.			].			path := classCategoriesTree model pathFromIter: iter.			classCategoriesTree expandRowsUpTo: path.			classCategoriesTree moveCursorAt: path.					classesTree model clear.			(SystemOrganization listAtCategoryNamed: aCategory) sort do: [ :ea |				classesTree model append: {ea asString. 'gtk-execute'}			]		].							self selectClass: class.	]! !!ClassBuilder methodsFor: 'as yet unclassified'!formatForType: type	^ type caseOf: {		[ #normal ] -> [ 0 ].		[ #variable ] -> [ 1 ].		[ #bytes ] -> [ 2 ].		[ #words ] -> [ 3 ].		[ #weak ] -> [ 5 "binary: 4 + 0 + 0 + 1" ]	} otherwise: [ self error: 'Unknown class type' ].! !!ClassBuilder methodsFor: 'as yet unclassified'!needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Answer whether we need a new subclass to conform to the requested changes"	"Check if we really need a new subclass"	oldClass ifNil:[^true]. "yes, it's a new class"	newSuper == oldClass superclass ifFalse:[^true]. "yes, it's a superclass change"	type = oldClass typeOfClass ifFalse:[^true]. "yes, it's a format change"	instVars = oldClass instVarNames ifFalse:[^true]. "yes, it's an iVar change"	^false! !!ClassBuilder methodsFor: 'as yet unclassified'!newSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Create a new subclass of the given superclass with the given specification."	| newClass |	(oldClass == nil or:[oldClass isMeta not]) 		ifTrue:[newClass := self privateNewSubclassOf: newSuper from: oldClass]		ifFalse:[newClass := oldClass clone].	newClass 		superclass: newSuper		methodDictionary: "Method"Dictionary new		instanceSize: (newSuper instSize + instVars size)		format: (self formatForType: type);		setInstVarNames: instVars.	oldClass ifNotNil:[		newClass organization: oldClass organization.		"Recompile the new class"		oldClass hasMethods 			ifTrue:[newClass compileAllFrom: oldClass].		oldClass hasTraitComposition ifTrue: [			newClass setTraitComposition: oldClass traitComposition copyTraitExpression ].		oldClass class hasTraitComposition ifTrue: [			newClass class setTraitComposition: oldClass class traitComposition copyTraitExpression ].				self recordClass: oldClass replacedBy: newClass.	].	(oldClass == nil or:[oldClass isObsolete not]) 		ifTrue:[newSuper addSubclass: newClass]		ifFalse:[newSuper addObsoleteSubclass: newClass].	^newClass! !!ClassBuilder methodsFor: 'as yet unclassified'!privateNewSubclassOf: newSuper from: oldClass	"Create a new meta and non-meta subclass of newSuper using oldClass as template"	"WARNING: This method does not preserve the superclass/subclass invariant!!"	| newSuperMeta oldMeta newMeta |	oldClass ifNil:[^self privateNewSubclassOf: newSuper].	newSuperMeta _ newSuper ifNil:[Class] ifNotNil:[newSuper class].	oldMeta _ oldClass class.	newMeta _ oldMeta clone.	newMeta 		superclass: newSuperMeta		methodDictionary: "Method"Dictionary new		instanceSize: oldMeta instSize		format: oldMeta format;		setInstVarNames: oldMeta instVarNames;		organization: oldMeta organization.	"Recompile the meta class"	oldMeta hasMethods 		ifTrue:[newMeta compileAllFrom: oldMeta].	"Record the meta class change"	self recordClass: oldMeta replacedBy: newMeta.	"And create a new instance"	^newMeta adoptInstance: oldClass from: oldMeta! !!ClassBuilder methodsFor: 'as yet unclassified'!reshapeClass: oldClass toSuper: newSuper	"Reshape the given class to the new super class. Recompile all the methods in the newly created class. Answer the new class."	| instVars |	instVars _ instVarMap at: oldClass name ifAbsent:[oldClass instVarNames].	^self newSubclassOf: newSuper 			type: oldClass typeOfClass 			instanceVariables: instVars 			from: oldClass! !!ClassDescription methodsFor: 'as yet unclassified'!classVersion	"Default.  Any class may return a later version to inform readers that use ReferenceStream.  8/17/96 tk"	"This method allows you to distinguish between class versions when the shape of the class 	hasn't changed (when there's no change in the instVar names).	In the conversion methods you usually can tell by the inst var names 	what old version you have. In a few cases, though, the same inst var 	names were kept but their interpretation changed (like in the layoutFrame).	By changing the class version when you keep the same instVars you can 	warn older and newer images that they have to convert."	^ 0! !!ClassDescription methodsFor: 'as yet unclassified'!obsolete	"Make the receiver obsolete."	superclass removeSubclass: self.	self organization: nil.	super obsolete.! !!ClassDescription methodsFor: 'as yet unclassified'!removeSelector: selector 	"Remove the message whose selector is given from the method 	dictionary of the receiver, if it is there. Answer nil otherwise."		| priorMethod priorProtocol | 	priorMethod _ self compiledMethodAt: selector ifAbsent: [^ nil].	priorProtocol _ self whichCategoryIncludesSelector: selector.	SystemChangeNotifier uniqueInstance		doSilently: [self organization removeElement: selector ].	super removeSelector: selector.	SystemChangeNotifier uniqueInstance 			methodRemoved: priorMethod selector: selector inProtocol: priorProtocol class: self.! !!ClassDescription methodsFor: 'as yet unclassified'!updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil	| currentCategory effectiveCategory sel changedCategories composition |	changedCategories _ IdentitySet new.	composition := self hasTraitComposition		ifTrue: [self traitComposition]		ifFalse: [TraitComposition new].	(composition methodDescriptionsForSelector: aSymbol) do: [:each |		sel _ each selector.		(self includesLocalSelector: sel) ifFalse: [			currentCategory _ self organization categoryOfElement: sel.			effectiveCategory _ each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.			effectiveCategory isNil ifTrue: [				currentCategory ifNotNil: [changedCategories add: currentCategory].				self organization removeElement: sel.			] ifFalse: [				((currentCategory isNil or: [currentCategory == ClassOrganizer ambiguous or: [currentCategory == oldCategoryOrNil]]) and: [currentCategory ~~ effectiveCategory]) ifTrue: [					currentCategory ifNotNil: [changedCategories add: currentCategory].					self organization 						classify: sel 						under: effectiveCategory						suppressIfDefault: false]]]].	^ changedCategories! !!ClassDescription methodsFor: 'as yet unclassified'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	(self includesSelector: aSelector)		ifTrue: [^ self organization categoryOfElement: aSelector]		ifFalse: [^nil]! !!Class methodsFor: 'as yet unclassified'!classPool: aDictionary	classPool _ aDictionary! !!Class methodsFor: 'as yet unclassified'!copy 	| newClass |	newClass _ self class copy new		superclass: superclass		methodDict: self methodDict copy		instanceSize: self instSize		format: format		name: name		organization: self organization copy		instVarNames: instanceVariables copy		classPool: classPool copy		sharedPools: sharedPools.	Class instSize+1 to: self class instSize do:		[:offset | newClass instVarAt: offset put: (self instVarAt: offset)].	^ newClass! !!Class methodsFor: 'as yet unclassified'!deactivate	"A remnant from the 3.3a modules work, retained . Does nothing, but may be overridden in Metaclasses."! !!Class methodsFor: 'as yet unclassified'!isSystemDefined	"Answer true if the receiver is a system-defined class, and not a UniClass (an instance-specific lightweight class)"	^ self == self officialClass! !!Class methodsFor: 'as yet unclassified'!obsolete	"Change the receiver and all of its subclasses to an obsolete class."	self == Object 		ifTrue: [^self error: 'Object is NOT obsolete'].	self setName: 'AnObsolete' , self name.	Object class instSize + 1 to: self class instSize do:		[:i | self instVarAt: i put: nil]. "Store nil over class instVars."	self classPool: nil.	self sharedPools: nil.	self class obsolete.	super obsolete.! !!Class methodsFor: 'as yet unclassified'!officialClass	"I am not a UniClass.  (See Player officialClass).  Return the class you use to make new subclasses."	^ self! !!Class methodsFor: 'as yet unclassified'!removeFromSystem	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."	self removeFromSystem: true.! !!Class methodsFor: 'as yet unclassified'!removeFromSystem: logged	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."		"keep the class name and category for triggering the system change message. If we wait to long, then we get obsolete information which is not what we want."	"tell class to deactivate and unload itself-- two separate events in the module system"	self deactivate; unload.	self superclass ifNotNil:		["If we have no superclass there's nothing to be remembered"		self superclass addObsoleteSubclass: self].	self environment forgetClass: self logged: logged.	self obsolete.! !!Class methodsFor: 'as yet unclassified'!sharedPools: aCollection	sharedPools _ aCollection! !!Class methodsFor: 'as yet unclassified'!superclass: sup methodDict: md instanceSize: is format: ft name: nm organization: org instVarNames: nilOrArray classPool: pool sharedPools: poolSet 	"Answer an instance of me, a new class, using the arguments of the 	message as the needed information.	Must only be sent to a new instance; else we would need Object flushCache."	superclass := sup.	methodDict := md.	instanceSize := is.	format := ft.	name := nm.	instanceVariables := nilOrArray.	classPool := pool.	sharedPools := poolSet.	self organization: org.! !!Class methodsFor: 'as yet unclassified'!unload	"Sent when a the class is removed.  Does nothing, but may be overridden by (class-side) subclasses."! !!Class methodsFor: 'as yet unclassified'!variableByteSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable byte-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableByteSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!variableSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable pointer variables."	^(ClassBuilder new)		superclass: self		variableSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!variableWordSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable word-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableWordSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!weakSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have weak indexable pointer variables."	^(ClassBuilder new)		superclass: self		weakSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!AppLauncher class methodsFor: 'as yet unclassified'!openAboutHuemul	| dlg logo |	logo := GdkPixbuf fromFile: 'Huemul.jpg'.	dlg := GtkAboutDialog new.	dlg		aboutDialogName: 'Huemul Smalltalk';		version: '0.8';		license: (StandardFileStream readOnlyFileNamed: 'LICENSE') upToEnd;		website: 'http://www.guillermomolina.com.ar/huemul';		comments: 'This is Huemul Smalltalk';		authors: {'Guillermo Adrian Molina'};		logo: logo.	dlg runAndDestroy! !!AppLauncher class methodsFor: 'as yet unclassified'!openWorkspace	^ Workspace open! !!Application class methodsFor: 'as yet unclassified'!startUp	^ self new startUp.! !!Application class methodsFor: 'as yet unclassified'!startUpWithArguments: arguments	| application |	application := self new.	application arguments: arguments.	^ application startUp.! !!Behavior class methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return false since zapping the method dictionary of Behavior class or its subclasses will cause the system to fail."	^false! !!ClassBrowser class methodsFor: 'as yet unclassified'!defaultSize	^ 640@480.! !!ClassBrowser class methodsFor: 'as yet unclassified'!title	^'Class browser'! !!ClassFinder class methodsFor: 'as yet unclassified'!defaultSize	^ 200@300.! !!ClassFinder class methodsFor: 'as yet unclassified'!title	^'Class finder'! !!CompiledMethod methodsFor: 'as yet unclassified'!hasLiteral: literal	"Answer whether the receiver references the argument, literal."	literals ifNil: [ ^false ].	^ literals hasLiteral: literal.! !!CompiledMethod methodsFor: 'as yet unclassified'!sourcePointer	"Answer the integer which can be used to find the source file and position for this method.	Not sources yet"	^ 0! !!CompiledMethodWithNode class methodsFor: 'as yet unclassified'!method: aCompiledMethod node: aMethodNode	^ self new method: aCompiledMethod; node: aMethodNode.! !!Compiler methodsFor: 'as yet unclassified'!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into a method. In other words, if receiver is not nil, then the text can refer to instance variables of that receiver (the Inspector uses this). If aContext is not nil, the text can refer to temporaries in that context (the Debugger uses this). If aRequestor is not nil, then it will receive a notify:at: message before the attempt to evaluate is aborted. Finally, the compiled method is directly invoked without modifying the receiving-class."	"| methodNode method value |	  	(Preferences compileUseNewCompiler or: 			[aContext ifNotNil: [aContext method isClosureCompiled] ifNil: [false]]) ifTrue: 				[^ self evaluate2: textOrStream 					    in: aContext 					    to: receiver 					    notifying: aRequestor 					    ifFail: failBlock 					    logged: logFlag].		class := (aContext isNil 		ifTrue: [ receiver ] 		ifFalse: [ aContext receiver ])			class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode := self 		translate: sourceStream		noPattern: true 		ifFail: [ ^ failBlock value ].	method := methodNode generate.	self interactive		ifTrue: [ method := method copyWithTempNames: methodNode tempNames ].	value := receiver		executeMethod: method 		withArgs: (context isNil			ifTrue: [ #() ]			ifFalse: [ Array with: aContext ]).	logFlag 		ifTrue: [ SystemChangeNotifier uniqueInstance evaluated: sourceStream contents context: aContext ].	^ value."	| string block |	string _ textOrStream readStream upToEnd.	block := self compileDoIt: string in: aContext to: receiver notifying: aRequestor ifFail: [^ failBlock value] log: logFlag.	^ block value! !!Exception methodsFor: 'as yet unclassified'!messageText	messageText ifNil: [ ^ self class name asString ].	^messageText! !!Exception methodsFor: 'as yet unclassified'!receiver	^ self signalerContext receiver! !!ExternalFunctionError methodsFor: 'as yet unclassified'!functionName	"Answer the function name that was beiing used."	^functionName! !!ExternalFunctionError methodsFor: 'as yet unclassified'!functionName: argument	"Specify the function name that was beiing used."	functionName := argument! !!ExternalFunctionError class methodsFor: 'as yet unclassified'!functionName: argument	^self new functionName: argument; yourself! !!ExternalObject methodsFor: 'as yet unclassified'!= anObject 	(anObject isKindOf: self class)		ifTrue: [^ anObject handle = self handle]		ifFalse: [^ false]! !!ExternalObject methodsFor: 'as yet unclassified'!beNull	^ handle beNull.! !!ExternalObject methodsFor: 'as yet unclassified'!finalize		self free.	self unregister.! !!ExternalObject methodsFor: 'as yet unclassified'!free	"Should override this"! !!ExternalObject methodsFor: 'as yet unclassified'!initialize	handle := self class defaultHandlerClass new.	self register.! !!ExternalObject methodsFor: 'as yet unclassified'!isNull	^ self handle isNull.! !!ExternalObject methodsFor: 'as yet unclassified'!register	Registry add: self.! !!ExternalObject methodsFor: 'as yet unclassified'!unregister		Registry remove: self ifAbsent:[  ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!addSymbol: anExternalSymbol	^ symbolCache at: anExternalSymbol name put: anExternalSymbol.! !!DynamicLibrary methodsFor: 'as yet unclassified'!bindSymbol: anExternalSymbol	^ self primitiveBindSymbol: anExternalSymbol.! !!DynamicLibrary methodsFor: 'as yet unclassified'!cDeclFunctionNamed: functionName	^ symbolCache at: functionName ifAbsent: [ self error: 'You must initialize the function before using it' ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!close		handle isNull ifFalse: [ 		self primitiveClose		handle beNull.	].! !!DynamicLibrary methodsFor: 'as yet unclassified'!initialize	super initialize.	symbolCache := Dictionary new.! !!DynamicLibrary methodsFor: 'as yet unclassified'!initializeCDeclFunctionNamed: functionName returnType: retType argTypes: argTypesArray	^ symbolCache at: functionName put: 			(CDeclFunction name: functionName library: self  returnType: retType argTypes: argTypesArray)! !!DynamicLibrary methodsFor: 'as yet unclassified'!initializeLibraryDataNamed: symbolName type: type	^ symbolCache at: symbolName put: (LibraryData name: symbolName library: self  type: type)! !!DynamicLibrary methodsFor: 'as yet unclassified'!libraryDataNamed: symbolName	^ symbolCache at: symbolName ifAbsent: [ self error: 'You must initialize the symbol before using it' ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!name	^name! !!DynamicLibrary methodsFor: 'as yet unclassified'!name: aName	name := aName.! !!DynamicLibrary methodsFor: 'as yet unclassified'!nativeFunctionNamed: functionName	^ symbolCache at: functionName ifAbsent: [ 		symbolCache at: functionName put: (NativeFunction name: functionName library: self)	].! !!DynamicLibrary methodsFor: 'as yet unclassified'!open		handle isNull ifTrue: [ self primitiveOpen ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveBindSymbol: anExternalSymbol	"Primitive. Find the given symbol in the library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 203>	^ anExternalSymbol throwNotKnownError.! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveClose	"Primitive. Close the given library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 202>! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveOpen	"Primitive. Open the given library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 198>	self primitiveFailed.! !!DynamicLibrary methodsFor: 'as yet unclassified'!printOn: aStream	aStream nextPutAll: self name.! !!DynamicLibrary methodsFor: 'as yet unclassified'!symbolNamed: symbolName	^ symbolCache at: symbolName ifAbsent: [ self error: 'You must initialize the symbol before using it' ]! !!Executable methodsFor: 'as yet unclassified'!name	^ Utilities executableName ! !!Executable methodsFor: 'as yet unclassified'!primitiveSmallIntegerAdd: receiver with: argument	^ (self nativeFunctionNamed: #primitiveSmallIntegerAdd) invokeReceiver: receiver with: argument.! !!ExternalBuffer methodsFor: 'as yet unclassified'!asByteArray	| array |	size ifNil: [ ^ self class throwTypeConvertionError ].	array := ByteArray new: self basicSize.	self storeInto: array.	^ array	! !!ExternalBuffer methodsFor: 'as yet unclassified'!atAllPut: constant	^ LibC6 default memSet: self constant: constant count: self size.! !!ExternalBuffer methodsFor: 'as yet unclassified'!atAllPutZero	^ self atAllPut: 0.! !!ExternalBuffer methodsFor: 'as yet unclassified'!basicSize	^ size.! !!ExternalBuffer methodsFor: 'as yet unclassified'!byteAt: index	<primitive: 190>	index isNumber		ifTrue: [self errorSubscriptBounds: index]		ifFalse: [self errorNonIntegerIndex].! !!ExternalBuffer methodsFor: 'as yet unclassified'!byteAt: index put: value	<primitive: 191>	index isNumber		ifTrue: [self errorSubscriptBounds: index]		ifFalse: [self errorNonIntegerIndex].! !!ExternalBuffer methodsFor: 'as yet unclassified'!free		handle isNull ifFalse: [ 		LibC6 default free: self.		self beNull.	]! !!ExternalBuffer methodsFor: 'as yet unclassified'!loadFrom: aByteArray	<primitive: 199>	self primitiveFailed.! !!ExternalBuffer methodsFor: 'as yet unclassified'!size	^ self basicSize.! !!ExternalBuffer methodsFor: 'as yet unclassified'!size: anInteger	size := anInteger.! !!ExternalBuffer methodsFor: 'as yet unclassified'!storeInto: aByteArray	<primitive: 218>	^ self class throwTypeConvertionError.! !!AsciiZ methodsFor: 'as yet unclassified'!asString	^ handle toString.! !!AsciiZ methodsFor: 'as yet unclassified'!asString2	| calcSize string |	size ifNil: [ ^ self class throwTypeConvertionError ].	calcSize := self strlen.	calcSize >= self size ifTrue: [ ^ self class throwTypeConvertionError ].	string := String new: calcSize.	self storeInto: string.	^ string! !!AsciiZ methodsFor: 'as yet unclassified'!loadFrom: aString		super loadFrom: aString.	self byteAt: (aString size + 1) put: 0.! !!AsciiZ methodsFor: 'as yet unclassified'!strlen	^ LibC6 default strLen: self.! !!ExternalFunction methodsFor: 'as yet unclassified'!library	^ library! !!ExternalFunction methodsFor: 'as yet unclassified'!library: aLibrary	library := aLibrary! !!ExternalFunction methodsFor: 'as yet unclassified'!name	^name! !!ExternalFunction methodsFor: 'as yet unclassified'!name: aName	name := aName! !!ExternalFunction methodsFor: 'as yet unclassified'!name: aName library: aLibrary	self name: aName.	self library: aLibrary! !!ExternalFunction methodsFor: 'as yet unclassified'!reload	library ifNil: [ ^ self throwNotKnownError ].	self handle: (library findFunction: self)! !!ExternalLibrary methodsFor: 'as yet unclassified'!bindFunction: function	| answer |	answer := self primitiveBindFunction: function.	answer ifNotNil: [ ^ answer ].	self open. "Library may be closed, open it and retry"	answer := self primitiveBindFunction: answer.	answer ifNotNil: [ ^ answer ].	^ function throwNotKnownError.		! !!ExternalLibrary methodsFor: 'as yet unclassified'!closeLibrary		(handle isNotNil and: [ handle isNull not ]) ifTrue: [ self primitiveClose ].	self handle: nil.	functionCache := nil.! !!ExternalLibrary methodsFor: 'as yet unclassified'!openLibrary		self primitiveOpen.	self initializeFunctionCache.! !!ExternalLibrary methodsFor: 'as yet unclassified'!primitiveBindFunction: function	"Primitive. Find the given symbol in the library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 203>	^ nil.! !!ExternalObject class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: self! !!ExternalObject class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalAddress! !!ExternalObject class methodsFor: 'as yet unclassified'!handleFromObject: anObject	^ self handleFromObject: anObject ifError: [ self throwTypeConvertionError ]! !!ExternalObject class methodsFor: 'as yet unclassified'!handleFromObject: anObject ifError: aBlock		(anObject isKindOf: ExternalObject) ifFalse: [ ^ aBlock value ].	^ anObject handle.	! !!ExternalObject class methodsFor: 'as yet unclassified'!initialize	Registry := WeakRegistry new.	Smalltalk addToShutDownList: self.! !!ExternalObject class methodsFor: 'as yet unclassified'!objectFromHandle: handle	^self objectFromHandle: handle ifError: [ self throwTypeConvertionError ]! !!ExternalObject class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; yourself! !!ExternalObject class methodsFor: 'as yet unclassified'!quit	Registry do: [ :each | each free ].	self allSubclassesDo: [ :ea | ea quit ]! !!ExternalObject class methodsFor: 'as yet unclassified'!shutDown: quitting	quitting ifTrue: [ self quit ].! !!ExternalObject class methodsFor: 'as yet unclassified'!throwTypeConvertionError	^ TypeConvertionError new signal! !!DynamicLibrary class methodsFor: 'as yet unclassified'!default	self = DynamicLibrary ifTrue: [ self error: 'Create a class to create its singleton' ].	default ifNil: [	"Represents the executable itself"		default := self new.		default name: self moduleName.		default open.	].	^ default.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!initialize	self = DynamicLibrary ifFalse: [ 		Smalltalk addToShutDownList: self	].! !!DynamicLibrary class methodsFor: 'as yet unclassified'!moduleName	self subClassResponsibility.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!resetLibrary	default := nil.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!shutDown: aBool	default ifNotNil: [ default close ].! !!Executable class methodsFor: 'as yet unclassified'!huemul	^ self default! !!Executable class methodsFor: 'as yet unclassified'!moduleName	^nil.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: ByteArray! !!ExternalBuffer class methodsFor: 'as yet unclassified'!fromByteArray: aByteArray	| anExternalBuffer |		anExternalBuffer := ExternalBuffer new: aByteArray size.	anExternalBuffer setFrom: aByteArray.	^ anExternalBuffer.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!handleFromObject: aByteArray ifError: aBlock		(aByteArray isKindOf: ByteArray) ifFalse: [ 		^ super handleFromObject: aByteArray ifError: aBlock	].	^ ( self fromByteArray: aByteArray ) handle.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!new: size	| anExternalBuffer |	"This space is allocated from the system not 	from Object Memory, you will have to give it back, 	as it is not garbage collected"	anExternalBuffer := LibC6 default malloc: (size +  10).	anExternalBuffer size: size.	^ anExternalBuffer! !!AsciiZ class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: String! !!AsciiZ class methodsFor: 'as yet unclassified'!fromString: aString	| anAsciiZ |		anAsciiZ := AsciiZ new: aString size + 1.	anAsciiZ loadFrom: aString.	^ anAsciiZ.! !!AsciiZ class methodsFor: 'as yet unclassified'!handleFromObject: aString ifError: aBlock		(aString isKindOf: String) ifFalse: [ 		^ super handleFromObject: aString ifError: aBlock	].	^ ( self fromString: aString ) handle.! !!AsciiZ class methodsFor: 'as yet unclassified'!new: size	| buffer asciiZ |	buffer := super new: size.	asciiZ := AsciiZ new handle: buffer handle.	asciiZ size: size.	asciiZ atAllPutZero.	buffer handle: ExternalAddress nullPointer.	^ asciiZ! !!AsciiZ class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; asString! !!ExternalFunction class methodsFor: 'as yet unclassified'!name: aName library: aLibrary	^self new name: aName library: aLibrary! !!ExternalLibrary class methodsFor: 'as yet unclassified'!huemul	Huemul ifNil: [	"Represents the executable itself"		Huemul := self new.		Huemul open.	].	^ Huemul.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!handle	self object ifNil: [ handle beNull ].	^ handle.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!initialize	super initialize.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!initializePointer	self handle forObject: self object.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!object	^ self objectPointer at: 1! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!object: anObject	self objectPointer at: 1 put: anObject.	self initializePointer.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!objectPointer	object ifNil: [ object := WeakArray new: 1 ].	^ object! !!ExternalArrayProxy methodsFor: 'as yet unclassified'!initializePointer	self handle forArray: self object.! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!fromObject: anObject		^ self new object: anObject; yourself! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!handleFromObject: anObject ifError: aBlock		^ ( self fromObject: anObject ) handle.! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		^ aBlock value! !!ExternalSymbol methodsFor: 'as yet unclassified'!address	handle isNull ifTrue: [ self bind ].	^ handle.! !!ExternalSymbol methodsFor: 'as yet unclassified'!bind	^ library bindSymbol: self.! !!ExternalSymbol methodsFor: 'as yet unclassified'!classFromType: aType	^ Smalltalk at: aType ifAbsent: [ self throwExternalSymbolError ].! !!ExternalSymbol methodsFor: 'as yet unclassified'!library	^ library! !!ExternalSymbol methodsFor: 'as yet unclassified'!library: aLibrary	library := aLibrary! !!ExternalSymbol methodsFor: 'as yet unclassified'!libraryName	^ library name.! !!ExternalSymbol methodsFor: 'as yet unclassified'!name	^name! !!ExternalSymbol methodsFor: 'as yet unclassified'!name: aName	name := aName! !!ExternalSymbol methodsFor: 'as yet unclassified'!name: aName library: aLibrary	self name: aName.	self library: aLibrary! !!ExternalSymbol methodsFor: 'as yet unclassified'!throwExternalSymbolError	^(ExternalSymbolError symbolName: name) signal.! !!ExternalSymbol methodsFor: 'as yet unclassified'!throwNotKnownError	^(ExternalSymbolError symbolName: name) signal.! !!ExecutableFunction methodsFor: 'as yet unclassified'!callingConventionString	self subclassResponsibility.! !!CDeclFunction methodsFor: 'as yet unclassified'!argTypes: anArrayOfTypes	argTypes := anArrayOfTypes.! !!CDeclFunction methodsFor: 'as yet unclassified'!callingConventionString	^ 'cdecl'! !!CDeclFunction methodsFor: 'as yet unclassified'!invoke	^self invokeWithArguments: #()! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1	^self invokeWithArguments: (Array with: arg1)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2	^self invokeWithArguments: (Array with: arg1 with: arg2)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4 with: arg5	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWithArguments: argArray	| argSize argHandleArray returnClass returnHandle |	argSize := argArray size.	argSize = argTypes size ifFalse: [ self throwExternalFunctionError ].	argHandleArray := Array new: argSize.	1 to: argSize do: [ :i |		| argType argClass argHandle arg |		argType := argTypes at: i.		argClass := self classFromType: argType.		arg := argArray at: i.		argHandle := argClass handleFromObject: arg.		argHandleArray at: i put: argHandle.	].	returnHandle := nil.	returnType = #Void ifFalse: [		returnClass := self classFromType: returnType.		returnHandle := returnClass defaultHandlerClass new.	].	handle isNull ifTrue: [ self bind ].	self primInvokeAnswering: returnHandle withArguments: argHandleArray.	returnType = #Void ifTrue: [ ^ nil ].	^ returnClass objectFromHandle: returnHandle.! !!CDeclFunction methodsFor: 'as yet unclassified'!primInvokeAnswering: aReturnValue withArguments: argArray	"Manually invoke the receiver, representing an external function."	<primitive: 204>	^self primitiveFailed! !!CDeclFunction methodsFor: 'as yet unclassified'!returnType: aType	returnType := aType.! !!CDeclFunction methodsFor: 'as yet unclassified'!returnType: aType argTypes: anArrayOfTypes	self returnType: aType.	self argTypes: anArrayOfTypes.! !!ExternalSymbol class methodsFor: 'as yet unclassified'!name: aName library: aLibrary	^self new name: aName library: aLibrary; bind! !!CDeclFunction class methodsFor: 'as yet unclassified'!name: aName library: aLibrary returnType: retType argTypes: argTypesArray	^self new name: aName library: aLibrary;		 returnType: retType argTypes: argTypesArray;		bind! !!ExternalSymbolError methodsFor: 'as yet unclassified'!isResumable	"Determine whether an exception is resumable."	^true! !!ExternalSymbolError methodsFor: 'as yet unclassified'!symbolName	^ symbolName! !!ExternalSymbolError methodsFor: 'as yet unclassified'!symbolName: argument	"Specify the function name that was beiing used."	symbolName := argument! !!ExternalSymbolError class methodsFor: 'as yet unclassified'!symbolName: argument	^self new symbolName: argument; yourself! !!FileDescriptor methodsFor: 'as yet unclassified'!close		self fileDescriptor > 2 ifTrue: [ 		LibC6 default close: self.		self fileDescriptor: -1.	]! !!FileDescriptor methodsFor: 'as yet unclassified'!fileDescriptor	^ SignedInteger objectFromHandle: handle. ! !!FileDescriptor methodsFor: 'as yet unclassified'!fileDescriptor: anInteger	handle := SignedInteger handleFromObject: anInteger. ! !!FileDescriptor methodsFor: 'as yet unclassified'!free		self close.! !!FileDescriptor methodsFor: 'as yet unclassified'!movePosition: offset"relative to actual position"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_CUR' ).	! !!FileDescriptor methodsFor: 'as yet unclassified'!position	^ self movePosition: 0.	! !!FileDescriptor methodsFor: 'as yet unclassified'!position: offset"absolute position"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_SET' ).! !!FileDescriptor methodsFor: 'as yet unclassified'!positionFromEnd: offset"relative to end of file"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_END' ).	! !!FileDescriptor methodsFor: 'as yet unclassified'!read: size	| retValue buffer |	buffer := ExternalBuffer new: size.	retValue := self readBuffer: buffer size: size.	! !!FileDescriptor methodsFor: 'as yet unclassified'!readBuffer: buffer size: size	^ LibC6 default read: self buffer: buffer size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!readString: aString	^ LibC6 default read: self string: aString size: aString size! !!FileDescriptor methodsFor: 'as yet unclassified'!readString: aString size: size	| internalSize |	internalSize := size.	aString size < size ifTrue: [ internalSize := aString size ].	^ LibC6 default read: self string: aString size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!size	| position size |	position := self position.	size := self positionFromEnd: 0.	self position: position.	^ size	! !!FileDescriptor methodsFor: 'as yet unclassified'!writeBuffer: buffer size: size	^ LibC6 default write: self buffer: buffer size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!writeString: aString	^ LibC6 default write: self string: aString size: aString size! !!FileDescriptor methodsFor: 'as yet unclassified'!writeString: aString size: size	| internalSize |	internalSize := size.	aString size < size ifTrue: [ internalSize := aString size ].	^ LibC6 default write: self string: aString size: size! !!FileDescriptor class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalValue! !!FileDescriptor class methodsFor: 'as yet unclassified'!initialize	self initializeStandardDescriptors! !!FileDescriptor class methodsFor: 'as yet unclassified'!initializeStandardDescriptors	StandardDescriptors := Dictionary new.	StandardDescriptors at: #stdout put: (self newFileDescriptor: 0).	StandardDescriptors at: #stdin put: (self newFileDescriptor: 1).	StandardDescriptors at: #stderr put: (self newFileDescriptor: 2).! !!FileDescriptor class methodsFor: 'as yet unclassified'!newFileDescriptor: anInteger	^ self new fileDescriptor: anInteger; yourself.! !!FileDescriptor class methodsFor: 'as yet unclassified'!standardDescriptors	^ StandardDescriptors! !!FileDescriptor class methodsFor: 'as yet unclassified'!stderr	^ StandardDescriptors at: #stderr.! !!FileDescriptor class methodsFor: 'as yet unclassified'!stdin	^ StandardDescriptors at: #stdin.! !!FileDescriptor class methodsFor: 'as yet unclassified'!stdout	^ StandardDescriptors at: #stdout.! !!FileStream methodsFor: 'as yet unclassified'!atEnd	"Answer true if the current position is >= the end of file position.	 1/31/96 sw: subclassResponsibility"	self subclassResponsibility! !!FileStream class methodsFor: 'as yet unclassified'!fileDoesNotExistUserHandling: fullFileName	(GtkMessageDialog question: fullFileName, ' does not exist, create it?') = #yes		ifTrue: [ ^ self new open: fullFileName forWrite: true ].! !!FileStream class methodsFor: 'as yet unclassified'!fileExistsUserHandling: fullFileName	(GtkMessageDialog question: fullFileName, ' exist, overwrite it?') = #yes		ifTrue: [ ^ self new openForOverwrite: fullFileName ].! !!FileStream class methodsFor: 'as yet unclassified'!readOnlyFileDoesNotExistUserHandling: fullFileName	GtkMessageDialog error: fullFileName, ' does not exist'! !!FileDoesNotExistException methodsFor: 'as yet unclassified'!defaultAction	"The default action taken if the exception is signaled."	^self readOnly		ifTrue: [FileStream readOnlyFileDoesNotExistUserHandling: self fileName]		ifFalse: [FileStream fileDoesNotExistUserHandling: self fileName]! !!GIRBuilder methodsFor: 'as yet unclassified'!compiledMethod	| bytecodes |	bytecodes := self bytecodes.	bytecodes ifNil: [ ^ nil ].	^ CompiledMethod new		primitive: 0;		numArgs: self numArgs;		numTemps: self numTemps;		literals: self literals;		relocationInfo: self relocationInfo;		bytecodes: bytecodes;		debugInfo: debugInfo;		source: source;		relocate.! !!GPointer methodsFor: 'as yet unclassified'!initialize	handle := self class defaultHandlerClass new.! !!GPointer class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalAddress! !!GPointer class methodsFor: 'as yet unclassified'!handle: aByteArray	^self basicNew handle: aByteArray; yourself! !!GObject class methodsFor: 'as yet unclassified'!handleFromObject: object	^ object handle.	! !!Gtk methodsFor: 'as yet unclassified'!initialize	self initializeGtkLibrary.	self startMainLoop.! !!Gtk class methodsFor: 'as yet unclassified'!main! !!Gtk class methodsFor: 'as yet unclassified'!shutDown: quiting	"Quits the Gtk main loop"	Default ifNotNil: [		Default quitMainLoop.		Default close.		Default := nil.	].! !!GtkDemoStockIds methodsFor: 'as yet unclassified'!initialize	| model tree |	model := GtkListStore new: {String. String. String. String}.	GtkStockItem allStocks do: [ :ea |		ea ifNotNil: [			model append: {				ea stockId asGtkStockId.				ea stockId.				ea label.				Gtk acceleratorName: ea keyval asCharacter modifier: ea modifier}]].	tree := GtkTreeView model: model.	self createFirstColumn: tree.	tree appendColumns: {		GtkTreeViewColumn title: 'Label' text: 2.		GtkTreeViewColumn title: 'Accel' text: 3.		GtkTreeViewColumn title: 'ID' text: 0}.	tree selection when: #changed send: #onItemChanged: to: self withArgumentsFirst: {tree}.			self container: (GtkHBox spacing: 5).	self container		packStart: (GtkScrolledWindow withChild: tree);		packEnd: self createInfoFrame expand: false fill: false! !!GtkDemoStockIds methodsFor: 'as yet unclassified'!onItemChanged: aTreeView	aTreeView selectedRow in: [:row |		idLabel label: row first.		nameLabel label: '#', row second.		accelLabel label: row third.		iconImage stock: row second iconSize: #dialog]! !!InMidstOfFileinNotification methodsFor: 'as yet unclassified'!defaultAction	^ self resume: false! !!LibC methodsFor: 'as yet unclassified'!closeLibrary	cLibrary closeLibrary.	cLibrary := nil.! !!LibC methodsFor: 'as yet unclassified'!initializeCLibrary	cLibrary := ExternalLibrary new.	cLibrary name: 'libc.so.6'.	cLibrary openLibrary.! !!LibC class methodsFor: 'as yet unclassified'!shutDown: quiting	"Quits the Gtk main loop"	self default closeLibrary.	Default := nil.! !!LibC6 methodsFor: 'as yet unclassified'!close: fd	| retValue |	retValue := ( self cDeclFunctionNamed: #close ) invokeWith: fd.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #close ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!errno	^ (self libraryDataNamed: #errno) value.	! !!LibC6 methodsFor: 'as yet unclassified'!errno: errno	(self libraryDataNamed: #errno) value: errno.	! !!LibC6 methodsFor: 'as yet unclassified'!free: anExternalBuffer	( self cDeclFunctionNamed: #free ) invokeWith: anExternalBuffer.	! !!LibC6 methodsFor: 'as yet unclassified'!getCurrentDirName	| retValue |	[ retValue := ( self cDeclFunctionNamed: 'get_current_dir_name' asSymbol ) invoke ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: 'get_current_dir_name' asSymbol ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!getEnv: envVariable	^ ( self cDeclFunctionNamed: #getenv ) invokeWith: envVariable.! !!LibC6 methodsFor: 'as yet unclassified'!getpid	^ (self cDeclFunctionNamed: #getpid) invoke.	! !!LibC6 methodsFor: 'as yet unclassified'!initialize	super initialize.	self initializeUniStd.	self initializeStdLib.	self initializeString.	self initializeFCntl.	self initializeStdIO.	self initializeErrNO.! !!LibC6 methodsFor: 'as yet unclassified'!initializeErrNO	self initializeLibraryDataNamed: #errno type: #SignedInteger.! !!LibC6 methodsFor: 'as yet unclassified'!initializeFCntl	self initializeCDeclFunctionNamed: #open returnType: #FileDescriptor argTypes: #( AsciiZ SignedInteger UnsignedInteger ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeStdIO	self initializeCDeclFunctionNamed: #printf  returnType: #SignedInteger argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: #perror  returnType: #Void argTypes: #( AsciiZ  ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeStdLib	self initializeCDeclFunctionNamed: #malloc  returnType: #ExternalBuffer argTypes: #( UnsignedInteger  ).	self initializeCDeclFunctionNamed: #free  returnType: #Void argTypes: #( ExternalBuffer  ).	self initializeCDeclFunctionNamed: #getenv  returnType: #AsciiZ argTypes: #( AsciiZ ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeString	self initializeCDeclFunctionNamed: #strlen returnType: #UnsignedInteger argTypes: #( AsciiZ ).	self initializeCDeclFunctionNamed: #strcat returnType: #AsciiZ argTypes: #( AsciiZ AsciiZ ).	self initializeCDeclFunctionNamed: #strcpy returnType: #AsciiZ argTypes: #( AsciiZ AsciiZ ).	self initializeCDeclFunctionNamed: #strerror returnType: #ReadOnlyAsciiZ argTypes: #( SignedInteger ).	self initializeCDeclFunctionNamed: #memset returnType: #ExternalBuffer argTypes: #( ExternalBuffer SignedInteger  UnsignedInteger ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeUniStd	self initializeCDeclFunctionNamed: #getpid  returnType: #UnsignedInteger argTypes: #().	self initializeCDeclFunctionNamed: 'get_current_dir_name' asSymbol  returnType: #AsciiZ argTypes: #().	self initializeCDeclFunctionNamed: #close  returnType: #SignedInteger argTypes: #( FileDescriptor ).	self initializeCDeclFunctionNamed: #lseek  returnType: #UnsignedInteger argTypes: #( FileDescriptor UnsignedInteger SignedInteger ).	self initializeCDeclFunctionNamed: #read  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalBuffer UnsignedInteger ).	self initializeCDeclFunctionNamed: #write  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalBuffer UnsignedInteger )."Redefinition of read for Strings"	symbolCache at: #readString put: (CDeclFunction name: #read library: self  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalArrayProxy UnsignedInteger ) )."Redefinition of write for Strings"	symbolCache at: #writeString put: (CDeclFunction name: #write library: self  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalArrayProxy UnsignedInteger ) ).! !!LibC6 methodsFor: 'as yet unclassified'!lseek: fileDescriptor offset: offset whence: whence	| returnValue |	returnValue := (self cDeclFunctionNamed: #lseek) invokeWith: fileDescriptor with: offset with: whence.	returnValue < 0 ifTrue: [		self throwErrorForExternalFunctionNamed: #lseek.		^ nil.	].	^ returnValue.	! !!LibC6 methodsFor: 'as yet unclassified'!malloc: size	| retValue |	[ retValue := ( self cDeclFunctionNamed: #malloc ) invokeWith: size ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: #malloc withMessage: 'can not allocate memory' ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!memSet: buffer constant: c count: n	^ (self cDeclFunctionNamed: #memset) invokeWith: buffer with: c with: n.	! !!LibC6 methodsFor: 'as yet unclassified'!open: path flags: flags	^ self open: path flags: flags mode: 8r644	! !!LibC6 methodsFor: 'as yet unclassified'!open: path flags: flags mode: mode	| fileDescriptor |	fileDescriptor := (self cDeclFunctionNamed: #open) invokeWith: path with: flags with: mode.	fileDescriptor fileDescriptor < 0 ifTrue: [		self throwErrorForExternalFunctionNamed: #open.		^ nil.	].	^ fileDescriptor.	! !!LibC6 methodsFor: 'as yet unclassified'!perror: aString	( self cDeclFunctionNamed: #perror ) invokeWith: aString.	! !!LibC6 methodsFor: 'as yet unclassified'!printf: aString	^ ( self cDeclFunctionNamed: #printf ) invokeWith: aString.	! !!LibC6 methodsFor: 'as yet unclassified'!read: fd buffer: buffer size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #read ) invokeWith: fd with: buffer with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #read ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!read: fd string: aString size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #readString ) invokeWith: fd with: aString with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #readString ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!strCat: destString with: sourceString	^ ( self cDeclFunctionNamed: #strcat ) invokeWith: destString with: sourceString.	! !!LibC6 methodsFor: 'as yet unclassified'!strCpy: destString with: sourceString	^ ( self cDeclFunctionNamed: #strcpy ) invokeWith: destString with: sourceString.	! !!LibC6 methodsFor: 'as yet unclassified'!strError: errno	| retValue |	[ retValue := ( self cDeclFunctionNamed: #strerror ) invokeWith: errno ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: #strerror ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!strLen: string	^ ( self cDeclFunctionNamed: #strlen ) invokeWith: string	! !!LibC6 methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName	^ self throwErrorForExternalFunctionNamed: functionName withMessage: (self strError: self errno).	! !!LibC6 methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName withMessage: aString	| error |	error := ExternalFunctionError functionName: functionName.	error messageText: aString.	^ error signal.	! !!LibC6 methodsFor: 'as yet unclassified'!valueForLSeekDirectiveNamed: aString	^ LSeekDirectives at: aString asSymbol.	! !!LibC6 methodsFor: 'as yet unclassified'!valueForOpenFlagNamed: aString	^ OpenFlags at: aString asSymbol.	! !!LibC6 methodsFor: 'as yet unclassified'!write: fd buffer: buffer size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #write ) invokeWith: fd with: buffer with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #write ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!write: fd string: aString size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #writeString ) invokeWith: fd with: aString with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #writeString ].	^ retValue.	! !!LibC6 class methodsFor: 'as yet unclassified'!initialize	self initializeOpenFlags.	self initializeLSeekDirectives.! !!LibC6 class methodsFor: 'as yet unclassified'!initializeLSeekDirectives	| lSeekDirectives |		lSeekDirectives := Dictionary new.	lSeekDirectives at: 'SEEK_SET' put: 0.	lSeekDirectives at: 'SEEK_CUR' put: 1.	lSeekDirectives at: 'SEEK_END' put: 2.	LSeekDirectives := lSeekDirectives! !!LibC6 class methodsFor: 'as yet unclassified'!initializeOpenFlags	| flagArray openFlags |		flagArray := #( 		('O_RDONLY'		0)		('O_WRONLY'		8r1)		('O_RDWR'		8r2)		('O_CREAT'		8r100)			('O_EXCL'			8r200)			('O_NOCTTY'		8r400)			('O_TRUNC'		8r1000)			('O_APPEND'		8r2000)		('O_NONBLOCK'	8r4000)		('O_SYNC'		8r10000)		('O_ASYNC'		8r20000)	).	openFlags := Dictionary new.	flagArray do: [ :i |		openFlags at: i first asSymbol put: i second	].	OpenFlags := openFlags! !!LibC6 class methodsFor: 'as yet unclassified'!moduleName	^ 'libc.so.6'.! !!LibExample methodsFor: 'as yet unclassified'!getpid	^ GETPID invoke! !!LibExample class methodsFor: 'as yet unclassified'!getpid	^ GETPID! !!LibExample class methodsFor: 'as yet unclassified'!initialize	GETPID := CDeclFunction name: 'getpid' libraryNamed: 'libc.so.6' returnType: #UnsignedInteger argTypes: #().! !!LibReadLine methodsFor: 'as yet unclassified'!addHistory: aString	( self cDeclFunctionNamed: 'add_history' asSymbol ) invokeWith: aString.! !!LibReadLine methodsFor: 'as yet unclassified'!initialize	super initialize.	self initializeCDeclFunctionNamed: #readline  returnType: #AsciiZ argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'add_history' asSymbol returnType: #Void argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'read_history' asSymbol returnType: #SignedInteger argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'write_history' asSymbol returnType: #SignedInteger argTypes: #( AsciiZ  ).! !!LibReadLine methodsFor: 'as yet unclassified'!readHistory: aFileName	| errno |	errno := ( self cDeclFunctionNamed: 'read_history' asSymbol ) invokeWith: aFileName.	errno = 0 ifFalse: [ self throwErrorForExternalFunctionNamed: 'read_history' asSymbol errno: errno ].	^ errno.! !!LibReadLine methodsFor: 'as yet unclassified'!readline: prompt	^ ( self cDeclFunctionNamed: #readline ) invokeWith: prompt.! !!LibReadLine methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName errno: errno	| error |	error := ExternalFunctionError functionName: functionName.	error messageText: (LibC6 default strError: errno).	^ error signal.! !!LibReadLine methodsFor: 'as yet unclassified'!writeHistory: aFileName	| errno |	errno := ( self cDeclFunctionNamed: 'write_history' asSymbol ) invokeWith: aFileName.	errno = 0 ifFalse: [ self throwErrorForExternalFunctionNamed: 'write_history' asSymbol errno: errno ].	^ errno.! !!LibReadLine class methodsFor: 'as yet unclassified'!moduleName	^ 'libreadline.so.5'.! !!LibraryData methodsFor: 'as yet unclassified'!primitiveGetValue: valueHandle	<primitive: 216>	^self primitiveFailed! !!LibraryData methodsFor: 'as yet unclassified'!primitiveSetValue: valueHandle	<primitive: 217>	^self primitiveFailed! !!LibraryData methodsFor: 'as yet unclassified'!type	^ type.! !!LibraryData methodsFor: 'as yet unclassified'!type: aType	type := aType.! !!LibraryData methodsFor: 'as yet unclassified'!value	| valueClass valueHandle |	valueClass := self classFromType: type.	valueHandle := valueClass defaultHandlerClass new.	handle isNull ifTrue: [ self bind ].	self primitiveGetValue: valueHandle.	^ valueClass objectFromHandle: valueHandle.! !!LibraryData methodsFor: 'as yet unclassified'!value: aValue	| argHandle argClass |	argClass := self classFromType: type.	argHandle := argClass handleFromObject: aValue.	handle isNull ifTrue: [ self bind ].	self primitiveSetValue: argHandle! !!LibraryData class methodsFor: 'as yet unclassified'!name: aName library: aLibrary type: type	^self new name: aName library: aLibrary;		type: type;		bind! !!Metaclass methodsFor: 'as yet unclassified'!addObsoleteSubclass: aClass	"Do nothing."! !!Metaclass methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return true if it is safe to zap the method dictionary on #obsolete"	thisClass == nil		ifTrue:[^true]		ifFalse:[^thisClass canZapMethodDictionary]! !!Metaclass methodsFor: 'as yet unclassified'!isSystemDefined	"Answer false if I am a UniClass (an instance-specific lightweight class)"	^ true! !!NativeFunction methodsFor: 'as yet unclassified'!callingConventionString	^ 'native'! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver	^self invokeReceiver: receiver withArguments: #()! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1	^self invokeReceiver: receiver withArguments: (Array with: arg1)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4 with: arg5	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver withArguments: argArray	handle isNull ifTrue: [ self bind ].	^ self primInvokeReceiver: receiver withArguments: argArray.! !!NativeFunction methodsFor: 'as yet unclassified'!primInvokeReceiver: receiver withArguments: argArray	"Manually invoke the receiver, representing an native function."	<primitive: 197>	^self primitiveFailed! !!ObjectTest methodsFor: 'as yet unclassified'!testBecome	"self debug: #testBecome"	"this test should that all the variables pointing to an object are pointing now to another one, and all      object pointing to the other are pointing to the object"	| pt1 pt2 pt3 |	pt1 := 0@0.	pt2 := pt1.	pt3 := 100@100.	pt1 become: pt3.	self assert: pt2 = (100@100).	self assert: pt3 = (0@0).	self assert: pt1 = (100@100).! !!ObjectTest methodsFor: 'as yet unclassified'!testBecomeForward	"self debug: #testBecomeForward"	"this test should that all the variables pointing to an object are pointing now to another one.	Not that this inverse is not true. This kind of become is called oneWayBecome in VW"	| pt1 pt2 pt3 |	pt1 := 0@0.	pt2 := pt1.	pt3 := 100@100.	pt1 becomeForward: pt3.	self assert: pt2 = (100@100).	self assert: pt3 == pt2.	self assert: pt1 = (100@100)! !!PrimitiveType class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalValue! !!PrimitiveType class methodsFor: 'as yet unclassified'!handleFromObject: anObject	^ self handleFromObject: anObject ifError: [ self throwTypeConvertionError ]! !!PrimitiveType class methodsFor: 'as yet unclassified'!handleFromObject: object ifError: aBlock	self subclassResponsibility.! !!PrimitiveType class methodsFor: 'as yet unclassified'!objectFromHandle: handle	^ self objectFromHandle: handle ifError: [  self throwTypeConvertionError ]! !!PrimitiveType class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock	self subclassResponsibility.! !!PrimitiveType class methodsFor: 'as yet unclassified'!throwTypeConvertionError	^ TypeConvertionError new signal! !!IntegerType class methodsFor: 'as yet unclassified'!handleFromObject: anInteger ifError: aBlock	| handle |		(self checkType: anInteger) ifFalse: [ ^ aBlock value ].	handle := ExternalValue new.	self store: anInteger in: handle.	^ handle.	! !!IntegerType class methodsFor: 'as yet unclassified'!isBigEndian	^  false! !!IntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	self subclassResponsibility.! !!IntegerType class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: errorBlock	| value |		value := self loadFrom: handle.	(value > self max ) ifTrue: [ ^ errorBlock value ].	^ value.! !!Process methodsFor: 'as yet unclassified'!primitiveBeInitialProcess	<primitive: 196>	self primitiveFailed! !!ProcessorScheduler methodsFor: 'as yet unclassified'!activeProcess	^ self primActiveProcess! !!ProcessorScheduler methodsFor: 'as yet unclassified'!primActiveProcess	<primitive: 195>	self primitiveFail.! !!ProcessorScheduler methodsFor: 'as yet unclassified'!startUp	| firstProcess |"	(processList isNil or: [ processList isEmpty not ]) ifTrue: [ self initialize ]."	self initialize.	firstProcess := Process new.	firstProcess name: 'Init'.	firstProcess priority: self userSchedulingPriority.	firstProcess state: #running."	firstProcess threadData: self activeThreadData."	firstProcess primitiveBeInitialProcess.! !!ReadOnlyAsciiZ methodsFor: 'as yet unclassified'!asString	^ handle toString.! !!ReadOnlyAsciiZ class methodsFor: 'as yet unclassified'!handleFromObject: aByteArray ifError: aBlock	"Can not be used as arguments"	aBlock value.! !!ReadOnlyAsciiZ class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; asString! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!addressRelativeTo: bytecodes	| functionAddress bytecodesAddress |	functionAddress := self function address asInteger.	bytecodesAddress := (ExternalAddress forArray: bytecodes ) asInteger.	^ functionAddress - bytecodesAddress - offset - 4! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!function	^ self library functionNamed: functionName.! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!functionName	^ functionName! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!functionName: aSymbol	^ functionName := aSymbol! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!library	^ Executable default! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!patch: bytecodes	self patch: bytecodes with: (self addressRelativeTo: bytecodes).! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!patch: bytecodes with: value	bytecodes longAt: (offset + 1) put: value bigEndian: false.! !!FunctionRelocation methodsFor: 'as yet unclassified'!addressRelativeTo: bytecodes	^ self primAddressRelativeTo: bytecodes! !!FunctionRelocation methodsFor: 'as yet unclassified'!primAddressRelativeTo: bytecodes	<primitive: 155>	self primitiveFail.! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!defaultLibraryClass	^ NativeLibrary! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!library 		^ self defaultLibraryClass named: libraryName! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!libraryName	^ libraryName! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!libraryName: aSymbol	^ libraryName := aSymbol! !!ExternalFunctionRelocation methodsFor: 'as yet unclassified'!defaultLibraryClass	^ ExternalLibrary2! !!SequenceableCollection methodsFor: 'as yet unclassified'!asTraitComposition	"For convenience the composition {T1. T2 ...} is the same as T1 + T2 + ..."	^self isEmpty		ifFalse: [			self size = 1				ifTrue: [self first asTraitComposition]				ifFalse: [					self copyWithoutFirst 						inject: self first						into: [:left :right | left + right]]]		ifTrue: [			TraitComposition new]! !!Array methodsFor: 'as yet unclassified'!elementsExchangeIdentityWith: otherArray	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsExchangeIdentityWith: otherArray.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!elementsForwardIdentityTo: otherArray	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsForwardIdentityTo: otherArray.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!elementsForwardIdentityTo: otherArray copyHash: copyHash	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsForwardIdentityTo: otherArray copyHash: copyHash.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!primElementsExchangeIdentityWith: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  At the same time, all pointers to the elements of otherArray are replaced by pointers to the corresponding elements of this array.  The identityHashes remain with the pointers rather than with the objects so that objects in hashed structures should still be properly indexed after the mutation."	<primitive: 128>	otherArray class == Array ifFalse: [^ self error: 'arg must be array'].	self size = otherArray size ifFalse: [^ self error: 'arrays must be same size'].	(self anySatisfy: [:obj | obj class == SmallInteger]) ifTrue: [^ self error: 'can''t become SmallIntegers'].	(otherArray anySatisfy: [:obj | obj class == SmallInteger]) ifTrue: [^ self error: 'can''t become SmallIntegers'].	"Must have failed because not enough space in forwarding table (see ObjectMemory-prepareForwardingTableForBecoming:with:twoWay:).  Do GC and try again only once"	(Smalltalk bytesLeft: true) = Smalltalk primitiveGarbageCollect		ifTrue: [^ self primitiveFailed].	^ self elementsExchangeIdentityWith: otherArray! !!Array methodsFor: 'as yet unclassified'!primElementsForwardIdentityTo: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  The identityHashes remain with the pointers rather than with the objects so that the objects in this array should still be properly indexed in any existing hashed structures after the mutation."	<primitive: 72>	self primitiveFailed! !!Array methodsFor: 'as yet unclassified'!primElementsForwardIdentityTo: otherArray copyHash: copyHash	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  The identityHashes remain with the pointers rather than with the objects so that the objects in this array should still be properly indexed in any existing hashed structures after the mutation."	<primitive: 249>	self primitiveFailed! !!ExternalValue methodsFor: 'as yet unclassified'!beNull	"Make the receiver a NULL pointer"	self atAllPut: 0.! !!ExternalValue methodsFor: 'as yet unclassified'!isNull	^(self basicAt: 1) = 0	and: (self basicAt: 2) = 0	and: (self basicAt: 3) = 0	and: (self basicAt: 4) = 0	! !!ExternalValue class methodsFor: 'as yet unclassified'!initialize	Smalltalk addToStartUpList: self.! !!ExternalValue class methodsFor: 'as yet unclassified'!new	"External addresses are always 4 bytes long"	^super new: 4! !!ExternalValue class methodsFor: 'as yet unclassified'!new: n	"You better don't try this..."	^self shouldNotImplement! !!ExternalValue class methodsFor: 'as yet unclassified'!startUp: resuming	resuming ifTrue: [		self allInstancesDo: [ :addr |			addr beNull		]	].! !!SharedPool class methodsFor: 'as yet unclassified'!bindingOf: varName	"Answer the binding of some variable resolved in the scope of the receiver"	| aSymbol binding |	aSymbol := varName asSymbol.	"First look in classVar dictionary."	binding := self classPool bindingOf: aSymbol.	binding ifNotNil:[^binding].	"Next look in shared pools."	self sharedPools do:[:pool | 		binding := pool bindingOf: aSymbol.		binding ifNotNil:[^binding].	].	"subclassing and environment are not preserved"	^nil! !!SharedPool class methodsFor: 'as yet unclassified'!bindingsDo: aBlock	^self classPool bindingsDo: aBlock! !!SharedPool class methodsFor: 'as yet unclassified'!classBindingOf: varName	"For initialization messages grant the regular scope"	^super bindingOf: varName! !!SharedPool class methodsFor: 'as yet unclassified'!hasBindingThatBeginsWith: aString	"Answer true if the receiver has a binding that begins with aString, false otherwise"	"First look in classVar dictionary."	(self classPool hasBindingThatBeginsWith: aString) ifTrue:[^true].	"Next look in shared pools."	self sharedPools do:[:pool | 		(pool hasBindingThatBeginsWith: aString) ifTrue: [^true]].	^false! !!SharedPool class methodsFor: 'as yet unclassified'!includesKey: aName	"does this pool include aName"	^(self bindingOf: aName) notNil! !!SharedPool class methodsFor: 'as yet unclassified'!keysDo: aBlock"A hopefully temporary fix for an issue arising from miss-spelled variable names in code being compiled. The correction code (see Class>possibleVariablesFor:continuedFrom: assumes that sharedPools are Dictionaries. The proper fix would involve making sure all pools are actually subclasses of SharedPool, which they are not currently."	self bindingsDo:[:b|		aBlock value: b key]! !!Shell methodsFor: 'as yet unclassified'!display: string	| buffer |		buffer := AsciiZ fromString: string.	^ FileDescriptor stdout writeBuffer: buffer size: buffer size.! !!Shell methodsFor: 'as yet unclassified'!input: prompt	^ LibReadLine default readline: prompt! !!Shell methodsFor: 'as yet unclassified'!main	| line value failed anotherLine buffer |	LibReadLine default readHistory: self historyFileName.	[		anotherLine := false.		buffer := ''.		[ 	| prompt |			prompt := anotherLine ifTrue: [ '' ] ifFalse: [ '> ' ].			line _ self input: prompt.			line isEmpty				ifTrue: [ true ] 				ifFalse: [					(line last = $\)						ifTrue: [							anotherLine := true.							line at: line size put: Character lf.						]						ifFalse: [ anotherLine := false ].					buffer := buffer, line.					anotherLine				]		] whileTrue. 		buffer = 'quit' or: [ buffer = 'save' ]	] whileFalse: [		self addToHistory: buffer.		failed _ false.		value _ Compiler new evaluate: buffer in: nil to: nil notifying: self ifFail: [ failed _ true].		failed ifFalse: [ self display: (value printString); lf ]	].	LibReadLine default writeHistory: self historyFileName.	buffer = 'save' ifTrue: [ Smalltalk snapshotAndQuit ].	^value.! !!SignedIntegerType class methodsFor: 'as yet unclassified'!checkType: value	^ value isInteger and: [ value >= self min and: [ value <= self max ] ]! !!SignedIntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	^ handle longAt: 1 bigEndian: self isBigEndian.! !!SignedIntegerType class methodsFor: 'as yet unclassified'!store: anInteger in: handle	handle longAt: 1 put: anInteger bigEndian: self isBigEndian.! !!SignedByte class methodsFor: 'as yet unclassified'!max			^ 127! !!SignedByte class methodsFor: 'as yet unclassified'!min			^ -128! !!SignedInteger class methodsFor: 'as yet unclassified'!max			^ 2147483647! !!SignedInteger class methodsFor: 'as yet unclassified'!min			^ -2147483648! !!SignedShortInteger class methodsFor: 'as yet unclassified'!max			^ 32767! !!SignedShortInteger class methodsFor: 'as yet unclassified'!min			^ -32768! !!SourceReference methodsFor: 'as yet unclassified'!sourceFrom: aString	self hasEmptySourceReference ifTrue: [ ^ '' ].	^ aString copyFrom: sourceStart to: sourceStop! !!StandardFileStream class methodsFor: 'as yet unclassified'!retryWithGC: execBlock until: testBlock forFileNamed: fullName	"Re-implemented to only force GC if a file with the given name exists"	| blockValue foundIt |	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	"See if we have a file with the given name"	foundIt := self registry keys "hold on strongly for now" 		anySatisfy:[:file| file name sameAs: fullName].	foundIt ifFalse:[^blockValue].	Smalltalk garbageCollectMost.	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollect.	^execBlock value.! !!SystemDictionary methodsFor: 'as yet unclassified'!forgetClass: aClass logged: aBool 	"Delete the class, aClass, from the system.	Note that this doesn't do everything required to dispose of a class - to do that use Class>>removeFromSystem."	aBool ifTrue: [SystemChangeNotifier uniqueInstance classRemoved: aClass fromCategory: aClass category].			SystemOrganization removeElement: aClass name.	self removeFromStartUpList: aClass.	self removeFromShutDownList: aClass.	self removeKey: aClass name ifAbsent: [].	self flushClassNameCache! !!SystemDictionary methodsFor: 'as yet unclassified'!removeClassNamed: aName	"Invoked from fileouts:  if there is currently a class in the system named aName, then remove it.  If anything untoward happens, report it in the Transcript.  "	| oldClass |	(oldClass _ self at: aName asSymbol ifAbsent: [nil]) == nil		ifTrue:			[Transcript cr; show: 'Removal of class named ', aName, ' ignored because ', aName, ' does not exist.'.			^ self].	oldClass removeFromSystem! !!SystemDictionary methodsFor: 'as yet unclassified'!startUp	Processor startUp.	ProcessorScheduler startUp.	self processStartUpList: true.	self installLowSpaceWatcher.! !!SystemTracer methodsFor: 'as yet unclassified'!getAligned: size	^ (( size + 3 ) bitShift: -2) bitShift: 2.! !!TraitBehavior methodsFor: 'as yet unclassified'!addUser: aClassOrTrait	users add: aClassOrTrait! !!TraitBehavior methodsFor: 'as yet unclassified'!classesComposedWithMe	^users gather: [:u | u classesComposedWithMe]! !!TraitBehavior methodsFor: 'as yet unclassified'!initialize	self methodDict: Dictionary new.	self traitComposition: nil.	users _ IdentitySet new.! !!TraitBehavior methodsFor: 'as yet unclassified'!removeUser: aClassOrTrait	users remove: aClassOrTrait ifAbsent: []! !!TraitBehavior methodsFor: 'as yet unclassified'!users	^users! !!TraitComposition methodsFor: 'as yet unclassified'!assertValidUser: aBehavior	"Assert that this trait composition set for aBehavior	does not introduce a cycle."		(self allTraits includes: aBehavior) ifTrue: [		TraitCompositionException signal: 'Cycle in compositions:  The composition (in)directly includes this trait!!']! !!TraitComposition methodsFor: 'as yet unclassified'!methodDescriptionsForSelector: aSymbol	"Return a collection of TraitMethodDescriptions for aSymbol and all the 	aliases of aSymbol."	| selectors collection |	selectors _ IdentitySet with: aSymbol.	self transformations do: [:each |		selectors addAll: (each aliasesForSelector: aSymbol)].	collection _ OrderedCollection new: selectors size.	selectors do: [:each |		collection add: (self methodDescriptionForSelector: each)].	^collection! !!TraitDescription methodsFor: 'as yet unclassified'!trait	"for compatibility with TraitTransformations"	^ self! !!TraitDescription methodsFor: 'as yet unclassified'!updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil	| currentCategory effectiveCategory sel changedCategories composition |	changedCategories _ IdentitySet new.	composition := self hasTraitComposition		ifTrue: [self traitComposition]		ifFalse: [TraitComposition new].	(composition methodDescriptionsForSelector: aSymbol) do: [:each |		sel _ each selector.		(self includesLocalSelector: sel) ifFalse: [			currentCategory _ self organization categoryOfElement: sel.			effectiveCategory _ each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.			effectiveCategory isNil ifTrue: [				currentCategory ifNotNil: [changedCategories add: currentCategory].				self organization removeElement: sel.			] ifFalse: [				((currentCategory isNil or: [currentCategory == ClassOrganizer ambiguous or: [currentCategory == oldCategoryOrNil]]) and: [currentCategory ~~ effectiveCategory]) ifTrue: [					currentCategory ifNotNil: [changedCategories add: currentCategory].					self organization 						classify: sel 						under: effectiveCategory						suppressIfDefault: false]]]].	^ changedCategories! !!TraitDescription methodsFor: 'as yet unclassified'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	(self includesSelector: aSelector)		ifTrue: [^ self organization categoryOfElement: aSelector]		ifFalse: [^nil]! !!Trait methodsFor: 'as yet unclassified'!initialize	super initialize.	classTrait _ ClassTrait for: self! !!TranscriptCodeView class methodsFor: 'as yet unclassified'!initialize	Smalltalk addToStartUpList: self.! !!TranscriptCodeView class methodsFor: 'as yet unclassified'!startUp: resuming	resuming ifTrue: [		TranscriptCodeBuffer := nil.	].! !!TranscriptStream methodsFor: 'as yet unclassified'!open	TranscriptCodeEditor open.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!atEnd	position ifNil: [ ^ nil ].	^ position >= readLimit! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!close	"Close this file."	fileID ifNotNil: [		fileID close.		fileID := nil.		position := nil.	].! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!open: fileName flags: flags	[ fileID := LibC6 default open: fileName flags: flags ]		on: ExternalFunctionError		do: [ ^ nil ].	name := fileName.	readLimit := fileID size.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!open: fileName forWrite: writeMode 	| flags |	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	flags := writeMode 		ifTrue: [ LibC6 default valueForOpenFlagNamed: 'O_RDWR' ]		ifFalse: [ LibC6 default valueForOpenFlagNamed: 'O_RDONLY' ].	rwmode := writeMode.	^ self open: fileName flags: flags.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!openForOverwrite: fileName	| flags |	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	flags := ((LibC6 default valueForOpenFlagNamed: 'O_RDWR') 			bitOr: ( LibC6 default valueForOpenFlagNamed: 'O_TRUNC' )) 			bitOr: ( LibC6 default valueForOpenFlagNamed: 'O_CREAT' ).	rwmode := true.	^ self open: fileName flags: flags.! !!BufferedFileStream methodsFor: 'as yet unclassified'!close	"Close this file."	self flush.	^ super close.! !!BufferedFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	self subclassResponsibility! !!BufferedFileStream methodsFor: 'as yet unclassified'!defaultBufferSize	^ DefaultBufferSize.! !!BufferedFileStream methodsFor: 'as yet unclassified'!flush	| bufferPosition bufferSize |	fileID ifNil: [ ^ nil ].	rwmode ifFalse: [ ^ nil ].	bufferPosition := position truncateTo: (collection size).	bufferSize := collection size min: ( readLimit - bufferPosition).	fileID position: bufferPosition.	bufferSize > 0 ifTrue: [ fileID writeString: collection size: bufferSize ].	 ! !!BufferedFileStream methodsFor: 'as yet unclassified'!initializeBuffer	| bufferSize |	position := 0.	collection := self defaultBufferClass new: self defaultBufferSize.	bufferSize := collection size min: readLimit.	bufferSize > 0 ifTrue: [ fileID readString: collection size: bufferSize ]. ! !!BufferedFileStream methodsFor: 'as yet unclassified'!next	| byte |	byte := self peek.	self position: position + 1.	^ byte! !!BufferedFileStream methodsFor: 'as yet unclassified'!nextPut: char	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	position ifNil: [ self position: 0 ].	collection at: (position \\ (collection size)) + 1put: char.	self position: position + 1.	^ char! !!BufferedFileStream methodsFor: 'as yet unclassified'!open: fileName flags: flags	(super open: fileName flags: flags) ifNotNil: [ self initializeBuffer ].! !!BufferedFileStream methodsFor: 'as yet unclassified'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	position ifNil: [ self position: 0 ].	self atEnd ifTrue: [^ nil ].	^ collection at: (position \\ (collection size)) + 1.! !!BufferedFileStream methodsFor: 'as yet unclassified'!position: newPosition	| oldBufferPosition newBufferPosition bufferSize |	fileID ifNil: [ ^nil ].	newPosition < 0 ifTrue: [ ^nil ]."	((newPosition > readLimit) and: [ rwmode not ])  ifTrue: [ ^nil ]."	newPosition > readLimit ifTrue: [		rwmode ifTrue: [ readLimit := newPosition ] ifFalse: [ ^nil ]	].	oldBufferPosition := position truncateTo: (collection size).	newBufferPosition := newPosition truncateTo: (collection size).	newBufferPosition = oldBufferPosition ifFalse: [ 		self flush.		fileID position: newBufferPosition.		bufferSize := collection size min: ( readLimit - newBufferPosition).		collection := self defaultBufferClass new: self defaultBufferSize.		bufferSize > 0 ifTrue: [ fileID readString: collection size: bufferSize ].	].	position := newPosition."	rwmode ifTrue: [ readLimit := newPosition ]."	^ position.! !!BinaryFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	^ ByteArray! !!TextFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	^ String! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!concreteStream	"Who should we really direct class queries to?  "	^ UnbufferedFileStream.! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!fileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new open: fileName forWrite: true! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!forceNewFileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new openForOverwrite: fileName! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!readOnlyFileNamed: fileName 	"Open an existing file with the given name for reading."	| f |	f := self new open: fileName forWrite: false.	^ f isNil		ifFalse: [f]		ifTrue: ["File does not exist..."			((FileDoesNotExistException fileName: fileName) readOnly: true) signal].	"StandardFileStream readOnlyFileNamed: 'kjsd.txt' "! !!BufferedFileStream class methodsFor: 'as yet unclassified'!initialize	self initializeDefaultBufferSize.! !!BufferedFileStream class methodsFor: 'as yet unclassified'!initializeDefaultBufferSize	DefaultBufferSize := 4096.! !!BufferedFileStream class methodsFor: 'as yet unclassified'!new	^ TextFileStream new.! !!UnhandledError methodsFor: 'as yet unclassified'!devDefaultAction	"The current computation is terminated. The cause of the error should be logged or reported to the user. If the program is operating in an interactive debugging environment the computation should be suspended and the debugger activated."	(GtkMessageDialog question: exception messageText, ', debug it?' ) = #yes		ifTrue: [ ^Processor activeProcess debugError: exception ]."	^ Processor activeProcess terminate."! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!checkType: value	^ value isInteger and: [ value >= 0 and: [ value <= self max ] ]! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	^ handle unsignedLongAt: 1 bigEndian: self isBigEndian.! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!min	^ 0! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!store: anInteger in: handle	handle unsignedLongAt: 1 put: anInteger bigEndian: self isBigEndian.! !!UnsignedByte class methodsFor: 'as yet unclassified'!max			^ 255! !!UnsignedInteger class methodsFor: 'as yet unclassified'!max			^ 4294967295! !!UnsignedShortInteger class methodsFor: 'as yet unclassified'!max			^ 65535! !!Workspace methodsFor: 'as yet unclassified'!buildMenuBar	| menu  edit  |	menu := GtkMenuBar new.	edit := GtkMenu new.	menu		append: AppLauncher fileMenu;		append: (edit createMenuItem: '_Edit');		append: workspaceView menu;		append: AppLauncher toolsMenu;		append: AppLauncher helpMenu.					^ menu.! !!Workspace methodsFor: 'as yet unclassified'!buildToolBar	| toolBar |	^ GtkToolbar new		appendItems: workspaceView toolBar;		yourself! !!Workspace methodsFor: 'as yet unclassified'!defaultCodeViewClass	^ WorkspaceView! !!Workspace methodsFor: 'as yet unclassified'!initialize	workspaceView := self defaultCodeViewClass new.	self container: (GtkVBox new		packStart: (self buildMenuBar) expand: false;		packStart: (self buildToolBar) expand: false;		packStart: (workspaceView view);		packStart: (GtkStatusbar new) expand: false	).! !!Workspace methodsFor: 'as yet unclassified'!inspectedVar: anObject	workspaceView inspectedVar: anObject.! !!TranscriptCodeEditor methodsFor: 'as yet unclassified'!defaultCodeViewClass	^ TranscriptCodeView! !!Workspace class methodsFor: 'as yet unclassified'!defaultSize	^ 640@480.! !!Workspace class methodsFor: 'as yet unclassified'!title	^'Workspace'! !!TranscriptCodeEditor class methodsFor: 'as yet unclassified'!title	^'Transcript'! !BufferedFileStream initialize!TranscriptCodeView initialize!TraitBehavior removeSelector: #initializeUsers!Application subclass: #Shell	instanceVariableNames: 'bindings'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!ExternalValue initialize!NativeFunctionRelocation removeSelector: #addressRelativeTo:!NativeFunctionRelocation removeSelector: #function!NativeFunctionRelocation removeSelector: #functionName!NativeFunctionRelocation removeSelector: #functionName:!NativeFunctionRelocation removeSelector: #patch:!NativeFunctionRelocation removeSelector: #patch:with:!ReadOnlyAsciiZ class removeSelector: #objectFromHandle:!ProcessorScheduler removeSelector: #activeProcess2!ProcessorScheduler removeSelector: #activeThreadData!ProcessorScheduler removeSelector: #primActiveThreadData!Process removeSelector: #threadData:!PrimitiveType class removeSelector: #defaultHandlerType!PrimitiveType class removeSelector: #instantiateHandler!NativeFunction removeSelector: #address!NativeFunction removeSelector: #bind!NativeFunction removeSelector: #invoke!NativeFunction removeSelector: #invokeAnswering:!NativeFunction removeSelector: #invokeAnswering:with:!NativeFunction removeSelector: #invokeAnswering:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:withArguments:!NativeFunction removeSelector: #invokeWith:!NativeFunction removeSelector: #invokeWith:with:!NativeFunction removeSelector: #invokeWith:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:with:with:!NativeFunction removeSelector: #invokeWithArguments:!NativeFunction removeSelector: #name!NativeFunction removeSelector: #name:!NativeFunction removeSelector: #throwNotKnownError!LibraryData removeSelector: #primitiveGetValue!LibExample initialize!LibC6 initialize!LibC6 removeSelector: #initializeUnistd!LibC6 removeSelector: #openPath:flags:!LibC6 removeSelector: #write2:buffer:size:!LibC removeSelector: #close!GPointer class removeSelector: #instantiateHandler!FileStream removeSelector: #position!FileDescriptor initialize!FileDescriptor removeSelector: #movePositionTo:!FileDescriptor removeSelector: #name!FileDescriptor removeSelector: #name:!FileDescriptor removeSelector: #positionFromEns:!FileDescriptor removeSelector: #setPositionAt:!FileDescriptor removeSelector: #setPositionFromEndAt:!CDeclFunction class removeSelector: #name:libraryNamed:returnType:argTypes:!ExecutableFunction class removeSelector: #name:library:!ExecutableFunction class removeSelector: #name:libraryNamed:!CDeclFunction removeSelector: #classFromType:!CDeclFunction removeSelector: #throwExternalFunctionError!ExecutableFunction removeSelector: #address!ExecutableFunction removeSelector: #bind!ExecutableFunction removeSelector: #invoke!ExecutableFunction removeSelector: #invokeWith:!ExecutableFunction removeSelector: #invokeWith:with:!ExecutableFunction removeSelector: #invokeWith:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithArguments:!ExecutableFunction removeSelector: #invokeWithReceiver:!ExecutableFunction removeSelector: #invokeWithReceiver:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:withArguments:!ExecutableFunction removeSelector: #library!ExecutableFunction removeSelector: #library:!ExecutableFunction removeSelector: #libraryName!ExecutableFunction removeSelector: #libraryNamed:!ExecutableFunction removeSelector: #name!ExecutableFunction removeSelector: #name:!ExecutableFunction removeSelector: #name:library:!ExecutableFunction removeSelector: #name:libraryNamed:!ExecutableFunction removeSelector: #primInvokeReceiver:withArguments:!ExecutableFunction removeSelector: #primInvokeWithArguments:!ExecutableFunction removeSelector: #primInvokeWithReceiver:withArguments:!ExecutableFunction removeSelector: #throwNotKnownError!ExternalSymbol removeSelector: #callingConventionString!ExternalObjectProxy removeSelector: #register!ExternalObjectProxy removeSelector: #unregister!AsciiZ class removeSelector: #objectFromHandle:!Executable class removeSelector: #huenul!DynamicLibrary class removeSelector: #addLibrary:named:!DynamicLibrary class removeSelector: #huemul!DynamicLibrary initialize!DynamicLibrary class removeSelector: #name:!DynamicLibrary class removeSelector: #named:!ExternalObject class removeSelector: #handle:!ExternalObject initialize!ExternalObject class removeSelector: #registry!ExternalObject class removeSelector: #registry:!AsciiZ removeSelector: #setFrom:!ExternalBuffer removeSelector: #finalize!ExternalBuffer removeSelector: #selfCheck!ExternalBuffer removeSelector: #setFrom:!ExternalBuffer removeSelector: #storeInto:size:!Executable removeSelector: #initialize!Executable removeSelector: #instantiateFunctionClass:!Executable removeSelector: #name:!Executable removeSelector: #nativeFunctionNamed:!Executable removeSelector: #primitiveOpen!DynamicLibrary removeSelector: #addExternal:!DynamicLibrary removeSelector: #basicName!DynamicLibrary removeSelector: #bind:!DynamicLibrary removeSelector: #bindFunction:!DynamicLibrary removeSelector: #cDeclFunctionNamed:returnType:argTypes:!DynamicLibrary removeSelector: #primitiveBind:!DynamicLibrary removeSelector: #primitiveBindFunction:!ExternalObject removeSelector: #isNullPointer!Object subclass: #ExternalObject	instanceVariableNames: 'handle'	classVariableNames: 'Registry'	poolDictionaries: ''	category: 'FFI-Types'!ExternalFunctionError class removeSelector: #function:!ExternalFunctionError removeSelector: #function!ExternalFunctionError removeSelector: #function:!ExternalFunctionError removeSelector: #isResumable!Error subclass: #ExternalFunctionError	instanceVariableNames: 'functionName'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!Application class removeSelector: #start!Application class removeSelector: #startWithArguments:!Class removeSelector: #superclass:methodDict:format:name:organization:instVarNames:classPool:sharedPools:!ClassBuilder removeSelector: #computeFormat:instSize:forSuper:ccIndex:!ClassBuilder removeSelector: #format:variable:words:pointers:weak:!Smalltalk removeClassNamed: #SystemChangeNotifierTest!RBProgramNodeVisitor subclass: #ASTChecker	instanceVariableNames: 'scope varsChangedInSend'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!RBProgramNodeVisitor subclass: #ASTTranslator	instanceVariableNames: 'methodBuilder receiverForCascade'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #Application	instanceVariableNames: 'arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!AssembleInstruction subclass: #AssembleCMov	instanceVariableNames: ''	classVariableNames: 'Condition'	poolDictionaries: ''	category: 'Exupery'!Object subclass: #AssemblerExupery	instanceVariableNames: 'stream blockAddresses jumpOffsets bytecodes instructionEncoders plugin relocator picEntries debugCollector source'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #BlockClosure	instanceVariableNames: 'method environment'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Contexts'!PluggableGtkSimpleApplication subclass: #ClassFinder	instanceVariableNames: 'classTrait'	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!Object subclass: #ColouringRegisterAllocator	instanceVariableNames: 'source result machine interferenceGraph registerStack registerFile registerTable spiltRegisters hasSpilt coloursUsed simplifyWorklist spillWorklist moveWorklist coalescedMoves isValidating deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #DebugInfo	instanceVariableNames: 'codeSourceReferences argVarsReferences tempVarsReferences capturedVarsReferences'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!Object subclass: #EventManager	instanceVariableNames: 'actionMap'	classVariableNames: 'ActionMaps'	poolDictionaries: ''	category: 'System-Object'!Error subclass: #ExternalFunctionError	instanceVariableNames: 'functionName '	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!Object subclass: #ExternalObject	instanceVariableNames: 'handle '	classVariableNames: 'Registry '	poolDictionaries: ''	category: 'FFI-Types'!ExternalObject subclass: #DynamicLibrary	instanceVariableNames: 'name symbolCache'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!DynamicLibrary subclass: #Executable	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!ExternalObject subclass: #ExternalBuffer	instanceVariableNames: 'size'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalBuffer subclass: #AsciiZ	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!DynamicLibrary class	instanceVariableNames: 'default'!ExternalObject subclass: #ExternalObjectProxy	instanceVariableNames: 'object'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalObjectProxy subclass: #ExternalArrayProxy	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalObject subclass: #ExternalSymbol	instanceVariableNames: 'name library'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!ExternalSymbol subclass: #ExecutableFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!ExecutableFunction subclass: #CDeclFunction	instanceVariableNames: 'returnType argTypes'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Error subclass: #ExternalSymbolError	instanceVariableNames: 'symbolName'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!ExternalObject subclass: #FileDescriptor	instanceVariableNames: ''	classVariableNames: 'StandardDescriptors'	poolDictionaries: ''	category: 'FFI-Types'!Error subclass: #FileStreamException	instanceVariableNames: 'fileName'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #CannotDeleteFileException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #FileDoesNotExistException	instanceVariableNames: 'readOnly'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #FileExistsException	instanceVariableNames: 'fileClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!AssemblyCopier subclass: #FinalCopier	instanceVariableNames: 'deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!LexicalScope subclass: #FunctionScope	instanceVariableNames: 'thisContextVar thisEnvVar tempVars capturedVars isHome hasInnerFreeVars hideTemps argVars uninitializedTemps capturedParentEnv'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #GIRBuilder	instanceVariableNames: 'ir currentBlock machine relocationInfo primitiveNode literals thisEnvVar cacheMap literalTemp source start stop debugInfo'	classVariableNames: 'InlinedSelectors SpecialConstants SpecialSelectors'	poolDictionaries: ''	category: 'Compiler-IR'!LexicalScope subclass: #InstanceScope	instanceVariableNames: 'vars'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!DynamicLibrary subclass: #LibC6	instanceVariableNames: ''	classVariableNames: 'LSeekDirectives OpenFlags'	poolDictionaries: ''	category: 'FFI-Libraries'!Object subclass: #LibExample	instanceVariableNames: ''	classVariableNames: 'GETPID'	poolDictionaries: ''	category: 'Guille-Test'!DynamicLibrary subclass: #LibReadLine	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!ExternalSymbol subclass: #LibraryData	instanceVariableNames: 'type'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Object subclass: #LivenessAnalyser	instanceVariableNames: 'source hasUpdated isValidating deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #MedLanguage	instanceVariableNames: 'in out start stop'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedCMov	instanceVariableNames: 'type from to'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedEnter	instanceVariableNames: 'argument'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedLeave	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedLiteral	instanceVariableNames: 'literal'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLiteral subclass: #MedFunction	instanceVariableNames: 'block byteCodeAddress'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!ExecutableFunction subclass: #NativeFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Object subclass: #PrimitiveType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!PrimitiveType subclass: #IntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!RBProgramNode subclass: #RBReturnNode	instanceVariableNames: 'return value homeBinding frameBinding'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Nodes'!ExternalObject subclass: #ReadOnlyAsciiZ	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SemanticWarning subclass: #RedeclaredVariableWarning	instanceVariableNames: 'variableNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #RelocationInfo	instanceVariableNames: 'offset'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #ExecutableFunctionRelocation	instanceVariableNames: 'functionName'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #FunctionRelocation	instanceVariableNames: 'function'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #LiteralRelocation	instanceVariableNames: 'literals'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!ExecutableFunctionRelocation subclass: #NativeFunctionRelocation	instanceVariableNames: 'libraryName'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!NativeFunctionRelocation subclass: #ExternalFunctionRelocation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #PrimitiveRelocation	instanceVariableNames: 'number'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!Object subclass: #ScopeVar	instanceVariableNames: 'scope usage'	classVariableNames: 'UsageAutomaton'	poolDictionaries: ''	category: 'Compiler-Semantics'!ScopeVar subclass: #GlobalVar	instanceVariableNames: 'assoc'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!ScopeVar subclass: #LocalVar	instanceVariableNames: 'name index'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!LocalVar subclass: #ArgVar	instanceVariableNames: 'isArg'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!LocalVar subclass: #CapturedVar	instanceVariableNames: 'sourceTemp'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!ByteArray variableByteSubclass: #ExternalValue	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!Object subclass: #SharedPool	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Pools'!Application subclass: #Shell	instanceVariableNames: 'bindings '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!IntegerType subclass: #SignedIntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedByte	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedShortInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!Object subclass: #SourceReference	instanceVariableNames: 'sourceStart sourceStop codeStop'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!RelocationInfo subclass: #SpecialSelectorRelocation	instanceVariableNames: 'specialSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!Model subclass: #StringHolder	instanceVariableNames: 'contents'	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Kernel-Remnants'!Object subclass: #SystemTracer	instanceVariableNames: 'byteStream traceQueue oopMap nextChunk nilOop count'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Tracer'!LocalVar subclass: #TempVar	instanceVariableNames: 'isArg'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Error subclass: #TraitException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Kernel'!TraitException subclass: #TraitCompositionException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Composition'!Error subclass: #TypeConvertionError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!FileStream subclass: #UnbufferedFileStream	instanceVariableNames: 'name fileID'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!Smalltalk renameClassNamed: #BufferedFileStream2 as: #BufferedFileStream!UnbufferedFileStream subclass: #BufferedFileStream	instanceVariableNames: ''	classVariableNames: 'DefaultBufferSize'	poolDictionaries: ''	category: 'Files-Kernel'!BufferedFileStream subclass: #BinaryFileStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!BufferedFileStream subclass: #TextFileStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!IntegerType subclass: #UnsignedIntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedByte	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedShortInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SemanticWarning subclass: #UnusedVariableWarning	instanceVariableNames: 'variableNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #VarReference	instanceVariableNames: 'name'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!RelocationInfo subclass: #VariableRelocation	instanceVariableNames: 'variable'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!PluggableGtkSimpleApplication subclass: #Workspace	instanceVariableNames: 'workspaceView'	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!Workspace subclass: #TranscriptCodeEditor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!!Object methodsFor: 'as yet unclassified'!errorSubscriptBounds: index 	"Create an error notification that an improper integer was used as an index."	self error: 'subscript is out of bounds: ' , index printString! !!Object methodsFor: 'as yet unclassified'!executeMethod: compiledMethod withArgs: argArray	"Execute compiledMethod against the receiver and args in argArray"	| selector |	<primitive: 188>	selector _ Symbol new.	self class addSelectorSilently: selector withMethod: compiledMethod.	^ [self perform: selector withArguments: argArray]		ensure: [self class basicRemoveSelector: selector]! !!Object methodsFor: 'as yet unclassified'!withArgs: argArray executeMethod: compiledMethod	"For compatibility with Aqueak"	self executeMethod: compiledMethod withArgs: argArray! !!Application methodsFor: 'as yet unclassified'!arguments	^ arguments.! !!Application methodsFor: 'as yet unclassified'!arguments: anArray	arguments := anArray.! !!Application methodsFor: 'as yet unclassified'!main	self subclassResponsibility.! !!Application methodsFor: 'as yet unclassified'!startUp	Smalltalk startUp.	^ self main.! !!Behavior methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return true if it is safe to zap the method dictionary on #obsolete"	^true! !!Behavior methodsFor: 'as yet unclassified'!isWeak	^ (format bitAnd: 4) = 1.! !!Behavior methodsFor: 'as yet unclassified'!obsolete	"Invalidate and recycle local methods,	e.g., zap the method dictionary if can be done safely."	self canZapMethodDictionary		ifTrue: [self methodDict: self emptyMethodDictionary].! !!Behavior methodsFor: 'as yet unclassified'!removeSelector: selector	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method."	| oldMethod |		oldMethod _ self methodDict at: selector ifAbsent: [^ self].	self methodDict removeKey: selector.	"Now flush Squeak's method cache, either by selector or by method"	oldMethod flushCache.	selector flushCache! !!Behavior methodsFor: 'as yet unclassified'!selectorsAndMethodsDo: aBlock	"Evaluate selectorBlock for all the message selectors in my method dictionary."	^ self methodDict keysAndValuesDo: aBlock! !!Behavior methodsFor: 'as yet unclassified'!setTraitComposition: aTraitComposition	| oldComposition |	(self hasTraitComposition not and: [aTraitComposition isEmpty]) ifTrue: [^self].	aTraitComposition assertValidUser: self.	oldComposition _ self traitComposition.	self traitComposition: aTraitComposition."	self applyChangesOfNewTraitCompositionReplacing: oldComposition."		oldComposition traits do: [:each | each removeUser: self].	aTraitComposition traits do: [:each | each addUser: self]! !!Behavior methodsFor: 'as yet unclassified'!traitCompositionString	^self hasTraitComposition		ifTrue: [self traitComposition asString]		ifFalse: ['{}']! !!Behavior methodsFor: 'as yet unclassified'!typeOfClass	"Answer a symbol uniquely describing the type of the receiver"	self isWeak ifTrue: [ ^ #weak ].	^ (format bitAnd: 3) caseOf: {		[ 0 ] -> [ #normal ].		[ 1 ] -> [ #variable ].		[ 2 ] -> [ #bytes ].		[ 3 ] -> [ #words ]	}! !!Behavior methodsFor: 'as yet unclassified'!whichSelectorsReferTo: literal	"Answer a set of selectors whose methods access the argument as a literal."	| who |	who _ IdentitySet new.	self selectorsAndMethodsDo: 		[:sel :method |		(method hasLiteral: literal)			ifTrue:				[((literal isVariableBinding) not					or: [method literals allButLast includes: literal])						ifTrue: [who add: sel]]].	^ who! !!BehaviorTest methodsFor: 'as yet unclassified'!testBehaviorSubclasses	"self run: #testBehaviorSubclasses"		| b b2 |"	b := Behavior new.	b superclass: OrderedCollection.	b methodDictionary: Dictionary new.	self shouldnt: [b subclasses ] raise: Error.	self shouldnt: [b withAllSubclasses] raise: Error.	self shouldnt: [b allSubclasses] raise: Error.	b2 := Behavior new.	b2 superclass: b.	b2 methodDictionary: Dictionary new.	self assert: (b subclasses includes: b2).	self assert: (b withAllSubclasses includes: b)."! !!BlockClosure methodsFor: 'as yet unclassified'!valueWithArguments: anArray 	"Evaluate the block with given args. Fail if the block expects other than the given number of arguments."	^ environment executeMethod: method withArgs: anArray ! !!ClassBrowser methodsFor: 'as yet unclassified'!buildClassCategoriesView	| model tree col cell |	tree := nil->nil.	SystemOrganization categories do: [ :each |		| category |		category := tree.		(each subStrings: '-') do: [ :cat |			category value ifNil: [ category value: Dictionary new].			category := category value associationAt: cat ifAbsent: [ category value at: cat put: nil. category value associationAt: cat ]		]	].	model := GtkTreeStore new: {String. String}.	[ self addSubcategoriesFrom: tree fromIter: nil inModel: model ] fork.	classCategoriesTree := GtkTreeView model: model.	col := GtkTreeViewColumn title: 'Class categories'.	cell := GtkCellRendererPixbuf new.	col		packStart: cell expand: false;		addAttribute: #stockId column: 1 on: cell.	cell := GtkCellRendererText new.	col		packStart: cell;		addAttribute: #text column: 0 on: cell.		classCategoriesTree appendColumn: col.	classCategoriesTree selection when: #changed send: #onClassCategoryChanged to: self.	classCategoriesTree enableTreeLines: true.	^ GtkScrolledWindow withChild: classCategoriesTree! !!ClassBrowser methodsFor: 'as yet unclassified'!loadClassMethodsOf: aClassClass	| iter |	classMethodsTree model clear.	aClassClass organization categories do: [ :cat |		iter := classMethodsTree model append: nil->{cat asString. true. 'grey'. 'gtk-info'}.		(aClassClass organization listAtCategoryNamed: cat) asSortedCollection do: [ :sel |			classMethodsTree model append: iter->{sel asString. false. 'grey'. 'gtk-execute'}		]	].	classMethodsTree expandAll.! !!ClassBrowser methodsFor: 'as yet unclassified'!loadInstanceMethodsOf: aClass	| iter |	instanceMethodsTree model clear.	aClass organization categories do: [ :cat |		iter := instanceMethodsTree model append: nil->{cat asString. true. 'grey'. 'gtk-info'}.		(aClass organization listAtCategoryNamed: cat) asSortedCollection do: [ :sel |			instanceMethodsTree model append: iter->{sel asString. false. 'grey'. 'gtk-execute'}		]	].	instanceMethodsTree expandAll.! !!ClassBrowser methodsFor: 'as yet unclassified'!onClassHierarchyChanged	| class iter path newIter aCategory classHierarchySelectedRow classesTreeSelectedRow |	classHierarchySelectedRow := classHierarchyTree selectedRow.	classHierarchySelectedRow ifNotNil: [		class := Smalltalk at: (classHierarchySelectedRow first asSymbol).							aCategory := class category.		( aCategory isNotNil and: [ aCategory ~= selectedClassCategory ] ) ifTrue: [			selectedClassCategory := aCategory.			iter := classCategoriesTree model firstIter.			newIter := nil.			(aCategory subStrings: '-') do: [ :cat |				newIter ifNotNil: [ iter := newIter ].				iter := self classCategoryFor: cat firstIter: iter.				newIter := classCategoriesTree model firstChildAt: iter.			].			path := classCategoriesTree model pathFromIter: iter.			classCategoriesTree expandRowsUpTo: path.			classCategoriesTree moveCursorAt: path.					classesTree model clear.			(SystemOrganization listAtCategoryNamed: aCategory) sort do: [ :ea |				classesTree model append: {ea asString. 'gtk-execute'}			]		].							self selectClass: class.	]! !!ClassBuilder methodsFor: 'as yet unclassified'!formatForType: type	^ type caseOf: {		[ #normal ] -> [ 0 ].		[ #variable ] -> [ 1 ].		[ #bytes ] -> [ 2 ].		[ #words ] -> [ 3 ].		[ #weak ] -> [ 5 "binary: 4 + 0 + 0 + 1" ]	} otherwise: [ self error: 'Unknown class type' ].! !!ClassBuilder methodsFor: 'as yet unclassified'!needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Answer whether we need a new subclass to conform to the requested changes"	"Check if we really need a new subclass"	oldClass ifNil:[^true]. "yes, it's a new class"	newSuper == oldClass superclass ifFalse:[^true]. "yes, it's a superclass change"	type = oldClass typeOfClass ifFalse:[^true]. "yes, it's a format change"	instVars = oldClass instVarNames ifFalse:[^true]. "yes, it's an iVar change"	^false! !!ClassBuilder methodsFor: 'as yet unclassified'!newSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Create a new subclass of the given superclass with the given specification."	| newClass |	(oldClass == nil or:[oldClass isMeta not]) 		ifTrue:[newClass := self privateNewSubclassOf: newSuper from: oldClass]		ifFalse:[newClass := oldClass clone].	newClass 		superclass: newSuper		methodDictionary: "Method"Dictionary new		instanceSize: (newSuper instSize + instVars size)		format: (self formatForType: type);		setInstVarNames: instVars.	oldClass ifNotNil:[		newClass organization: oldClass organization.		"Recompile the new class"		oldClass hasMethods 			ifTrue:[newClass compileAllFrom: oldClass].		oldClass hasTraitComposition ifTrue: [			newClass setTraitComposition: oldClass traitComposition copyTraitExpression ].		oldClass class hasTraitComposition ifTrue: [			newClass class setTraitComposition: oldClass class traitComposition copyTraitExpression ].				self recordClass: oldClass replacedBy: newClass.	].	(oldClass == nil or:[oldClass isObsolete not]) 		ifTrue:[newSuper addSubclass: newClass]		ifFalse:[newSuper addObsoleteSubclass: newClass].	^newClass! !!ClassBuilder methodsFor: 'as yet unclassified'!privateNewSubclassOf: newSuper from: oldClass	"Create a new meta and non-meta subclass of newSuper using oldClass as template"	"WARNING: This method does not preserve the superclass/subclass invariant!!"	| newSuperMeta oldMeta newMeta |	oldClass ifNil:[^self privateNewSubclassOf: newSuper].	newSuperMeta _ newSuper ifNil:[Class] ifNotNil:[newSuper class].	oldMeta _ oldClass class.	newMeta _ oldMeta clone.	newMeta 		superclass: newSuperMeta		methodDictionary: "Method"Dictionary new		instanceSize: oldMeta instSize		format: oldMeta format;		setInstVarNames: oldMeta instVarNames;		organization: oldMeta organization.	"Recompile the meta class"	oldMeta hasMethods 		ifTrue:[newMeta compileAllFrom: oldMeta].	"Record the meta class change"	self recordClass: oldMeta replacedBy: newMeta.	"And create a new instance"	^newMeta adoptInstance: oldClass from: oldMeta! !!ClassBuilder methodsFor: 'as yet unclassified'!reshapeClass: oldClass toSuper: newSuper	"Reshape the given class to the new super class. Recompile all the methods in the newly created class. Answer the new class."	| instVars |	instVars _ instVarMap at: oldClass name ifAbsent:[oldClass instVarNames].	^self newSubclassOf: newSuper 			type: oldClass typeOfClass 			instanceVariables: instVars 			from: oldClass! !!ClassDescription methodsFor: 'as yet unclassified'!classVersion	"Default.  Any class may return a later version to inform readers that use ReferenceStream.  8/17/96 tk"	"This method allows you to distinguish between class versions when the shape of the class 	hasn't changed (when there's no change in the instVar names).	In the conversion methods you usually can tell by the inst var names 	what old version you have. In a few cases, though, the same inst var 	names were kept but their interpretation changed (like in the layoutFrame).	By changing the class version when you keep the same instVars you can 	warn older and newer images that they have to convert."	^ 0! !!ClassDescription methodsFor: 'as yet unclassified'!obsolete	"Make the receiver obsolete."	superclass removeSubclass: self.	self organization: nil.	super obsolete.! !!ClassDescription methodsFor: 'as yet unclassified'!removeSelector: selector 	"Remove the message whose selector is given from the method 	dictionary of the receiver, if it is there. Answer nil otherwise."		| priorMethod priorProtocol | 	priorMethod _ self compiledMethodAt: selector ifAbsent: [^ nil].	priorProtocol _ self whichCategoryIncludesSelector: selector.	SystemChangeNotifier uniqueInstance		doSilently: [self organization removeElement: selector ].	super removeSelector: selector.	SystemChangeNotifier uniqueInstance 			methodRemoved: priorMethod selector: selector inProtocol: priorProtocol class: self.! !!ClassDescription methodsFor: 'as yet unclassified'!updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil	| currentCategory effectiveCategory sel changedCategories composition |	changedCategories _ IdentitySet new.	composition := self hasTraitComposition		ifTrue: [self traitComposition]		ifFalse: [TraitComposition new].	(composition methodDescriptionsForSelector: aSymbol) do: [:each |		sel _ each selector.		(self includesLocalSelector: sel) ifFalse: [			currentCategory _ self organization categoryOfElement: sel.			effectiveCategory _ each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.			effectiveCategory isNil ifTrue: [				currentCategory ifNotNil: [changedCategories add: currentCategory].				self organization removeElement: sel.			] ifFalse: [				((currentCategory isNil or: [currentCategory == ClassOrganizer ambiguous or: [currentCategory == oldCategoryOrNil]]) and: [currentCategory ~~ effectiveCategory]) ifTrue: [					currentCategory ifNotNil: [changedCategories add: currentCategory].					self organization 						classify: sel 						under: effectiveCategory						suppressIfDefault: false]]]].	^ changedCategories! !!ClassDescription methodsFor: 'as yet unclassified'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	(self includesSelector: aSelector)		ifTrue: [^ self organization categoryOfElement: aSelector]		ifFalse: [^nil]! !!Class methodsFor: 'as yet unclassified'!classPool: aDictionary	classPool _ aDictionary! !!Class methodsFor: 'as yet unclassified'!copy 	| newClass |	newClass _ self class copy new		superclass: superclass		methodDict: self methodDict copy		instanceSize: self instSize		format: format		name: name		organization: self organization copy		instVarNames: instanceVariables copy		classPool: classPool copy		sharedPools: sharedPools.	Class instSize+1 to: self class instSize do:		[:offset | newClass instVarAt: offset put: (self instVarAt: offset)].	^ newClass! !!Class methodsFor: 'as yet unclassified'!deactivate	"A remnant from the 3.3a modules work, retained . Does nothing, but may be overridden in Metaclasses."! !!Class methodsFor: 'as yet unclassified'!isSystemDefined	"Answer true if the receiver is a system-defined class, and not a UniClass (an instance-specific lightweight class)"	^ self == self officialClass! !!Class methodsFor: 'as yet unclassified'!obsolete	"Change the receiver and all of its subclasses to an obsolete class."	self == Object 		ifTrue: [^self error: 'Object is NOT obsolete'].	self setName: 'AnObsolete' , self name.	Object class instSize + 1 to: self class instSize do:		[:i | self instVarAt: i put: nil]. "Store nil over class instVars."	self classPool: nil.	self sharedPools: nil.	self class obsolete.	super obsolete.! !!Class methodsFor: 'as yet unclassified'!officialClass	"I am not a UniClass.  (See Player officialClass).  Return the class you use to make new subclasses."	^ self! !!Class methodsFor: 'as yet unclassified'!removeFromSystem	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."	self removeFromSystem: true.! !!Class methodsFor: 'as yet unclassified'!removeFromSystem: logged	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."		"keep the class name and category for triggering the system change message. If we wait to long, then we get obsolete information which is not what we want."	"tell class to deactivate and unload itself-- two separate events in the module system"	self deactivate; unload.	self superclass ifNotNil:		["If we have no superclass there's nothing to be remembered"		self superclass addObsoleteSubclass: self].	self environment forgetClass: self logged: logged.	self obsolete.! !!Class methodsFor: 'as yet unclassified'!sharedPools: aCollection	sharedPools _ aCollection! !!Class methodsFor: 'as yet unclassified'!superclass: sup methodDict: md instanceSize: is format: ft name: nm organization: org instVarNames: nilOrArray classPool: pool sharedPools: poolSet 	"Answer an instance of me, a new class, using the arguments of the 	message as the needed information.	Must only be sent to a new instance; else we would need Object flushCache."	superclass := sup.	methodDict := md.	instanceSize := is.	format := ft.	name := nm.	instanceVariables := nilOrArray.	classPool := pool.	sharedPools := poolSet.	self organization: org.! !!Class methodsFor: 'as yet unclassified'!unload	"Sent when a the class is removed.  Does nothing, but may be overridden by (class-side) subclasses."! !!Class methodsFor: 'as yet unclassified'!variableByteSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable byte-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableByteSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!variableSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable pointer variables."	^(ClassBuilder new)		superclass: self		variableSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!variableWordSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable word-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableWordSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!weakSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have weak indexable pointer variables."	^(ClassBuilder new)		superclass: self		weakSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!AppLauncher class methodsFor: 'as yet unclassified'!openAboutHuemul	| dlg logo |	logo := GdkPixbuf fromFile: 'Huemul.jpg'.	dlg := GtkAboutDialog new.	dlg		aboutDialogName: 'Huemul Smalltalk';		version: '0.8';		license: (StandardFileStream readOnlyFileNamed: 'LICENSE') upToEnd;		website: 'http://www.guillermomolina.com.ar/huemul';		comments: 'This is Huemul Smalltalk';		authors: {'Guillermo Adrian Molina'};		logo: logo.	dlg runAndDestroy! !!AppLauncher class methodsFor: 'as yet unclassified'!openWorkspace	^ Workspace open! !!Application class methodsFor: 'as yet unclassified'!startUp	^ self new startUp.! !!Application class methodsFor: 'as yet unclassified'!startUpWithArguments: arguments	| application |	application := self new.	application arguments: arguments.	^ application startUp.! !!Behavior class methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return false since zapping the method dictionary of Behavior class or its subclasses will cause the system to fail."	^false! !!ClassBrowser class methodsFor: 'as yet unclassified'!defaultSize	^ 640@480.! !!ClassBrowser class methodsFor: 'as yet unclassified'!title	^'Class browser'! !!ClassFinder class methodsFor: 'as yet unclassified'!defaultSize	^ 200@300.! !!ClassFinder class methodsFor: 'as yet unclassified'!title	^'Class finder'! !!CompiledMethod methodsFor: 'as yet unclassified'!hasLiteral: literal	"Answer whether the receiver references the argument, literal."	literals ifNil: [ ^false ].	^ literals hasLiteral: literal.! !!CompiledMethod methodsFor: 'as yet unclassified'!sourcePointer	"Answer the integer which can be used to find the source file and position for this method.	Not sources yet"	^ 0! !!CompiledMethodWithNode class methodsFor: 'as yet unclassified'!method: aCompiledMethod node: aMethodNode	^ self new method: aCompiledMethod; node: aMethodNode.! !!Compiler methodsFor: 'as yet unclassified'!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into a method. In other words, if receiver is not nil, then the text can refer to instance variables of that receiver (the Inspector uses this). If aContext is not nil, the text can refer to temporaries in that context (the Debugger uses this). If aRequestor is not nil, then it will receive a notify:at: message before the attempt to evaluate is aborted. Finally, the compiled method is directly invoked without modifying the receiving-class."	"| methodNode method value |	  	(Preferences compileUseNewCompiler or: 			[aContext ifNotNil: [aContext method isClosureCompiled] ifNil: [false]]) ifTrue: 				[^ self evaluate2: textOrStream 					    in: aContext 					    to: receiver 					    notifying: aRequestor 					    ifFail: failBlock 					    logged: logFlag].		class := (aContext isNil 		ifTrue: [ receiver ] 		ifFalse: [ aContext receiver ])			class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode := self 		translate: sourceStream		noPattern: true 		ifFail: [ ^ failBlock value ].	method := methodNode generate.	self interactive		ifTrue: [ method := method copyWithTempNames: methodNode tempNames ].	value := receiver		executeMethod: method 		withArgs: (context isNil			ifTrue: [ #() ]			ifFalse: [ Array with: aContext ]).	logFlag 		ifTrue: [ SystemChangeNotifier uniqueInstance evaluated: sourceStream contents context: aContext ].	^ value."	| string block |	string _ textOrStream readStream upToEnd.	block := self compileDoIt: string in: aContext to: receiver notifying: aRequestor ifFail: [^ failBlock value] log: logFlag.	^ block value! !!Exception methodsFor: 'as yet unclassified'!messageText	messageText ifNil: [ ^ self class name asString ].	^messageText! !!Exception methodsFor: 'as yet unclassified'!receiver	^ self signalerContext receiver! !!ExternalFunctionError methodsFor: 'as yet unclassified'!functionName	"Answer the function name that was beiing used."	^functionName! !!ExternalFunctionError methodsFor: 'as yet unclassified'!functionName: argument	"Specify the function name that was beiing used."	functionName := argument! !!ExternalFunctionError class methodsFor: 'as yet unclassified'!functionName: argument	^self new functionName: argument; yourself! !!ExternalObject methodsFor: 'as yet unclassified'!= anObject 	(anObject isKindOf: self class)		ifTrue: [^ anObject handle = self handle]		ifFalse: [^ false]! !!ExternalObject methodsFor: 'as yet unclassified'!beNull	^ handle beNull.! !!ExternalObject methodsFor: 'as yet unclassified'!finalize		self free.	self unregister.! !!ExternalObject methodsFor: 'as yet unclassified'!free	"Should override this"! !!ExternalObject methodsFor: 'as yet unclassified'!initialize	handle := self class defaultHandlerClass new.	self register.! !!ExternalObject methodsFor: 'as yet unclassified'!isNull	^ self handle isNull.! !!ExternalObject methodsFor: 'as yet unclassified'!register	Registry add: self.! !!ExternalObject methodsFor: 'as yet unclassified'!unregister		Registry remove: self ifAbsent:[  ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!addSymbol: anExternalSymbol	^ symbolCache at: anExternalSymbol name put: anExternalSymbol.! !!DynamicLibrary methodsFor: 'as yet unclassified'!bindSymbol: anExternalSymbol	^ self primitiveBindSymbol: anExternalSymbol.! !!DynamicLibrary methodsFor: 'as yet unclassified'!cDeclFunctionNamed: functionName	^ symbolCache at: functionName ifAbsent: [ self error: 'You must initialize the function before using it' ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!close		handle isNull ifFalse: [ 		self primitiveClose		handle beNull.	].! !!DynamicLibrary methodsFor: 'as yet unclassified'!initialize	super initialize.	symbolCache := Dictionary new.! !!DynamicLibrary methodsFor: 'as yet unclassified'!initializeCDeclFunctionNamed: functionName returnType: retType argTypes: argTypesArray	^ symbolCache at: functionName put: 			(CDeclFunction name: functionName library: self  returnType: retType argTypes: argTypesArray)! !!DynamicLibrary methodsFor: 'as yet unclassified'!initializeLibraryDataNamed: symbolName type: type	^ symbolCache at: symbolName put: (LibraryData name: symbolName library: self  type: type)! !!DynamicLibrary methodsFor: 'as yet unclassified'!libraryDataNamed: symbolName	^ symbolCache at: symbolName ifAbsent: [ self error: 'You must initialize the symbol before using it' ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!name	^name! !!DynamicLibrary methodsFor: 'as yet unclassified'!name: aName	name := aName.! !!DynamicLibrary methodsFor: 'as yet unclassified'!nativeFunctionNamed: functionName	^ symbolCache at: functionName ifAbsent: [ 		symbolCache at: functionName put: (NativeFunction name: functionName library: self)	].! !!DynamicLibrary methodsFor: 'as yet unclassified'!open		handle isNull ifTrue: [ self primitiveOpen ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveBindSymbol: anExternalSymbol	"Primitive. Find the given symbol in the library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 203>	^ anExternalSymbol throwNotKnownError.! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveClose	"Primitive. Close the given library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 202>! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveOpen	"Primitive. Open the given library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 198>	self primitiveFailed.! !!DynamicLibrary methodsFor: 'as yet unclassified'!printOn: aStream	aStream nextPutAll: self name.! !!DynamicLibrary methodsFor: 'as yet unclassified'!symbolNamed: symbolName	^ symbolCache at: symbolName ifAbsent: [ self error: 'You must initialize the symbol before using it' ]! !!Executable methodsFor: 'as yet unclassified'!name	^ Utilities executableName ! !!Executable methodsFor: 'as yet unclassified'!primitiveSmallIntegerAdd: receiver with: argument	^ (self nativeFunctionNamed: #primitiveSmallIntegerAdd) invokeReceiver: receiver with: argument.! !!ExternalBuffer methodsFor: 'as yet unclassified'!asByteArray	| array |	size ifNil: [ ^ self class throwTypeConvertionError ].	array := ByteArray new: self basicSize.	self storeInto: array.	^ array	! !!ExternalBuffer methodsFor: 'as yet unclassified'!atAllPut: constant	^ LibC6 default memSet: self constant: constant count: self size.! !!ExternalBuffer methodsFor: 'as yet unclassified'!atAllPutZero	^ self atAllPut: 0.! !!ExternalBuffer methodsFor: 'as yet unclassified'!basicSize	^ size.! !!ExternalBuffer methodsFor: 'as yet unclassified'!byteAt: index	<primitive: 190>	index isNumber		ifTrue: [self errorSubscriptBounds: index]		ifFalse: [self errorNonIntegerIndex].! !!ExternalBuffer methodsFor: 'as yet unclassified'!byteAt: index put: value	<primitive: 191>	index isNumber		ifTrue: [self errorSubscriptBounds: index]		ifFalse: [self errorNonIntegerIndex].! !!ExternalBuffer methodsFor: 'as yet unclassified'!free		handle isNull ifFalse: [ 		LibC6 default free: self.		self beNull.	]! !!ExternalBuffer methodsFor: 'as yet unclassified'!loadFrom: aByteArray	<primitive: 199>	self primitiveFailed.! !!ExternalBuffer methodsFor: 'as yet unclassified'!size	^ self basicSize.! !!ExternalBuffer methodsFor: 'as yet unclassified'!size: anInteger	size := anInteger.! !!ExternalBuffer methodsFor: 'as yet unclassified'!storeInto: aByteArray	<primitive: 218>	^ self class throwTypeConvertionError.! !!AsciiZ methodsFor: 'as yet unclassified'!asString	^ handle toString.! !!AsciiZ methodsFor: 'as yet unclassified'!asString2	| calcSize string |	size ifNil: [ ^ self class throwTypeConvertionError ].	calcSize := self strlen.	calcSize >= self size ifTrue: [ ^ self class throwTypeConvertionError ].	string := String new: calcSize.	self storeInto: string.	^ string! !!AsciiZ methodsFor: 'as yet unclassified'!loadFrom: aString		super loadFrom: aString.	self byteAt: (aString size + 1) put: 0.! !!AsciiZ methodsFor: 'as yet unclassified'!strlen	^ LibC6 default strLen: self.! !!ExternalFunction methodsFor: 'as yet unclassified'!library	^ library! !!ExternalFunction methodsFor: 'as yet unclassified'!library: aLibrary	library := aLibrary! !!ExternalFunction methodsFor: 'as yet unclassified'!name	^name! !!ExternalFunction methodsFor: 'as yet unclassified'!name: aName	name := aName! !!ExternalFunction methodsFor: 'as yet unclassified'!name: aName library: aLibrary	self name: aName.	self library: aLibrary! !!ExternalFunction methodsFor: 'as yet unclassified'!reload	library ifNil: [ ^ self throwNotKnownError ].	self handle: (library findFunction: self)! !!ExternalLibrary methodsFor: 'as yet unclassified'!bindFunction: function	| answer |	answer := self primitiveBindFunction: function.	answer ifNotNil: [ ^ answer ].	self open. "Library may be closed, open it and retry"	answer := self primitiveBindFunction: answer.	answer ifNotNil: [ ^ answer ].	^ function throwNotKnownError.		! !!ExternalLibrary methodsFor: 'as yet unclassified'!closeLibrary		(handle isNotNil and: [ handle isNull not ]) ifTrue: [ self primitiveClose ].	self handle: nil.	functionCache := nil.! !!ExternalLibrary methodsFor: 'as yet unclassified'!openLibrary		self primitiveOpen.	self initializeFunctionCache.! !!ExternalLibrary methodsFor: 'as yet unclassified'!primitiveBindFunction: function	"Primitive. Find the given symbol in the library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 203>	^ nil.! !!ExternalObject class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: self! !!ExternalObject class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalAddress! !!ExternalObject class methodsFor: 'as yet unclassified'!handleFromObject: anObject	^ self handleFromObject: anObject ifError: [ self throwTypeConvertionError ]! !!ExternalObject class methodsFor: 'as yet unclassified'!handleFromObject: anObject ifError: aBlock		(anObject isKindOf: ExternalObject) ifFalse: [ ^ aBlock value ].	^ anObject handle.	! !!ExternalObject class methodsFor: 'as yet unclassified'!initialize	Registry := WeakRegistry new.	Smalltalk addToShutDownList: self.! !!ExternalObject class methodsFor: 'as yet unclassified'!objectFromHandle: handle	^self objectFromHandle: handle ifError: [ self throwTypeConvertionError ]! !!ExternalObject class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; yourself! !!ExternalObject class methodsFor: 'as yet unclassified'!quit	Registry do: [ :each | each free ].	self allSubclassesDo: [ :ea | ea quit ]! !!ExternalObject class methodsFor: 'as yet unclassified'!shutDown: quitting	quitting ifTrue: [ self quit ].! !!ExternalObject class methodsFor: 'as yet unclassified'!throwTypeConvertionError	^ TypeConvertionError new signal! !!DynamicLibrary class methodsFor: 'as yet unclassified'!default	self = DynamicLibrary ifTrue: [ self error: 'Create a class to create its singleton' ].	default ifNil: [	"Represents the executable itself"		default := self new.		default name: self moduleName.		default open.	].	^ default.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!initialize	self = DynamicLibrary ifFalse: [ 		Smalltalk addToShutDownList: self	].! !!DynamicLibrary class methodsFor: 'as yet unclassified'!moduleName	self subClassResponsibility.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!resetLibrary	default := nil.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!shutDown: aBool	default ifNotNil: [ default close ].! !!Executable class methodsFor: 'as yet unclassified'!huemul	^ self default! !!Executable class methodsFor: 'as yet unclassified'!moduleName	^nil.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: ByteArray! !!ExternalBuffer class methodsFor: 'as yet unclassified'!fromByteArray: aByteArray	| anExternalBuffer |		anExternalBuffer := ExternalBuffer new: aByteArray size.	anExternalBuffer setFrom: aByteArray.	^ anExternalBuffer.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!handleFromObject: aByteArray ifError: aBlock		(aByteArray isKindOf: ByteArray) ifFalse: [ 		^ super handleFromObject: aByteArray ifError: aBlock	].	^ ( self fromByteArray: aByteArray ) handle.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!new: size	| anExternalBuffer |	"This space is allocated from the system not 	from Object Memory, you will have to give it back, 	as it is not garbage collected"	anExternalBuffer := LibC6 default malloc: (size +  10).	anExternalBuffer size: size.	^ anExternalBuffer! !!AsciiZ class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: String! !!AsciiZ class methodsFor: 'as yet unclassified'!fromString: aString	| anAsciiZ |		anAsciiZ := AsciiZ new: aString size + 1.	anAsciiZ loadFrom: aString.	^ anAsciiZ.! !!AsciiZ class methodsFor: 'as yet unclassified'!handleFromObject: aString ifError: aBlock		(aString isKindOf: String) ifFalse: [ 		^ super handleFromObject: aString ifError: aBlock	].	^ ( self fromString: aString ) handle.! !!AsciiZ class methodsFor: 'as yet unclassified'!new: size	| buffer asciiZ |	buffer := super new: size.	asciiZ := AsciiZ new handle: buffer handle.	asciiZ size: size.	asciiZ atAllPutZero.	buffer handle: ExternalAddress nullPointer.	^ asciiZ! !!AsciiZ class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; asString! !!ExternalFunction class methodsFor: 'as yet unclassified'!name: aName library: aLibrary	^self new name: aName library: aLibrary! !!ExternalLibrary class methodsFor: 'as yet unclassified'!huemul	Huemul ifNil: [	"Represents the executable itself"		Huemul := self new.		Huemul open.	].	^ Huemul.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!handle	self object ifNil: [ handle beNull ].	^ handle.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!initialize	super initialize.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!initializePointer	self handle forObject: self object.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!object	^ self objectPointer at: 1! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!object: anObject	self objectPointer at: 1 put: anObject.	self initializePointer.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!objectPointer	object ifNil: [ object := WeakArray new: 1 ].	^ object! !!ExternalArrayProxy methodsFor: 'as yet unclassified'!initializePointer	self handle forArray: self object.! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!fromObject: anObject		^ self new object: anObject; yourself! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!handleFromObject: anObject ifError: aBlock		^ ( self fromObject: anObject ) handle.! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		^ aBlock value! !!ExternalSymbol methodsFor: 'as yet unclassified'!address	handle isNull ifTrue: [ self bind ].	^ handle.! !!ExternalSymbol methodsFor: 'as yet unclassified'!bind	^ library bindSymbol: self.! !!ExternalSymbol methodsFor: 'as yet unclassified'!classFromType: aType	^ Smalltalk at: aType ifAbsent: [ self throwExternalSymbolError ].! !!ExternalSymbol methodsFor: 'as yet unclassified'!library	^ library! !!ExternalSymbol methodsFor: 'as yet unclassified'!library: aLibrary	library := aLibrary! !!ExternalSymbol methodsFor: 'as yet unclassified'!libraryName	^ library name.! !!ExternalSymbol methodsFor: 'as yet unclassified'!name	^name! !!ExternalSymbol methodsFor: 'as yet unclassified'!name: aName	name := aName! !!ExternalSymbol methodsFor: 'as yet unclassified'!name: aName library: aLibrary	self name: aName.	self library: aLibrary! !!ExternalSymbol methodsFor: 'as yet unclassified'!throwExternalSymbolError	^(ExternalSymbolError symbolName: name) signal.! !!ExternalSymbol methodsFor: 'as yet unclassified'!throwNotKnownError	^(ExternalSymbolError symbolName: name) signal.! !!ExecutableFunction methodsFor: 'as yet unclassified'!callingConventionString	self subclassResponsibility.! !!CDeclFunction methodsFor: 'as yet unclassified'!argTypes: anArrayOfTypes	argTypes := anArrayOfTypes.! !!CDeclFunction methodsFor: 'as yet unclassified'!callingConventionString	^ 'cdecl'! !!CDeclFunction methodsFor: 'as yet unclassified'!invoke	^self invokeWithArguments: #()! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1	^self invokeWithArguments: (Array with: arg1)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2	^self invokeWithArguments: (Array with: arg1 with: arg2)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4 with: arg5	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWithArguments: argArray	| argSize argHandleArray returnClass returnHandle |	argSize := argArray size.	argSize = argTypes size ifFalse: [ self throwExternalFunctionError ].	argHandleArray := Array new: argSize.	1 to: argSize do: [ :i |		| argType argClass argHandle arg |		argType := argTypes at: i.		argClass := self classFromType: argType.		arg := argArray at: i.		argHandle := argClass handleFromObject: arg.		argHandleArray at: i put: argHandle.	].	returnHandle := nil.	returnType = #Void ifFalse: [		returnClass := self classFromType: returnType.		returnHandle := returnClass defaultHandlerClass new.	].	handle isNull ifTrue: [ self bind ].	self primInvokeAnswering: returnHandle withArguments: argHandleArray.	returnType = #Void ifTrue: [ ^ nil ].	^ returnClass objectFromHandle: returnHandle.! !!CDeclFunction methodsFor: 'as yet unclassified'!primInvokeAnswering: aReturnValue withArguments: argArray	"Manually invoke the receiver, representing an external function."	<primitive: 204>	^self primitiveFailed! !!CDeclFunction methodsFor: 'as yet unclassified'!returnType: aType	returnType := aType.! !!CDeclFunction methodsFor: 'as yet unclassified'!returnType: aType argTypes: anArrayOfTypes	self returnType: aType.	self argTypes: anArrayOfTypes.! !!ExternalSymbol class methodsFor: 'as yet unclassified'!name: aName library: aLibrary	^self new name: aName library: aLibrary; bind! !!CDeclFunction class methodsFor: 'as yet unclassified'!name: aName library: aLibrary returnType: retType argTypes: argTypesArray	^self new name: aName library: aLibrary;		 returnType: retType argTypes: argTypesArray;		bind! !!ExternalSymbolError methodsFor: 'as yet unclassified'!isResumable	"Determine whether an exception is resumable."	^true! !!ExternalSymbolError methodsFor: 'as yet unclassified'!symbolName	^ symbolName! !!ExternalSymbolError methodsFor: 'as yet unclassified'!symbolName: argument	"Specify the function name that was beiing used."	symbolName := argument! !!ExternalSymbolError class methodsFor: 'as yet unclassified'!symbolName: argument	^self new symbolName: argument; yourself! !!FileDescriptor methodsFor: 'as yet unclassified'!close		self fileDescriptor > 2 ifTrue: [ 		LibC6 default close: self.		self fileDescriptor: -1.	]! !!FileDescriptor methodsFor: 'as yet unclassified'!fileDescriptor	^ SignedInteger objectFromHandle: handle. ! !!FileDescriptor methodsFor: 'as yet unclassified'!fileDescriptor: anInteger	handle := SignedInteger handleFromObject: anInteger. ! !!FileDescriptor methodsFor: 'as yet unclassified'!free		self close.! !!FileDescriptor methodsFor: 'as yet unclassified'!movePosition: offset"relative to actual position"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_CUR' ).	! !!FileDescriptor methodsFor: 'as yet unclassified'!position	^ self movePosition: 0.	! !!FileDescriptor methodsFor: 'as yet unclassified'!position: offset"absolute position"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_SET' ).! !!FileDescriptor methodsFor: 'as yet unclassified'!positionFromEnd: offset"relative to end of file"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_END' ).	! !!FileDescriptor methodsFor: 'as yet unclassified'!read: size	| retValue buffer |	buffer := ExternalBuffer new: size.	retValue := self readBuffer: buffer size: size.	! !!FileDescriptor methodsFor: 'as yet unclassified'!readBuffer: buffer size: size	^ LibC6 default read: self buffer: buffer size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!readString: aString	^ LibC6 default read: self string: aString size: aString size! !!FileDescriptor methodsFor: 'as yet unclassified'!readString: aString size: size	| internalSize |	internalSize := size.	aString size < size ifTrue: [ internalSize := aString size ].	^ LibC6 default read: self string: aString size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!size	| position size |	position := self position.	size := self positionFromEnd: 0.	self position: position.	^ size	! !!FileDescriptor methodsFor: 'as yet unclassified'!writeBuffer: buffer size: size	^ LibC6 default write: self buffer: buffer size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!writeString: aString	^ LibC6 default write: self string: aString size: aString size! !!FileDescriptor methodsFor: 'as yet unclassified'!writeString: aString size: size	| internalSize |	internalSize := size.	aString size < size ifTrue: [ internalSize := aString size ].	^ LibC6 default write: self string: aString size: size! !!FileDescriptor class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalValue! !!FileDescriptor class methodsFor: 'as yet unclassified'!initialize	self initializeStandardDescriptors! !!FileDescriptor class methodsFor: 'as yet unclassified'!initializeStandardDescriptors	StandardDescriptors := Dictionary new.	StandardDescriptors at: #stdout put: (self newFileDescriptor: 0).	StandardDescriptors at: #stdin put: (self newFileDescriptor: 1).	StandardDescriptors at: #stderr put: (self newFileDescriptor: 2).! !!FileDescriptor class methodsFor: 'as yet unclassified'!newFileDescriptor: anInteger	^ self new fileDescriptor: anInteger; yourself.! !!FileDescriptor class methodsFor: 'as yet unclassified'!standardDescriptors	^ StandardDescriptors! !!FileDescriptor class methodsFor: 'as yet unclassified'!stderr	^ StandardDescriptors at: #stderr.! !!FileDescriptor class methodsFor: 'as yet unclassified'!stdin	^ StandardDescriptors at: #stdin.! !!FileDescriptor class methodsFor: 'as yet unclassified'!stdout	^ StandardDescriptors at: #stdout.! !!FileStream methodsFor: 'as yet unclassified'!atEnd	"Answer true if the current position is >= the end of file position.	 1/31/96 sw: subclassResponsibility"	self subclassResponsibility! !!FileStream class methodsFor: 'as yet unclassified'!fileDoesNotExistUserHandling: fullFileName	(GtkMessageDialog question: fullFileName, ' does not exist, create it?') = #yes		ifTrue: [ ^ self new open: fullFileName forWrite: true ].! !!FileStream class methodsFor: 'as yet unclassified'!fileExistsUserHandling: fullFileName	(GtkMessageDialog question: fullFileName, ' exist, overwrite it?') = #yes		ifTrue: [ ^ self new openForOverwrite: fullFileName ].! !!FileStream class methodsFor: 'as yet unclassified'!readOnlyFileDoesNotExistUserHandling: fullFileName	GtkMessageDialog error: fullFileName, ' does not exist'! !!FileDoesNotExistException methodsFor: 'as yet unclassified'!defaultAction	"The default action taken if the exception is signaled."	^self readOnly		ifTrue: [FileStream readOnlyFileDoesNotExistUserHandling: self fileName]		ifFalse: [FileStream fileDoesNotExistUserHandling: self fileName]! !!GIRBuilder methodsFor: 'as yet unclassified'!compiledMethod	| bytecodes |	bytecodes := self bytecodes.	bytecodes ifNil: [ ^ nil ].	^ CompiledMethod new		primitive: 0;		numArgs: self numArgs;		numTemps: self numTemps;		literals: self literals;		relocationInfo: self relocationInfo;		bytecodes: bytecodes;		debugInfo: debugInfo;		source: source;		relocate.! !!GPointer methodsFor: 'as yet unclassified'!initialize	handle := self class defaultHandlerClass new.! !!GPointer class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalAddress! !!GPointer class methodsFor: 'as yet unclassified'!handle: aByteArray	^self basicNew handle: aByteArray; yourself! !!GObject class methodsFor: 'as yet unclassified'!handleFromObject: object	^ object handle.	! !!Gtk methodsFor: 'as yet unclassified'!initialize	self initializeGtkLibrary.	self startMainLoop.! !!Gtk class methodsFor: 'as yet unclassified'!main

Gtk default startMainLoop.! !!Gtk class methodsFor: 'as yet unclassified'!shutDown: quiting	"Quits the Gtk main loop"	Default ifNotNil: [		Default quitMainLoop.		Default close.		Default := nil.	].! !!GtkDemoStockIds methodsFor: 'as yet unclassified'!initialize	| model tree |	model := GtkListStore new: {String. String. String. String}.	GtkStockItem allStocks do: [ :ea |		ea ifNotNil: [			model append: {				ea stockId asGtkStockId.				ea stockId.				ea label.				Gtk acceleratorName: ea keyval asCharacter modifier: ea modifier}]].	tree := GtkTreeView model: model.	self createFirstColumn: tree.	tree appendColumns: {		GtkTreeViewColumn title: 'Label' text: 2.		GtkTreeViewColumn title: 'Accel' text: 3.		GtkTreeViewColumn title: 'ID' text: 0}.	tree selection when: #changed send: #onItemChanged: to: self withArgumentsFirst: {tree}.			self container: (GtkHBox spacing: 5).	self container		packStart: (GtkScrolledWindow withChild: tree);		packEnd: self createInfoFrame expand: false fill: false! !!GtkDemoStockIds methodsFor: 'as yet unclassified'!onItemChanged: aTreeView	aTreeView selectedRow in: [:row |		idLabel label: row first.		nameLabel label: '#', row second.		accelLabel label: row third.		iconImage stock: row second iconSize: #dialog]! !!InMidstOfFileinNotification methodsFor: 'as yet unclassified'!defaultAction	^ self resume: false! !!LibC methodsFor: 'as yet unclassified'!closeLibrary	cLibrary closeLibrary.	cLibrary := nil.! !!LibC methodsFor: 'as yet unclassified'!initializeCLibrary	cLibrary := ExternalLibrary new.	cLibrary name: 'libc.so.6'.	cLibrary openLibrary.! !!LibC class methodsFor: 'as yet unclassified'!shutDown: quiting	"Quits the Gtk main loop"	self default closeLibrary.	Default := nil.! !!LibC6 methodsFor: 'as yet unclassified'!close: fd	| retValue |	retValue := ( self cDeclFunctionNamed: #close ) invokeWith: fd.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #close ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!errno	^ (self libraryDataNamed: #errno) value.	! !!LibC6 methodsFor: 'as yet unclassified'!errno: errno	(self libraryDataNamed: #errno) value: errno.	! !!LibC6 methodsFor: 'as yet unclassified'!free: anExternalBuffer	( self cDeclFunctionNamed: #free ) invokeWith: anExternalBuffer.	! !!LibC6 methodsFor: 'as yet unclassified'!getCurrentDirName	| retValue |	[ retValue := ( self cDeclFunctionNamed: 'get_current_dir_name' asSymbol ) invoke ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: 'get_current_dir_name' asSymbol ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!getEnv: envVariable	^ ( self cDeclFunctionNamed: #getenv ) invokeWith: envVariable.! !!LibC6 methodsFor: 'as yet unclassified'!getpid	^ (self cDeclFunctionNamed: #getpid) invoke.	! !!LibC6 methodsFor: 'as yet unclassified'!initialize	super initialize.	self initializeUniStd.	self initializeStdLib.	self initializeString.	self initializeFCntl.	self initializeStdIO.	self initializeErrNO.! !!LibC6 methodsFor: 'as yet unclassified'!initializeErrNO	self initializeLibraryDataNamed: #errno type: #SignedInteger.! !!LibC6 methodsFor: 'as yet unclassified'!initializeFCntl	self initializeCDeclFunctionNamed: #open returnType: #FileDescriptor argTypes: #( AsciiZ SignedInteger UnsignedInteger ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeStdIO	self initializeCDeclFunctionNamed: #printf  returnType: #SignedInteger argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: #perror  returnType: #Void argTypes: #( AsciiZ  ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeStdLib	self initializeCDeclFunctionNamed: #malloc  returnType: #ExternalBuffer argTypes: #( UnsignedInteger  ).	self initializeCDeclFunctionNamed: #free  returnType: #Void argTypes: #( ExternalBuffer  ).	self initializeCDeclFunctionNamed: #getenv  returnType: #AsciiZ argTypes: #( AsciiZ ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeString	self initializeCDeclFunctionNamed: #strlen returnType: #UnsignedInteger argTypes: #( AsciiZ ).	self initializeCDeclFunctionNamed: #strcat returnType: #AsciiZ argTypes: #( AsciiZ AsciiZ ).	self initializeCDeclFunctionNamed: #strcpy returnType: #AsciiZ argTypes: #( AsciiZ AsciiZ ).	self initializeCDeclFunctionNamed: #strerror returnType: #ReadOnlyAsciiZ argTypes: #( SignedInteger ).	self initializeCDeclFunctionNamed: #memset returnType: #ExternalBuffer argTypes: #( ExternalBuffer SignedInteger  UnsignedInteger ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeUniStd	self initializeCDeclFunctionNamed: #getpid  returnType: #UnsignedInteger argTypes: #().	self initializeCDeclFunctionNamed: 'get_current_dir_name' asSymbol  returnType: #AsciiZ argTypes: #().	self initializeCDeclFunctionNamed: #close  returnType: #SignedInteger argTypes: #( FileDescriptor ).	self initializeCDeclFunctionNamed: #lseek  returnType: #UnsignedInteger argTypes: #( FileDescriptor UnsignedInteger SignedInteger ).	self initializeCDeclFunctionNamed: #read  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalBuffer UnsignedInteger ).	self initializeCDeclFunctionNamed: #write  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalBuffer UnsignedInteger )."Redefinition of read for Strings"	symbolCache at: #readString put: (CDeclFunction name: #read library: self  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalArrayProxy UnsignedInteger ) )."Redefinition of write for Strings"	symbolCache at: #writeString put: (CDeclFunction name: #write library: self  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalArrayProxy UnsignedInteger ) ).! !!LibC6 methodsFor: 'as yet unclassified'!lseek: fileDescriptor offset: offset whence: whence	| returnValue |	returnValue := (self cDeclFunctionNamed: #lseek) invokeWith: fileDescriptor with: offset with: whence.	returnValue < 0 ifTrue: [		self throwErrorForExternalFunctionNamed: #lseek.		^ nil.	].	^ returnValue.	! !!LibC6 methodsFor: 'as yet unclassified'!malloc: size	| retValue |	[ retValue := ( self cDeclFunctionNamed: #malloc ) invokeWith: size ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: #malloc withMessage: 'can not allocate memory' ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!memSet: buffer constant: c count: n	^ (self cDeclFunctionNamed: #memset) invokeWith: buffer with: c with: n.	! !!LibC6 methodsFor: 'as yet unclassified'!open: path flags: flags	^ self open: path flags: flags mode: 8r644	! !!LibC6 methodsFor: 'as yet unclassified'!open: path flags: flags mode: mode	| fileDescriptor |	fileDescriptor := (self cDeclFunctionNamed: #open) invokeWith: path with: flags with: mode.	fileDescriptor fileDescriptor < 0 ifTrue: [		self throwErrorForExternalFunctionNamed: #open.		^ nil.	].	^ fileDescriptor.	! !!LibC6 methodsFor: 'as yet unclassified'!perror: aString	( self cDeclFunctionNamed: #perror ) invokeWith: aString.	! !!LibC6 methodsFor: 'as yet unclassified'!printf: aString	^ ( self cDeclFunctionNamed: #printf ) invokeWith: aString.	! !!LibC6 methodsFor: 'as yet unclassified'!read: fd buffer: buffer size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #read ) invokeWith: fd with: buffer with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #read ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!read: fd string: aString size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #readString ) invokeWith: fd with: aString with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #readString ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!strCat: destString with: sourceString	^ ( self cDeclFunctionNamed: #strcat ) invokeWith: destString with: sourceString.	! !!LibC6 methodsFor: 'as yet unclassified'!strCpy: destString with: sourceString	^ ( self cDeclFunctionNamed: #strcpy ) invokeWith: destString with: sourceString.	! !!LibC6 methodsFor: 'as yet unclassified'!strError: errno	| retValue |	[ retValue := ( self cDeclFunctionNamed: #strerror ) invokeWith: errno ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: #strerror ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!strLen: string	^ ( self cDeclFunctionNamed: #strlen ) invokeWith: string	! !!LibC6 methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName	^ self throwErrorForExternalFunctionNamed: functionName withMessage: (self strError: self errno).	! !!LibC6 methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName withMessage: aString	| error |	error := ExternalFunctionError functionName: functionName.	error messageText: aString.	^ error signal.	! !!LibC6 methodsFor: 'as yet unclassified'!valueForLSeekDirectiveNamed: aString	^ LSeekDirectives at: aString asSymbol.	! !!LibC6 methodsFor: 'as yet unclassified'!valueForOpenFlagNamed: aString	^ OpenFlags at: aString asSymbol.	! !!LibC6 methodsFor: 'as yet unclassified'!write: fd buffer: buffer size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #write ) invokeWith: fd with: buffer with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #write ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!write: fd string: aString size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #writeString ) invokeWith: fd with: aString with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #writeString ].	^ retValue.	! !!LibC6 class methodsFor: 'as yet unclassified'!initialize	self initializeOpenFlags.	self initializeLSeekDirectives.! !!LibC6 class methodsFor: 'as yet unclassified'!initializeLSeekDirectives	| lSeekDirectives |		lSeekDirectives := Dictionary new.	lSeekDirectives at: 'SEEK_SET' put: 0.	lSeekDirectives at: 'SEEK_CUR' put: 1.	lSeekDirectives at: 'SEEK_END' put: 2.	LSeekDirectives := lSeekDirectives! !!LibC6 class methodsFor: 'as yet unclassified'!initializeOpenFlags	| flagArray openFlags |		flagArray := #( 		('O_RDONLY'		0)		('O_WRONLY'		8r1)		('O_RDWR'		8r2)		('O_CREAT'		8r100)			('O_EXCL'			8r200)			('O_NOCTTY'		8r400)			('O_TRUNC'		8r1000)			('O_APPEND'		8r2000)		('O_NONBLOCK'	8r4000)		('O_SYNC'		8r10000)		('O_ASYNC'		8r20000)	).	openFlags := Dictionary new.	flagArray do: [ :i |		openFlags at: i first asSymbol put: i second	].	OpenFlags := openFlags! !!LibC6 class methodsFor: 'as yet unclassified'!moduleName	^ 'libc.so.6'.! !!LibExample methodsFor: 'as yet unclassified'!getpid	^ GETPID invoke! !!LibExample class methodsFor: 'as yet unclassified'!getpid	^ GETPID! !!LibExample class methodsFor: 'as yet unclassified'!initialize	GETPID := CDeclFunction name: 'getpid' libraryNamed: 'libc.so.6' returnType: #UnsignedInteger argTypes: #().! !!LibReadLine methodsFor: 'as yet unclassified'!addHistory: aString	( self cDeclFunctionNamed: 'add_history' asSymbol ) invokeWith: aString.! !!LibReadLine methodsFor: 'as yet unclassified'!initialize	super initialize.	self initializeCDeclFunctionNamed: #readline  returnType: #AsciiZ argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'add_history' asSymbol returnType: #Void argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'read_history' asSymbol returnType: #SignedInteger argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'write_history' asSymbol returnType: #SignedInteger argTypes: #( AsciiZ  ).! !!LibReadLine methodsFor: 'as yet unclassified'!readHistory: aFileName	| errno |	errno := ( self cDeclFunctionNamed: 'read_history' asSymbol ) invokeWith: aFileName.	errno = 0 ifFalse: [ self throwErrorForExternalFunctionNamed: 'read_history' asSymbol errno: errno ].	^ errno.! !!LibReadLine methodsFor: 'as yet unclassified'!readline: prompt	^ ( self cDeclFunctionNamed: #readline ) invokeWith: prompt.! !!LibReadLine methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName errno: errno	| error |	error := ExternalFunctionError functionName: functionName.	error messageText: (LibC6 default strError: errno).	^ error signal.! !!LibReadLine methodsFor: 'as yet unclassified'!writeHistory: aFileName	| errno |	errno := ( self cDeclFunctionNamed: 'write_history' asSymbol ) invokeWith: aFileName.	errno = 0 ifFalse: [ self throwErrorForExternalFunctionNamed: 'write_history' asSymbol errno: errno ].	^ errno.! !!LibReadLine class methodsFor: 'as yet unclassified'!moduleName	^ 'libreadline.so.5'.! !!LibraryData methodsFor: 'as yet unclassified'!primitiveGetValue: valueHandle	<primitive: 216>	^self primitiveFailed! !!LibraryData methodsFor: 'as yet unclassified'!primitiveSetValue: valueHandle	<primitive: 217>	^self primitiveFailed! !!LibraryData methodsFor: 'as yet unclassified'!type	^ type.! !!LibraryData methodsFor: 'as yet unclassified'!type: aType	type := aType.! !!LibraryData methodsFor: 'as yet unclassified'!value	| valueClass valueHandle |	valueClass := self classFromType: type.	valueHandle := valueClass defaultHandlerClass new.	handle isNull ifTrue: [ self bind ].	self primitiveGetValue: valueHandle.	^ valueClass objectFromHandle: valueHandle.! !!LibraryData methodsFor: 'as yet unclassified'!value: aValue	| argHandle argClass |	argClass := self classFromType: type.	argHandle := argClass handleFromObject: aValue.	handle isNull ifTrue: [ self bind ].	self primitiveSetValue: argHandle! !!LibraryData class methodsFor: 'as yet unclassified'!name: aName library: aLibrary type: type	^self new name: aName library: aLibrary;		type: type;		bind! !!Metaclass methodsFor: 'as yet unclassified'!addObsoleteSubclass: aClass	"Do nothing."! !!Metaclass methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return true if it is safe to zap the method dictionary on #obsolete"	thisClass == nil		ifTrue:[^true]		ifFalse:[^thisClass canZapMethodDictionary]! !!Metaclass methodsFor: 'as yet unclassified'!isSystemDefined	"Answer false if I am a UniClass (an instance-specific lightweight class)"	^ true! !!NativeFunction methodsFor: 'as yet unclassified'!callingConventionString	^ 'native'! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver	^self invokeReceiver: receiver withArguments: #()! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1	^self invokeReceiver: receiver withArguments: (Array with: arg1)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4 with: arg5	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver withArguments: argArray	handle isNull ifTrue: [ self bind ].	^ self primInvokeReceiver: receiver withArguments: argArray.! !!NativeFunction methodsFor: 'as yet unclassified'!primInvokeReceiver: receiver withArguments: argArray	"Manually invoke the receiver, representing an native function."	<primitive: 197>	^self primitiveFailed! !!ObjectTest methodsFor: 'as yet unclassified'!testBecome	"self debug: #testBecome"	"this test should that all the variables pointing to an object are pointing now to another one, and all      object pointing to the other are pointing to the object"	| pt1 pt2 pt3 |	pt1 := 0@0.	pt2 := pt1.	pt3 := 100@100.	pt1 become: pt3.	self assert: pt2 = (100@100).	self assert: pt3 = (0@0).	self assert: pt1 = (100@100).! !!ObjectTest methodsFor: 'as yet unclassified'!testBecomeForward	"self debug: #testBecomeForward"	"this test should that all the variables pointing to an object are pointing now to another one.	Not that this inverse is not true. This kind of become is called oneWayBecome in VW"	| pt1 pt2 pt3 |	pt1 := 0@0.	pt2 := pt1.	pt3 := 100@100.	pt1 becomeForward: pt3.	self assert: pt2 = (100@100).	self assert: pt3 == pt2.	self assert: pt1 = (100@100)! !!PrimitiveType class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalValue! !!PrimitiveType class methodsFor: 'as yet unclassified'!handleFromObject: anObject	^ self handleFromObject: anObject ifError: [ self throwTypeConvertionError ]! !!PrimitiveType class methodsFor: 'as yet unclassified'!handleFromObject: object ifError: aBlock	self subclassResponsibility.! !!PrimitiveType class methodsFor: 'as yet unclassified'!objectFromHandle: handle	^ self objectFromHandle: handle ifError: [  self throwTypeConvertionError ]! !!PrimitiveType class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock	self subclassResponsibility.! !!PrimitiveType class methodsFor: 'as yet unclassified'!throwTypeConvertionError	^ TypeConvertionError new signal! !!IntegerType class methodsFor: 'as yet unclassified'!handleFromObject: anInteger ifError: aBlock	| handle |		(self checkType: anInteger) ifFalse: [ ^ aBlock value ].	handle := ExternalValue new.	self store: anInteger in: handle.	^ handle.	! !!IntegerType class methodsFor: 'as yet unclassified'!isBigEndian	^  false! !!IntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	self subclassResponsibility.! !!IntegerType class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: errorBlock	| value |		value := self loadFrom: handle.	(value > self max ) ifTrue: [ ^ errorBlock value ].	^ value.! !!Process methodsFor: 'as yet unclassified'!primitiveBeInitialProcess	<primitive: 196>	self primitiveFailed! !!ProcessorScheduler methodsFor: 'as yet unclassified'!activeProcess	^ self primActiveProcess! !!ProcessorScheduler methodsFor: 'as yet unclassified'!primActiveProcess	<primitive: 195>	self primitiveFail.! !!ProcessorScheduler methodsFor: 'as yet unclassified'!startUp	| firstProcess |"	(processList isNil or: [ processList isEmpty not ]) ifTrue: [ self initialize ]."	self initialize.	firstProcess := Process new.	firstProcess name: 'Init'.	firstProcess priority: self userSchedulingPriority.	firstProcess state: #running."	firstProcess threadData: self activeThreadData."	firstProcess primitiveBeInitialProcess.! !!ReadOnlyAsciiZ methodsFor: 'as yet unclassified'!asString	^ handle toString.! !!ReadOnlyAsciiZ class methodsFor: 'as yet unclassified'!handleFromObject: aByteArray ifError: aBlock	"Can not be used as arguments"	aBlock value.! !!ReadOnlyAsciiZ class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; asString! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!addressRelativeTo: bytecodes	| functionAddress bytecodesAddress |	functionAddress := self function address asInteger.	bytecodesAddress := (ExternalAddress forArray: bytecodes ) asInteger.	^ functionAddress - bytecodesAddress - offset - 4! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!function	^ self library functionNamed: functionName.! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!functionName	^ functionName! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!functionName: aSymbol	^ functionName := aSymbol! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!library	^ Executable default! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!patch: bytecodes	self patch: bytecodes with: (self addressRelativeTo: bytecodes).! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!patch: bytecodes with: value	bytecodes longAt: (offset + 1) put: value bigEndian: false.! !!FunctionRelocation methodsFor: 'as yet unclassified'!addressRelativeTo: bytecodes	^ self primAddressRelativeTo: bytecodes! !!FunctionRelocation methodsFor: 'as yet unclassified'!primAddressRelativeTo: bytecodes	<primitive: 155>	self primitiveFail.! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!defaultLibraryClass	^ NativeLibrary! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!library 		^ self defaultLibraryClass named: libraryName! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!libraryName	^ libraryName! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!libraryName: aSymbol	^ libraryName := aSymbol! !!ExternalFunctionRelocation methodsFor: 'as yet unclassified'!defaultLibraryClass	^ ExternalLibrary2! !!SequenceableCollection methodsFor: 'as yet unclassified'!asTraitComposition	"For convenience the composition {T1. T2 ...} is the same as T1 + T2 + ..."	^self isEmpty		ifFalse: [			self size = 1				ifTrue: [self first asTraitComposition]				ifFalse: [					self copyWithoutFirst 						inject: self first						into: [:left :right | left + right]]]		ifTrue: [			TraitComposition new]! !!Array methodsFor: 'as yet unclassified'!elementsExchangeIdentityWith: otherArray	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsExchangeIdentityWith: otherArray.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!elementsForwardIdentityTo: otherArray	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsForwardIdentityTo: otherArray.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!elementsForwardIdentityTo: otherArray copyHash: copyHash	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsForwardIdentityTo: otherArray copyHash: copyHash.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!primElementsExchangeIdentityWith: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  At the same time, all pointers to the elements of otherArray are replaced by pointers to the corresponding elements of this array.  The identityHashes remain with the pointers rather than with the objects so that objects in hashed structures should still be properly indexed after the mutation."	<primitive: 128>	otherArray class == Array ifFalse: [^ self error: 'arg must be array'].	self size = otherArray size ifFalse: [^ self error: 'arrays must be same size'].	(self anySatisfy: [:obj | obj class == SmallInteger]) ifTrue: [^ self error: 'can''t become SmallIntegers'].	(otherArray anySatisfy: [:obj | obj class == SmallInteger]) ifTrue: [^ self error: 'can''t become SmallIntegers'].	"Must have failed because not enough space in forwarding table (see ObjectMemory-prepareForwardingTableForBecoming:with:twoWay:).  Do GC and try again only once"	(Smalltalk bytesLeft: true) = Smalltalk primitiveGarbageCollect		ifTrue: [^ self primitiveFailed].	^ self elementsExchangeIdentityWith: otherArray! !!Array methodsFor: 'as yet unclassified'!primElementsForwardIdentityTo: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  The identityHashes remain with the pointers rather than with the objects so that the objects in this array should still be properly indexed in any existing hashed structures after the mutation."	<primitive: 72>	self primitiveFailed! !!Array methodsFor: 'as yet unclassified'!primElementsForwardIdentityTo: otherArray copyHash: copyHash	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  The identityHashes remain with the pointers rather than with the objects so that the objects in this array should still be properly indexed in any existing hashed structures after the mutation."	<primitive: 249>	self primitiveFailed! !!ExternalValue methodsFor: 'as yet unclassified'!beNull	"Make the receiver a NULL pointer"	self atAllPut: 0.! !!ExternalValue methodsFor: 'as yet unclassified'!isNull	^(self basicAt: 1) = 0	and: (self basicAt: 2) = 0	and: (self basicAt: 3) = 0	and: (self basicAt: 4) = 0	! !!ExternalValue class methodsFor: 'as yet unclassified'!initialize	Smalltalk addToStartUpList: self.! !!ExternalValue class methodsFor: 'as yet unclassified'!new	"External addresses are always 4 bytes long"	^super new: 4! !!ExternalValue class methodsFor: 'as yet unclassified'!new: n	"You better don't try this..."	^self shouldNotImplement! !!ExternalValue class methodsFor: 'as yet unclassified'!startUp: resuming	resuming ifTrue: [		self allInstancesDo: [ :addr |			addr beNull		]	].! !!SharedPool class methodsFor: 'as yet unclassified'!bindingOf: varName	"Answer the binding of some variable resolved in the scope of the receiver"	| aSymbol binding |	aSymbol := varName asSymbol.	"First look in classVar dictionary."	binding := self classPool bindingOf: aSymbol.	binding ifNotNil:[^binding].	"Next look in shared pools."	self sharedPools do:[:pool | 		binding := pool bindingOf: aSymbol.		binding ifNotNil:[^binding].	].	"subclassing and environment are not preserved"	^nil! !!SharedPool class methodsFor: 'as yet unclassified'!bindingsDo: aBlock	^self classPool bindingsDo: aBlock! !!SharedPool class methodsFor: 'as yet unclassified'!classBindingOf: varName	"For initialization messages grant the regular scope"	^super bindingOf: varName! !!SharedPool class methodsFor: 'as yet unclassified'!hasBindingThatBeginsWith: aString	"Answer true if the receiver has a binding that begins with aString, false otherwise"	"First look in classVar dictionary."	(self classPool hasBindingThatBeginsWith: aString) ifTrue:[^true].	"Next look in shared pools."	self sharedPools do:[:pool | 		(pool hasBindingThatBeginsWith: aString) ifTrue: [^true]].	^false! !!SharedPool class methodsFor: 'as yet unclassified'!includesKey: aName	"does this pool include aName"	^(self bindingOf: aName) notNil! !!SharedPool class methodsFor: 'as yet unclassified'!keysDo: aBlock"A hopefully temporary fix for an issue arising from miss-spelled variable names in code being compiled. The correction code (see Class>possibleVariablesFor:continuedFrom: assumes that sharedPools are Dictionaries. The proper fix would involve making sure all pools are actually subclasses of SharedPool, which they are not currently."	self bindingsDo:[:b|		aBlock value: b key]! !!Shell methodsFor: 'as yet unclassified'!display: string	| buffer |		buffer := AsciiZ fromString: string.	^ FileDescriptor stdout writeBuffer: buffer size: buffer size.! !!Shell methodsFor: 'as yet unclassified'!input: prompt	^ LibReadLine default readline: prompt! !!Shell methodsFor: 'as yet unclassified'!main	| line value failed anotherLine buffer |	LibReadLine default readHistory: self historyFileName.	[		anotherLine := false.		buffer := ''.		[ 	| prompt |			prompt := anotherLine ifTrue: [ '' ] ifFalse: [ '> ' ].			line _ self input: prompt.			line isEmpty				ifTrue: [ true ] 				ifFalse: [					(line last = $\)						ifTrue: [							anotherLine := true.							line at: line size put: Character lf.						]						ifFalse: [ anotherLine := false ].					buffer := buffer, line.					anotherLine				]		] whileTrue. 		buffer = 'quit' or: [ buffer = 'save' ]	] whileFalse: [		self addToHistory: buffer.		failed _ false.		value _ Compiler new evaluate: buffer in: nil to: nil notifying: self ifFail: [ failed _ true].		failed ifFalse: [ self display: (value printString); lf ]	].	LibReadLine default writeHistory: self historyFileName.	buffer = 'save' ifTrue: [ Smalltalk snapshotAndQuit ].	^value.! !!SignedIntegerType class methodsFor: 'as yet unclassified'!checkType: value	^ value isInteger and: [ value >= self min and: [ value <= self max ] ]! !!SignedIntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	^ handle longAt: 1 bigEndian: self isBigEndian.! !!SignedIntegerType class methodsFor: 'as yet unclassified'!store: anInteger in: handle	handle longAt: 1 put: anInteger bigEndian: self isBigEndian.! !!SignedByte class methodsFor: 'as yet unclassified'!max			^ 127! !!SignedByte class methodsFor: 'as yet unclassified'!min			^ -128! !!SignedInteger class methodsFor: 'as yet unclassified'!max			^ 2147483647! !!SignedInteger class methodsFor: 'as yet unclassified'!min			^ -2147483648! !!SignedShortInteger class methodsFor: 'as yet unclassified'!max			^ 32767! !!SignedShortInteger class methodsFor: 'as yet unclassified'!min			^ -32768! !!SourceReference methodsFor: 'as yet unclassified'!sourceFrom: aString	self hasEmptySourceReference ifTrue: [ ^ '' ].	^ aString copyFrom: sourceStart to: sourceStop! !!StandardFileStream class methodsFor: 'as yet unclassified'!retryWithGC: execBlock until: testBlock forFileNamed: fullName	"Re-implemented to only force GC if a file with the given name exists"	| blockValue foundIt |	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	"See if we have a file with the given name"	foundIt := self registry keys "hold on strongly for now" 		anySatisfy:[:file| file name sameAs: fullName].	foundIt ifFalse:[^blockValue].	Smalltalk garbageCollectMost.	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollect.	^execBlock value.! !!SystemDictionary methodsFor: 'as yet unclassified'!forgetClass: aClass logged: aBool 	"Delete the class, aClass, from the system.	Note that this doesn't do everything required to dispose of a class - to do that use Class>>removeFromSystem."	aBool ifTrue: [SystemChangeNotifier uniqueInstance classRemoved: aClass fromCategory: aClass category].			SystemOrganization removeElement: aClass name.	self removeFromStartUpList: aClass.	self removeFromShutDownList: aClass.	self removeKey: aClass name ifAbsent: [].	self flushClassNameCache! !!SystemDictionary methodsFor: 'as yet unclassified'!removeClassNamed: aName	"Invoked from fileouts:  if there is currently a class in the system named aName, then remove it.  If anything untoward happens, report it in the Transcript.  "	| oldClass |	(oldClass _ self at: aName asSymbol ifAbsent: [nil]) == nil		ifTrue:			[Transcript cr; show: 'Removal of class named ', aName, ' ignored because ', aName, ' does not exist.'.			^ self].	oldClass removeFromSystem! !!SystemDictionary methodsFor: 'as yet unclassified'!startUp	Processor startUp.	ProcessorScheduler startUp.	self processStartUpList: true.	self installLowSpaceWatcher.! !!SystemTracer methodsFor: 'as yet unclassified'!getAligned: size	^ (( size + 3 ) bitShift: -2) bitShift: 2.! !!TraitBehavior methodsFor: 'as yet unclassified'!addUser: aClassOrTrait	users add: aClassOrTrait! !!TraitBehavior methodsFor: 'as yet unclassified'!classesComposedWithMe	^users gather: [:u | u classesComposedWithMe]! !!TraitBehavior methodsFor: 'as yet unclassified'!initialize	self methodDict: Dictionary new.	self traitComposition: nil.	users _ IdentitySet new.! !!TraitBehavior methodsFor: 'as yet unclassified'!removeUser: aClassOrTrait	users remove: aClassOrTrait ifAbsent: []! !!TraitBehavior methodsFor: 'as yet unclassified'!users	^users! !!TraitComposition methodsFor: 'as yet unclassified'!assertValidUser: aBehavior	"Assert that this trait composition set for aBehavior	does not introduce a cycle."		(self allTraits includes: aBehavior) ifTrue: [		TraitCompositionException signal: 'Cycle in compositions:  The composition (in)directly includes this trait!!']! !!TraitComposition methodsFor: 'as yet unclassified'!methodDescriptionsForSelector: aSymbol	"Return a collection of TraitMethodDescriptions for aSymbol and all the 	aliases of aSymbol."	| selectors collection |	selectors _ IdentitySet with: aSymbol.	self transformations do: [:each |		selectors addAll: (each aliasesForSelector: aSymbol)].	collection _ OrderedCollection new: selectors size.	selectors do: [:each |		collection add: (self methodDescriptionForSelector: each)].	^collection! !!TraitDescription methodsFor: 'as yet unclassified'!trait	"for compatibility with TraitTransformations"	^ self! !!TraitDescription methodsFor: 'as yet unclassified'!updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil	| currentCategory effectiveCategory sel changedCategories composition |	changedCategories _ IdentitySet new.	composition := self hasTraitComposition		ifTrue: [self traitComposition]		ifFalse: [TraitComposition new].	(composition methodDescriptionsForSelector: aSymbol) do: [:each |		sel _ each selector.		(self includesLocalSelector: sel) ifFalse: [			currentCategory _ self organization categoryOfElement: sel.			effectiveCategory _ each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.			effectiveCategory isNil ifTrue: [				currentCategory ifNotNil: [changedCategories add: currentCategory].				self organization removeElement: sel.			] ifFalse: [				((currentCategory isNil or: [currentCategory == ClassOrganizer ambiguous or: [currentCategory == oldCategoryOrNil]]) and: [currentCategory ~~ effectiveCategory]) ifTrue: [					currentCategory ifNotNil: [changedCategories add: currentCategory].					self organization 						classify: sel 						under: effectiveCategory						suppressIfDefault: false]]]].	^ changedCategories! !!TraitDescription methodsFor: 'as yet unclassified'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	(self includesSelector: aSelector)		ifTrue: [^ self organization categoryOfElement: aSelector]		ifFalse: [^nil]! !!Trait methodsFor: 'as yet unclassified'!initialize	super initialize.	classTrait _ ClassTrait for: self! !!TranscriptCodeView class methodsFor: 'as yet unclassified'!initialize	Smalltalk addToStartUpList: self.! !!TranscriptCodeView class methodsFor: 'as yet unclassified'!startUp: resuming	resuming ifTrue: [		TranscriptCodeBuffer := nil.	].! !!TranscriptStream methodsFor: 'as yet unclassified'!open	TranscriptCodeEditor open.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!atEnd	position ifNil: [ ^ nil ].	^ position >= readLimit! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!close	"Close this file."	fileID ifNotNil: [		fileID close.		fileID := nil.		position := nil.	].! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!open: fileName flags: flags	[ fileID := LibC6 default open: fileName flags: flags ]		on: ExternalFunctionError		do: [ ^ nil ].	name := fileName.	readLimit := fileID size.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!open: fileName forWrite: writeMode 	| flags |	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	flags := writeMode 		ifTrue: [ LibC6 default valueForOpenFlagNamed: 'O_RDWR' ]		ifFalse: [ LibC6 default valueForOpenFlagNamed: 'O_RDONLY' ].	rwmode := writeMode.	^ self open: fileName flags: flags.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!openForOverwrite: fileName	| flags |	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	flags := ((LibC6 default valueForOpenFlagNamed: 'O_RDWR') 			bitOr: ( LibC6 default valueForOpenFlagNamed: 'O_TRUNC' )) 			bitOr: ( LibC6 default valueForOpenFlagNamed: 'O_CREAT' ).	rwmode := true.	^ self open: fileName flags: flags.! !!BufferedFileStream methodsFor: 'as yet unclassified'!close	"Close this file."	self flush.	^ super close.! !!BufferedFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	self subclassResponsibility! !!BufferedFileStream methodsFor: 'as yet unclassified'!defaultBufferSize	^ DefaultBufferSize.! !!BufferedFileStream methodsFor: 'as yet unclassified'!flush	| bufferPosition bufferSize |	fileID ifNil: [ ^ nil ].	rwmode ifFalse: [ ^ nil ].	bufferPosition := position truncateTo: (collection size).	bufferSize := collection size min: ( readLimit - bufferPosition).	fileID position: bufferPosition.	bufferSize > 0 ifTrue: [ fileID writeString: collection size: bufferSize ].	 ! !!BufferedFileStream methodsFor: 'as yet unclassified'!initializeBuffer	| bufferSize |	position := 0.	collection := self defaultBufferClass new: self defaultBufferSize.	bufferSize := collection size min: readLimit.	bufferSize > 0 ifTrue: [ fileID readString: collection size: bufferSize ]. ! !!BufferedFileStream methodsFor: 'as yet unclassified'!next	| byte |	byte := self peek.	self position: position + 1.	^ byte! !!BufferedFileStream methodsFor: 'as yet unclassified'!nextPut: char	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	position ifNil: [ self position: 0 ].	collection at: (position \\ (collection size)) + 1put: char.	self position: position + 1.	^ char! !!BufferedFileStream methodsFor: 'as yet unclassified'!open: fileName flags: flags	(super open: fileName flags: flags) ifNotNil: [ self initializeBuffer ].! !!BufferedFileStream methodsFor: 'as yet unclassified'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	position ifNil: [ self position: 0 ].	self atEnd ifTrue: [^ nil ].	^ collection at: (position \\ (collection size)) + 1.! !!BufferedFileStream methodsFor: 'as yet unclassified'!position: newPosition	| oldBufferPosition newBufferPosition bufferSize |	fileID ifNil: [ ^nil ].	newPosition < 0 ifTrue: [ ^nil ]."	((newPosition > readLimit) and: [ rwmode not ])  ifTrue: [ ^nil ]."	newPosition > readLimit ifTrue: [		rwmode ifTrue: [ readLimit := newPosition ] ifFalse: [ ^nil ]	].	oldBufferPosition := position truncateTo: (collection size).	newBufferPosition := newPosition truncateTo: (collection size).	newBufferPosition = oldBufferPosition ifFalse: [ 		self flush.		fileID position: newBufferPosition.		bufferSize := collection size min: ( readLimit - newBufferPosition).		collection := self defaultBufferClass new: self defaultBufferSize.		bufferSize > 0 ifTrue: [ fileID readString: collection size: bufferSize ].	].	position := newPosition."	rwmode ifTrue: [ readLimit := newPosition ]."	^ position.! !!BinaryFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	^ ByteArray! !!TextFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	^ String! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!concreteStream	"Who should we really direct class queries to?  "	^ UnbufferedFileStream.! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!fileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new open: fileName forWrite: true! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!forceNewFileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new openForOverwrite: fileName! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!readOnlyFileNamed: fileName 	"Open an existing file with the given name for reading."	| f |	f := self new open: fileName forWrite: false.	^ f isNil		ifFalse: [f]		ifTrue: ["File does not exist..."			((FileDoesNotExistException fileName: fileName) readOnly: true) signal].	"StandardFileStream readOnlyFileNamed: 'kjsd.txt' "! !!BufferedFileStream class methodsFor: 'as yet unclassified'!initialize	self initializeDefaultBufferSize.! !!BufferedFileStream class methodsFor: 'as yet unclassified'!initializeDefaultBufferSize	DefaultBufferSize := 4096.! !!BufferedFileStream class methodsFor: 'as yet unclassified'!new	^ TextFileStream new.! !!UnhandledError methodsFor: 'as yet unclassified'!devDefaultAction	"The current computation is terminated. The cause of the error should be logged or reported to the user. If the program is operating in an interactive debugging environment the computation should be suspended and the debugger activated."	(GtkMessageDialog question: exception messageText, ', debug it?' ) = #yes		ifTrue: [ ^Processor activeProcess debugError: exception ]."	^ Processor activeProcess terminate."! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!checkType: value	^ value isInteger and: [ value >= 0 and: [ value <= self max ] ]! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	^ handle unsignedLongAt: 1 bigEndian: self isBigEndian.! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!min	^ 0! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!store: anInteger in: handle	handle unsignedLongAt: 1 put: anInteger bigEndian: self isBigEndian.! !!UnsignedByte class methodsFor: 'as yet unclassified'!max			^ 255! !!UnsignedInteger class methodsFor: 'as yet unclassified'!max			^ 4294967295! !!UnsignedShortInteger class methodsFor: 'as yet unclassified'!max			^ 65535! !!Workspace methodsFor: 'as yet unclassified'!buildMenuBar	| menu  edit  |	menu := GtkMenuBar new.	edit := GtkMenu new.	menu		append: AppLauncher fileMenu;		append: (edit createMenuItem: '_Edit');		append: workspaceView menu;		append: AppLauncher toolsMenu;		append: AppLauncher helpMenu.					^ menu.! !!Workspace methodsFor: 'as yet unclassified'!buildToolBar	| toolBar |	^ GtkToolbar new		appendItems: workspaceView toolBar;		yourself! !!Workspace methodsFor: 'as yet unclassified'!defaultCodeViewClass	^ WorkspaceView! !!Workspace methodsFor: 'as yet unclassified'!initialize	workspaceView := self defaultCodeViewClass new.	self container: (GtkVBox new		packStart: (self buildMenuBar) expand: false;		packStart: (self buildToolBar) expand: false;		packStart: (workspaceView view);		packStart: (GtkStatusbar new) expand: false	).! !!Workspace methodsFor: 'as yet unclassified'!inspectedVar: anObject	workspaceView inspectedVar: anObject.! !!TranscriptCodeEditor methodsFor: 'as yet unclassified'!defaultCodeViewClass	^ TranscriptCodeView! !!Workspace class methodsFor: 'as yet unclassified'!defaultSize	^ 640@480.! !!Workspace class methodsFor: 'as yet unclassified'!title	^'Workspace'! !!TranscriptCodeEditor class methodsFor: 'as yet unclassified'!title	^'Transcript'! !BufferedFileStream initialize!TranscriptCodeView initialize!TraitBehavior removeSelector: #initializeUsers!Application subclass: #Shell	instanceVariableNames: 'bindings'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!ExternalValue initialize!NativeFunctionRelocation removeSelector: #addressRelativeTo:!NativeFunctionRelocation removeSelector: #function!NativeFunctionRelocation removeSelector: #functionName!NativeFunctionRelocation removeSelector: #functionName:!NativeFunctionRelocation removeSelector: #patch:!NativeFunctionRelocation removeSelector: #patch:with:!ReadOnlyAsciiZ class removeSelector: #objectFromHandle:!ProcessorScheduler removeSelector: #activeProcess2!ProcessorScheduler removeSelector: #activeThreadData!ProcessorScheduler removeSelector: #primActiveThreadData!Process removeSelector: #threadData:!PrimitiveType class removeSelector: #defaultHandlerType!PrimitiveType class removeSelector: #instantiateHandler!NativeFunction removeSelector: #address!NativeFunction removeSelector: #bind!NativeFunction removeSelector: #invoke!NativeFunction removeSelector: #invokeAnswering:!NativeFunction removeSelector: #invokeAnswering:with:!NativeFunction removeSelector: #invokeAnswering:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:withArguments:!NativeFunction removeSelector: #invokeWith:!NativeFunction removeSelector: #invokeWith:with:!NativeFunction removeSelector: #invokeWith:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:with:with:!NativeFunction removeSelector: #invokeWithArguments:!NativeFunction removeSelector: #name!NativeFunction removeSelector: #name:!NativeFunction removeSelector: #throwNotKnownError!LibraryData removeSelector: #primitiveGetValue!LibExample initialize!LibC6 initialize!LibC6 removeSelector: #initializeUnistd!LibC6 removeSelector: #openPath:flags:!LibC6 removeSelector: #write2:buffer:size:!LibC removeSelector: #close!GPointer class removeSelector: #instantiateHandler!FileStream removeSelector: #position!FileDescriptor initialize!FileDescriptor removeSelector: #movePositionTo:!FileDescriptor removeSelector: #name!FileDescriptor removeSelector: #name:!FileDescriptor removeSelector: #positionFromEns:!FileDescriptor removeSelector: #setPositionAt:!FileDescriptor removeSelector: #setPositionFromEndAt:!CDeclFunction class removeSelector: #name:libraryNamed:returnType:argTypes:!ExecutableFunction class removeSelector: #name:library:!ExecutableFunction class removeSelector: #name:libraryNamed:!CDeclFunction removeSelector: #classFromType:!CDeclFunction removeSelector: #throwExternalFunctionError!ExecutableFunction removeSelector: #address!ExecutableFunction removeSelector: #bind!ExecutableFunction removeSelector: #invoke!ExecutableFunction removeSelector: #invokeWith:!ExecutableFunction removeSelector: #invokeWith:with:!ExecutableFunction removeSelector: #invokeWith:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithArguments:!ExecutableFunction removeSelector: #invokeWithReceiver:!ExecutableFunction removeSelector: #invokeWithReceiver:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:withArguments:!ExecutableFunction removeSelector: #library!ExecutableFunction removeSelector: #library:!ExecutableFunction removeSelector: #libraryName!ExecutableFunction removeSelector: #libraryNamed:!ExecutableFunction removeSelector: #name!ExecutableFunction removeSelector: #name:!ExecutableFunction removeSelector: #name:library:!ExecutableFunction removeSelector: #name:libraryNamed:!ExecutableFunction removeSelector: #primInvokeReceiver:withArguments:!ExecutableFunction removeSelector: #primInvokeWithArguments:!ExecutableFunction removeSelector: #primInvokeWithReceiver:withArguments:!ExecutableFunction removeSelector: #throwNotKnownError!ExternalSymbol removeSelector: #callingConventionString!ExternalObjectProxy removeSelector: #register!ExternalObjectProxy removeSelector: #unregister!AsciiZ class removeSelector: #objectFromHandle:!Executable class removeSelector: #huenul!DynamicLibrary class removeSelector: #addLibrary:named:!DynamicLibrary class removeSelector: #huemul!DynamicLibrary initialize!DynamicLibrary class removeSelector: #name:!DynamicLibrary class removeSelector: #named:!ExternalObject class removeSelector: #handle:!ExternalObject initialize!ExternalObject class removeSelector: #registry!ExternalObject class removeSelector: #registry:!AsciiZ removeSelector: #setFrom:!ExternalBuffer removeSelector: #finalize!ExternalBuffer removeSelector: #selfCheck!ExternalBuffer removeSelector: #setFrom:!ExternalBuffer removeSelector: #storeInto:size:!Executable removeSelector: #initialize!Executable removeSelector: #instantiateFunctionClass:!Executable removeSelector: #name:!Executable removeSelector: #nativeFunctionNamed:!Executable removeSelector: #primitiveOpen!DynamicLibrary removeSelector: #addExternal:!DynamicLibrary removeSelector: #basicName!DynamicLibrary removeSelector: #bind:!DynamicLibrary removeSelector: #bindFunction:!DynamicLibrary removeSelector: #cDeclFunctionNamed:returnType:argTypes:!DynamicLibrary removeSelector: #primitiveBind:!DynamicLibrary removeSelector: #primitiveBindFunction:!ExternalObject removeSelector: #isNullPointer!Object subclass: #ExternalObject	instanceVariableNames: 'handle'	classVariableNames: 'Registry'	poolDictionaries: ''	category: 'FFI-Types'!ExternalFunctionError class removeSelector: #function:!ExternalFunctionError removeSelector: #function!ExternalFunctionError removeSelector: #function:!ExternalFunctionError removeSelector: #isResumable!Error subclass: #ExternalFunctionError	instanceVariableNames: 'functionName'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!Application class removeSelector: #start!Application class removeSelector: #startWithArguments:!Class removeSelector: #superclass:methodDict:format:name:organization:instVarNames:classPool:sharedPools:!ClassBuilder removeSelector: #computeFormat:instSize:forSuper:ccIndex:!ClassBuilder removeSelector: #format:variable:words:pointers:weak:!Smalltalk removeClassNamed: #SystemChangeNotifierTest!RBProgramNodeVisitor subclass: #ASTChecker	instanceVariableNames: 'scope varsChangedInSend'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!RBProgramNodeVisitor subclass: #ASTTranslator	instanceVariableNames: 'methodBuilder receiverForCascade'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #Application	instanceVariableNames: 'arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!AssembleInstruction subclass: #AssembleCMov	instanceVariableNames: ''	classVariableNames: 'Condition'	poolDictionaries: ''	category: 'Exupery'!Object subclass: #AssemblerExupery	instanceVariableNames: 'stream blockAddresses jumpOffsets bytecodes instructionEncoders plugin relocator picEntries debugCollector source'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #BlockClosure	instanceVariableNames: 'method environment'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Contexts'!PluggableGtkSimpleApplication subclass: #ClassFinder	instanceVariableNames: 'classTrait'	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!Object subclass: #ColouringRegisterAllocator	instanceVariableNames: 'source result machine interferenceGraph registerStack registerFile registerTable spiltRegisters hasSpilt coloursUsed simplifyWorklist spillWorklist moveWorklist coalescedMoves isValidating deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #DebugInfo	instanceVariableNames: 'codeSourceReferences argVarsReferences tempVarsReferences capturedVarsReferences'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!Object subclass: #EventManager	instanceVariableNames: 'actionMap'	classVariableNames: 'ActionMaps'	poolDictionaries: ''	category: 'System-Object'!Error subclass: #ExternalFunctionError	instanceVariableNames: 'functionName '	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!Object subclass: #ExternalObject	instanceVariableNames: 'handle '	classVariableNames: 'Registry '	poolDictionaries: ''	category: 'FFI-Types'!ExternalObject subclass: #DynamicLibrary	instanceVariableNames: 'name symbolCache'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!DynamicLibrary subclass: #Executable	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!ExternalObject subclass: #ExternalBuffer	instanceVariableNames: 'size'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalBuffer subclass: #AsciiZ	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!DynamicLibrary class	instanceVariableNames: 'default'!ExternalObject subclass: #ExternalObjectProxy	instanceVariableNames: 'object'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalObjectProxy subclass: #ExternalArrayProxy	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalObject subclass: #ExternalSymbol	instanceVariableNames: 'name library'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!ExternalSymbol subclass: #ExecutableFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!ExecutableFunction subclass: #CDeclFunction	instanceVariableNames: 'returnType argTypes'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Error subclass: #ExternalSymbolError	instanceVariableNames: 'symbolName'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!ExternalObject subclass: #FileDescriptor	instanceVariableNames: ''	classVariableNames: 'StandardDescriptors'	poolDictionaries: ''	category: 'FFI-Types'!Error subclass: #FileStreamException	instanceVariableNames: 'fileName'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #CannotDeleteFileException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #FileDoesNotExistException	instanceVariableNames: 'readOnly'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #FileExistsException	instanceVariableNames: 'fileClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!AssemblyCopier subclass: #FinalCopier	instanceVariableNames: 'deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!LexicalScope subclass: #FunctionScope	instanceVariableNames: 'thisContextVar thisEnvVar tempVars capturedVars isHome hasInnerFreeVars hideTemps argVars uninitializedTemps capturedParentEnv'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #GIRBuilder	instanceVariableNames: 'ir currentBlock machine relocationInfo primitiveNode literals thisEnvVar cacheMap literalTemp source start stop debugInfo'	classVariableNames: 'InlinedSelectors SpecialConstants SpecialSelectors'	poolDictionaries: ''	category: 'Compiler-IR'!LexicalScope subclass: #InstanceScope	instanceVariableNames: 'vars'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!DynamicLibrary subclass: #LibC6	instanceVariableNames: ''	classVariableNames: 'LSeekDirectives OpenFlags'	poolDictionaries: ''	category: 'FFI-Libraries'!Object subclass: #LibExample	instanceVariableNames: ''	classVariableNames: 'GETPID'	poolDictionaries: ''	category: 'Guille-Test'!DynamicLibrary subclass: #LibReadLine	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!ExternalSymbol subclass: #LibraryData	instanceVariableNames: 'type'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Object subclass: #LivenessAnalyser	instanceVariableNames: 'source hasUpdated isValidating deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #MedLanguage	instanceVariableNames: 'in out start stop'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedCMov	instanceVariableNames: 'type from to'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedEnter	instanceVariableNames: 'argument'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedLeave	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedLiteral	instanceVariableNames: 'literal'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLiteral subclass: #MedFunction	instanceVariableNames: 'block byteCodeAddress'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!ExecutableFunction subclass: #NativeFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Object subclass: #PrimitiveType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!PrimitiveType subclass: #IntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!RBProgramNode subclass: #RBReturnNode	instanceVariableNames: 'return value homeBinding frameBinding'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Nodes'!ExternalObject subclass: #ReadOnlyAsciiZ	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SemanticWarning subclass: #RedeclaredVariableWarning	instanceVariableNames: 'variableNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #RelocationInfo	instanceVariableNames: 'offset'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #ExecutableFunctionRelocation	instanceVariableNames: 'functionName'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #FunctionRelocation	instanceVariableNames: 'function'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #LiteralRelocation	instanceVariableNames: 'literals'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!ExecutableFunctionRelocation subclass: #NativeFunctionRelocation	instanceVariableNames: 'libraryName'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!NativeFunctionRelocation subclass: #ExternalFunctionRelocation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #PrimitiveRelocation	instanceVariableNames: 'number'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!Object subclass: #ScopeVar	instanceVariableNames: 'scope usage'	classVariableNames: 'UsageAutomaton'	poolDictionaries: ''	category: 'Compiler-Semantics'!ScopeVar subclass: #GlobalVar	instanceVariableNames: 'assoc'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!ScopeVar subclass: #LocalVar	instanceVariableNames: 'name index'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!LocalVar subclass: #ArgVar	instanceVariableNames: 'isArg'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!LocalVar subclass: #CapturedVar	instanceVariableNames: 'sourceTemp'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!ByteArray variableByteSubclass: #ExternalValue	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!Object subclass: #SharedPool	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Pools'!Application subclass: #Shell	instanceVariableNames: 'bindings '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!IntegerType subclass: #SignedIntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedByte	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedShortInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!Object subclass: #SourceReference	instanceVariableNames: 'sourceStart sourceStop codeStop'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!RelocationInfo subclass: #SpecialSelectorRelocation	instanceVariableNames: 'specialSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!Model subclass: #StringHolder	instanceVariableNames: 'contents'	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Kernel-Remnants'!Object subclass: #SystemTracer	instanceVariableNames: 'byteStream traceQueue oopMap nextChunk nilOop count'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Tracer'!LocalVar subclass: #TempVar	instanceVariableNames: 'isArg'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Error subclass: #TraitException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Kernel'!TraitException subclass: #TraitCompositionException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Composition'!Error subclass: #TypeConvertionError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!FileStream subclass: #UnbufferedFileStream	instanceVariableNames: 'name fileID'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!Smalltalk renameClassNamed: #BufferedFileStream2 as: #BufferedFileStream!UnbufferedFileStream subclass: #BufferedFileStream	instanceVariableNames: ''	classVariableNames: 'DefaultBufferSize'	poolDictionaries: ''	category: 'Files-Kernel'!BufferedFileStream subclass: #BinaryFileStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!BufferedFileStream subclass: #TextFileStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!IntegerType subclass: #UnsignedIntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedByte	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedShortInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SemanticWarning subclass: #UnusedVariableWarning	instanceVariableNames: 'variableNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #VarReference	instanceVariableNames: 'name'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!RelocationInfo subclass: #VariableRelocation	instanceVariableNames: 'variable'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!PluggableGtkSimpleApplication subclass: #Workspace	instanceVariableNames: 'workspaceView'	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!Workspace subclass: #TranscriptCodeEditor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!!Object methodsFor: 'as yet unclassified'!errorSubscriptBounds: index 	"Create an error notification that an improper integer was used as an index."	self error: 'subscript is out of bounds: ' , index printString! !!Object methodsFor: 'as yet unclassified'!executeMethod: compiledMethod withArgs: argArray	"Execute compiledMethod against the receiver and args in argArray"	| selector |	<primitive: 188>	selector _ Symbol new.	self class addSelectorSilently: selector withMethod: compiledMethod.	^ [self perform: selector withArguments: argArray]		ensure: [self class basicRemoveSelector: selector]! !!Object methodsFor: 'as yet unclassified'!withArgs: argArray executeMethod: compiledMethod	"For compatibility with Aqueak"	self executeMethod: compiledMethod withArgs: argArray! !!Application methodsFor: 'as yet unclassified'!arguments	^ arguments.! !!Application methodsFor: 'as yet unclassified'!arguments: anArray	arguments := anArray.! !!Application methodsFor: 'as yet unclassified'!main	self subclassResponsibility.! !!Application methodsFor: 'as yet unclassified'!startUp	Smalltalk startUp.	^ self main.! !!Behavior methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return true if it is safe to zap the method dictionary on #obsolete"	^true! !!Behavior methodsFor: 'as yet unclassified'!isWeak	^ (format bitAnd: 4) = 1.! !!Behavior methodsFor: 'as yet unclassified'!obsolete	"Invalidate and recycle local methods,	e.g., zap the method dictionary if can be done safely."	self canZapMethodDictionary		ifTrue: [self methodDict: self emptyMethodDictionary].! !!Behavior methodsFor: 'as yet unclassified'!removeSelector: selector	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method."	| oldMethod |		oldMethod _ self methodDict at: selector ifAbsent: [^ self].	self methodDict removeKey: selector.	"Now flush Squeak's method cache, either by selector or by method"	oldMethod flushCache.	selector flushCache! !!Behavior methodsFor: 'as yet unclassified'!selectorsAndMethodsDo: aBlock	"Evaluate selectorBlock for all the message selectors in my method dictionary."	^ self methodDict keysAndValuesDo: aBlock! !!Behavior methodsFor: 'as yet unclassified'!setTraitComposition: aTraitComposition	| oldComposition |	(self hasTraitComposition not and: [aTraitComposition isEmpty]) ifTrue: [^self].	aTraitComposition assertValidUser: self.	oldComposition _ self traitComposition.	self traitComposition: aTraitComposition."	self applyChangesOfNewTraitCompositionReplacing: oldComposition."		oldComposition traits do: [:each | each removeUser: self].	aTraitComposition traits do: [:each | each addUser: self]! !!Behavior methodsFor: 'as yet unclassified'!traitCompositionString	^self hasTraitComposition		ifTrue: [self traitComposition asString]		ifFalse: ['{}']! !!Behavior methodsFor: 'as yet unclassified'!typeOfClass	"Answer a symbol uniquely describing the type of the receiver"	self isWeak ifTrue: [ ^ #weak ].	^ (format bitAnd: 3) caseOf: {		[ 0 ] -> [ #normal ].		[ 1 ] -> [ #variable ].		[ 2 ] -> [ #bytes ].		[ 3 ] -> [ #words ]	}! !!Behavior methodsFor: 'as yet unclassified'!whichSelectorsReferTo: literal	"Answer a set of selectors whose methods access the argument as a literal."	| who |	who _ IdentitySet new.	self selectorsAndMethodsDo: 		[:sel :method |		(method hasLiteral: literal)			ifTrue:				[((literal isVariableBinding) not					or: [method literals allButLast includes: literal])						ifTrue: [who add: sel]]].	^ who! !!BehaviorTest methodsFor: 'as yet unclassified'!testBehaviorSubclasses	"self run: #testBehaviorSubclasses"		| b b2 |"	b := Behavior new.	b superclass: OrderedCollection.	b methodDictionary: Dictionary new.	self shouldnt: [b subclasses ] raise: Error.	self shouldnt: [b withAllSubclasses] raise: Error.	self shouldnt: [b allSubclasses] raise: Error.	b2 := Behavior new.	b2 superclass: b.	b2 methodDictionary: Dictionary new.	self assert: (b subclasses includes: b2).	self assert: (b withAllSubclasses includes: b)."! !!BlockClosure methodsFor: 'as yet unclassified'!valueWithArguments: anArray 	"Evaluate the block with given args. Fail if the block expects other than the given number of arguments."	^ environment executeMethod: method withArgs: anArray ! !!ClassBrowser methodsFor: 'as yet unclassified'!buildClassCategoriesView	| model tree col cell |	tree := nil->nil.	SystemOrganization categories do: [ :each |		| category |		category := tree.		(each subStrings: '-') do: [ :cat |			category value ifNil: [ category value: Dictionary new].			category := category value associationAt: cat ifAbsent: [ category value at: cat put: nil. category value associationAt: cat ]		]	].	model := GtkTreeStore new: {String. String}.	[ self addSubcategoriesFrom: tree fromIter: nil inModel: model ] fork.	classCategoriesTree := GtkTreeView model: model.	col := GtkTreeViewColumn title: 'Class categories'.	cell := GtkCellRendererPixbuf new.	col		packStart: cell expand: false;		addAttribute: #stockId column: 1 on: cell.	cell := GtkCellRendererText new.	col		packStart: cell;		addAttribute: #text column: 0 on: cell.		classCategoriesTree appendColumn: col.	classCategoriesTree selection when: #changed send: #onClassCategoryChanged to: self.	classCategoriesTree enableTreeLines: true.	^ GtkScrolledWindow withChild: classCategoriesTree! !!ClassBrowser methodsFor: 'as yet unclassified'!loadClassMethodsOf: aClassClass	| iter |	classMethodsTree model clear.	aClassClass organization categories do: [ :cat |		iter := classMethodsTree model append: nil->{cat asString. true. 'grey'. 'gtk-info'}.		(aClassClass organization listAtCategoryNamed: cat) asSortedCollection do: [ :sel |			classMethodsTree model append: iter->{sel asString. false. 'grey'. 'gtk-execute'}		]	].	classMethodsTree expandAll.! !!ClassBrowser methodsFor: 'as yet unclassified'!loadInstanceMethodsOf: aClass	| iter |	instanceMethodsTree model clear.	aClass organization categories do: [ :cat |		iter := instanceMethodsTree model append: nil->{cat asString. true. 'grey'. 'gtk-info'}.		(aClass organization listAtCategoryNamed: cat) asSortedCollection do: [ :sel |			instanceMethodsTree model append: iter->{sel asString. false. 'grey'. 'gtk-execute'}		]	].	instanceMethodsTree expandAll.! !!ClassBrowser methodsFor: 'as yet unclassified'!onClassHierarchyChanged	| class iter path newIter aCategory classHierarchySelectedRow classesTreeSelectedRow |	classHierarchySelectedRow := classHierarchyTree selectedRow.	classHierarchySelectedRow ifNotNil: [		class := Smalltalk at: (classHierarchySelectedRow first asSymbol).							aCategory := class category.		( aCategory isNotNil and: [ aCategory ~= selectedClassCategory ] ) ifTrue: [			selectedClassCategory := aCategory.			iter := classCategoriesTree model firstIter.			newIter := nil.			(aCategory subStrings: '-') do: [ :cat |				newIter ifNotNil: [ iter := newIter ].				iter := self classCategoryFor: cat firstIter: iter.				newIter := classCategoriesTree model firstChildAt: iter.			].			path := classCategoriesTree model pathFromIter: iter.			classCategoriesTree expandRowsUpTo: path.			classCategoriesTree moveCursorAt: path.					classesTree model clear.			(SystemOrganization listAtCategoryNamed: aCategory) sort do: [ :ea |				classesTree model append: {ea asString. 'gtk-execute'}			]		].							self selectClass: class.	]! !!ClassBuilder methodsFor: 'as yet unclassified'!formatForType: type	^ type caseOf: {		[ #normal ] -> [ 0 ].		[ #variable ] -> [ 1 ].		[ #bytes ] -> [ 2 ].		[ #words ] -> [ 3 ].		[ #weak ] -> [ 5 "binary: 4 + 0 + 0 + 1" ]	} otherwise: [ self error: 'Unknown class type' ].! !!ClassBuilder methodsFor: 'as yet unclassified'!needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Answer whether we need a new subclass to conform to the requested changes"	"Check if we really need a new subclass"	oldClass ifNil:[^true]. "yes, it's a new class"	newSuper == oldClass superclass ifFalse:[^true]. "yes, it's a superclass change"	type = oldClass typeOfClass ifFalse:[^true]. "yes, it's a format change"	instVars = oldClass instVarNames ifFalse:[^true]. "yes, it's an iVar change"	^false! !!ClassBuilder methodsFor: 'as yet unclassified'!newSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Create a new subclass of the given superclass with the given specification."	| newClass |	(oldClass == nil or:[oldClass isMeta not]) 		ifTrue:[newClass := self privateNewSubclassOf: newSuper from: oldClass]		ifFalse:[newClass := oldClass clone].	newClass 		superclass: newSuper		methodDictionary: "Method"Dictionary new		instanceSize: (newSuper instSize + instVars size)		format: (self formatForType: type);		setInstVarNames: instVars.	oldClass ifNotNil:[		newClass organization: oldClass organization.		"Recompile the new class"		oldClass hasMethods 			ifTrue:[newClass compileAllFrom: oldClass].		oldClass hasTraitComposition ifTrue: [			newClass setTraitComposition: oldClass traitComposition copyTraitExpression ].		oldClass class hasTraitComposition ifTrue: [			newClass class setTraitComposition: oldClass class traitComposition copyTraitExpression ].				self recordClass: oldClass replacedBy: newClass.	].	(oldClass == nil or:[oldClass isObsolete not]) 		ifTrue:[newSuper addSubclass: newClass]		ifFalse:[newSuper addObsoleteSubclass: newClass].	^newClass! !!ClassBuilder methodsFor: 'as yet unclassified'!privateNewSubclassOf: newSuper from: oldClass	"Create a new meta and non-meta subclass of newSuper using oldClass as template"	"WARNING: This method does not preserve the superclass/subclass invariant!!"	| newSuperMeta oldMeta newMeta |	oldClass ifNil:[^self privateNewSubclassOf: newSuper].	newSuperMeta _ newSuper ifNil:[Class] ifNotNil:[newSuper class].	oldMeta _ oldClass class.	newMeta _ oldMeta clone.	newMeta 		superclass: newSuperMeta		methodDictionary: "Method"Dictionary new		instanceSize: oldMeta instSize		format: oldMeta format;		setInstVarNames: oldMeta instVarNames;		organization: oldMeta organization.	"Recompile the meta class"	oldMeta hasMethods 		ifTrue:[newMeta compileAllFrom: oldMeta].	"Record the meta class change"	self recordClass: oldMeta replacedBy: newMeta.	"And create a new instance"	^newMeta adoptInstance: oldClass from: oldMeta! !!ClassBuilder methodsFor: 'as yet unclassified'!reshapeClass: oldClass toSuper: newSuper	"Reshape the given class to the new super class. Recompile all the methods in the newly created class. Answer the new class."	| instVars |	instVars _ instVarMap at: oldClass name ifAbsent:[oldClass instVarNames].	^self newSubclassOf: newSuper 			type: oldClass typeOfClass 			instanceVariables: instVars 			from: oldClass! !!ClassDescription methodsFor: 'as yet unclassified'!classVersion	"Default.  Any class may return a later version to inform readers that use ReferenceStream.  8/17/96 tk"	"This method allows you to distinguish between class versions when the shape of the class 	hasn't changed (when there's no change in the instVar names).	In the conversion methods you usually can tell by the inst var names 	what old version you have. In a few cases, though, the same inst var 	names were kept but their interpretation changed (like in the layoutFrame).	By changing the class version when you keep the same instVars you can 	warn older and newer images that they have to convert."	^ 0! !!ClassDescription methodsFor: 'as yet unclassified'!obsolete	"Make the receiver obsolete."	superclass removeSubclass: self.	self organization: nil.	super obsolete.! !!ClassDescription methodsFor: 'as yet unclassified'!removeSelector: selector 	"Remove the message whose selector is given from the method 	dictionary of the receiver, if it is there. Answer nil otherwise."		| priorMethod priorProtocol | 	priorMethod _ self compiledMethodAt: selector ifAbsent: [^ nil].	priorProtocol _ self whichCategoryIncludesSelector: selector.	SystemChangeNotifier uniqueInstance		doSilently: [self organization removeElement: selector ].	super removeSelector: selector.	SystemChangeNotifier uniqueInstance 			methodRemoved: priorMethod selector: selector inProtocol: priorProtocol class: self.! !!ClassDescription methodsFor: 'as yet unclassified'!updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil	| currentCategory effectiveCategory sel changedCategories composition |	changedCategories _ IdentitySet new.	composition := self hasTraitComposition		ifTrue: [self traitComposition]		ifFalse: [TraitComposition new].	(composition methodDescriptionsForSelector: aSymbol) do: [:each |		sel _ each selector.		(self includesLocalSelector: sel) ifFalse: [			currentCategory _ self organization categoryOfElement: sel.			effectiveCategory _ each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.			effectiveCategory isNil ifTrue: [				currentCategory ifNotNil: [changedCategories add: currentCategory].				self organization removeElement: sel.			] ifFalse: [				((currentCategory isNil or: [currentCategory == ClassOrganizer ambiguous or: [currentCategory == oldCategoryOrNil]]) and: [currentCategory ~~ effectiveCategory]) ifTrue: [					currentCategory ifNotNil: [changedCategories add: currentCategory].					self organization 						classify: sel 						under: effectiveCategory						suppressIfDefault: false]]]].	^ changedCategories! !!ClassDescription methodsFor: 'as yet unclassified'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	(self includesSelector: aSelector)		ifTrue: [^ self organization categoryOfElement: aSelector]		ifFalse: [^nil]! !!Class methodsFor: 'as yet unclassified'!classPool: aDictionary	classPool _ aDictionary! !!Class methodsFor: 'as yet unclassified'!copy 	| newClass |	newClass _ self class copy new		superclass: superclass		methodDict: self methodDict copy		instanceSize: self instSize		format: format		name: name		organization: self organization copy		instVarNames: instanceVariables copy		classPool: classPool copy		sharedPools: sharedPools.	Class instSize+1 to: self class instSize do:		[:offset | newClass instVarAt: offset put: (self instVarAt: offset)].	^ newClass! !!Class methodsFor: 'as yet unclassified'!deactivate	"A remnant from the 3.3a modules work, retained . Does nothing, but may be overridden in Metaclasses."! !!Class methodsFor: 'as yet unclassified'!isSystemDefined	"Answer true if the receiver is a system-defined class, and not a UniClass (an instance-specific lightweight class)"	^ self == self officialClass! !!Class methodsFor: 'as yet unclassified'!obsolete	"Change the receiver and all of its subclasses to an obsolete class."	self == Object 		ifTrue: [^self error: 'Object is NOT obsolete'].	self setName: 'AnObsolete' , self name.	Object class instSize + 1 to: self class instSize do:		[:i | self instVarAt: i put: nil]. "Store nil over class instVars."	self classPool: nil.	self sharedPools: nil.	self class obsolete.	super obsolete.! !!Class methodsFor: 'as yet unclassified'!officialClass	"I am not a UniClass.  (See Player officialClass).  Return the class you use to make new subclasses."	^ self! !!Class methodsFor: 'as yet unclassified'!removeFromSystem	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."	self removeFromSystem: true.! !!Class methodsFor: 'as yet unclassified'!removeFromSystem: logged	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."		"keep the class name and category for triggering the system change message. If we wait to long, then we get obsolete information which is not what we want."	"tell class to deactivate and unload itself-- two separate events in the module system"	self deactivate; unload.	self superclass ifNotNil:		["If we have no superclass there's nothing to be remembered"		self superclass addObsoleteSubclass: self].	self environment forgetClass: self logged: logged.	self obsolete.! !!Class methodsFor: 'as yet unclassified'!sharedPools: aCollection	sharedPools _ aCollection! !!Class methodsFor: 'as yet unclassified'!superclass: sup methodDict: md instanceSize: is format: ft name: nm organization: org instVarNames: nilOrArray classPool: pool sharedPools: poolSet 	"Answer an instance of me, a new class, using the arguments of the 	message as the needed information.	Must only be sent to a new instance; else we would need Object flushCache."	superclass := sup.	methodDict := md.	instanceSize := is.	format := ft.	name := nm.	instanceVariables := nilOrArray.	classPool := pool.	sharedPools := poolSet.	self organization: org.! !!Class methodsFor: 'as yet unclassified'!unload	"Sent when a the class is removed.  Does nothing, but may be overridden by (class-side) subclasses."! !!Class methodsFor: 'as yet unclassified'!variableByteSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable byte-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableByteSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!variableSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable pointer variables."	^(ClassBuilder new)		superclass: self		variableSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!variableWordSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable word-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableWordSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!weakSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have weak indexable pointer variables."	^(ClassBuilder new)		superclass: self		weakSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!AppLauncher class methodsFor: 'as yet unclassified'!openAboutHuemul	| dlg logo |	logo := GdkPixbuf fromFile: 'Huemul.jpg'.	dlg := GtkAboutDialog new.	dlg		aboutDialogName: 'Huemul Smalltalk';		version: '0.8';		license: (StandardFileStream readOnlyFileNamed: 'LICENSE') upToEnd;		website: 'http://www.guillermomolina.com.ar/huemul';		comments: 'This is Huemul Smalltalk';		authors: {'Guillermo Adrian Molina'};		logo: logo.	dlg runAndDestroy! !!AppLauncher class methodsFor: 'as yet unclassified'!openWorkspace	^ Workspace open! !!Application class methodsFor: 'as yet unclassified'!startUp	^ self new startUp.! !!Application class methodsFor: 'as yet unclassified'!startUpWithArguments: arguments	| application |	application := self new.	application arguments: arguments.	^ application startUp.! !!Behavior class methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return false since zapping the method dictionary of Behavior class or its subclasses will cause the system to fail."	^false! !!ClassBrowser class methodsFor: 'as yet unclassified'!defaultSize	^ 640@480.! !!ClassBrowser class methodsFor: 'as yet unclassified'!title	^'Class browser'! !!ClassFinder class methodsFor: 'as yet unclassified'!defaultSize	^ 200@300.! !!ClassFinder class methodsFor: 'as yet unclassified'!title	^'Class finder'! !!CompiledMethod methodsFor: 'as yet unclassified'!hasLiteral: literal	"Answer whether the receiver references the argument, literal."	literals ifNil: [ ^false ].	^ literals hasLiteral: literal.! !!CompiledMethod methodsFor: 'as yet unclassified'!sourcePointer	"Answer the integer which can be used to find the source file and position for this method.	Not sources yet"	^ 0! !!CompiledMethodWithNode class methodsFor: 'as yet unclassified'!method: aCompiledMethod node: aMethodNode	^ self new method: aCompiledMethod; node: aMethodNode.! !!Compiler methodsFor: 'as yet unclassified'!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into a method. In other words, if receiver is not nil, then the text can refer to instance variables of that receiver (the Inspector uses this). If aContext is not nil, the text can refer to temporaries in that context (the Debugger uses this). If aRequestor is not nil, then it will receive a notify:at: message before the attempt to evaluate is aborted. Finally, the compiled method is directly invoked without modifying the receiving-class."	"| methodNode method value |	  	(Preferences compileUseNewCompiler or: 			[aContext ifNotNil: [aContext method isClosureCompiled] ifNil: [false]]) ifTrue: 				[^ self evaluate2: textOrStream 					    in: aContext 					    to: receiver 					    notifying: aRequestor 					    ifFail: failBlock 					    logged: logFlag].		class := (aContext isNil 		ifTrue: [ receiver ] 		ifFalse: [ aContext receiver ])			class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode := self 		translate: sourceStream		noPattern: true 		ifFail: [ ^ failBlock value ].	method := methodNode generate.	self interactive		ifTrue: [ method := method copyWithTempNames: methodNode tempNames ].	value := receiver		executeMethod: method 		withArgs: (context isNil			ifTrue: [ #() ]			ifFalse: [ Array with: aContext ]).	logFlag 		ifTrue: [ SystemChangeNotifier uniqueInstance evaluated: sourceStream contents context: aContext ].	^ value."	| string block |	string _ textOrStream readStream upToEnd.	block := self compileDoIt: string in: aContext to: receiver notifying: aRequestor ifFail: [^ failBlock value] log: logFlag.	^ block value! !!Exception methodsFor: 'as yet unclassified'!messageText	messageText ifNil: [ ^ self class name asString ].	^messageText! !!Exception methodsFor: 'as yet unclassified'!receiver	^ self signalerContext receiver! !!ExternalFunctionError methodsFor: 'as yet unclassified'!functionName	"Answer the function name that was beiing used."	^functionName! !!ExternalFunctionError methodsFor: 'as yet unclassified'!functionName: argument	"Specify the function name that was beiing used."	functionName := argument! !!ExternalFunctionError class methodsFor: 'as yet unclassified'!functionName: argument	^self new functionName: argument; yourself! !!ExternalObject methodsFor: 'as yet unclassified'!= anObject 	(anObject isKindOf: self class)		ifTrue: [^ anObject handle = self handle]		ifFalse: [^ false]! !!ExternalObject methodsFor: 'as yet unclassified'!beNull	^ handle beNull.! !!ExternalObject methodsFor: 'as yet unclassified'!finalize		self free.	self unregister.! !!ExternalObject methodsFor: 'as yet unclassified'!free	"Should override this"! !!ExternalObject methodsFor: 'as yet unclassified'!initialize	handle := self class defaultHandlerClass new.	self register.! !!ExternalObject methodsFor: 'as yet unclassified'!isNull	^ self handle isNull.! !!ExternalObject methodsFor: 'as yet unclassified'!register	Registry add: self.! !!ExternalObject methodsFor: 'as yet unclassified'!unregister		Registry remove: self ifAbsent:[  ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!addSymbol: anExternalSymbol	^ symbolCache at: anExternalSymbol name put: anExternalSymbol.! !!DynamicLibrary methodsFor: 'as yet unclassified'!bindSymbol: anExternalSymbol	^ self primitiveBindSymbol: anExternalSymbol.! !!DynamicLibrary methodsFor: 'as yet unclassified'!cDeclFunctionNamed: functionName	^ symbolCache at: functionName ifAbsent: [ self error: 'You must initialize the function before using it' ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!close		handle isNull ifFalse: [ 		self primitiveClose		handle beNull.	].! !!DynamicLibrary methodsFor: 'as yet unclassified'!initialize	super initialize.	symbolCache := Dictionary new.! !!DynamicLibrary methodsFor: 'as yet unclassified'!initializeCDeclFunctionNamed: functionName returnType: retType argTypes: argTypesArray	^ symbolCache at: functionName put: 			(CDeclFunction name: functionName library: self  returnType: retType argTypes: argTypesArray)! !!DynamicLibrary methodsFor: 'as yet unclassified'!initializeLibraryDataNamed: symbolName type: type	^ symbolCache at: symbolName put: (LibraryData name: symbolName library: self  type: type)! !!DynamicLibrary methodsFor: 'as yet unclassified'!libraryDataNamed: symbolName	^ symbolCache at: symbolName ifAbsent: [ self error: 'You must initialize the symbol before using it' ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!name	^name! !!DynamicLibrary methodsFor: 'as yet unclassified'!name: aName	name := aName.! !!DynamicLibrary methodsFor: 'as yet unclassified'!nativeFunctionNamed: functionName	^ symbolCache at: functionName ifAbsent: [ 		symbolCache at: functionName put: (NativeFunction name: functionName library: self)	].! !!DynamicLibrary methodsFor: 'as yet unclassified'!open		handle isNull ifTrue: [ self primitiveOpen ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveBindSymbol: anExternalSymbol	"Primitive. Find the given symbol in the library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 203>	^ anExternalSymbol throwNotKnownError.! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveClose	"Primitive. Close the given library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 202>! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveOpen	"Primitive. Open the given library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 198>	self primitiveFailed.! !!DynamicLibrary methodsFor: 'as yet unclassified'!printOn: aStream	aStream nextPutAll: self name.! !!DynamicLibrary methodsFor: 'as yet unclassified'!symbolNamed: symbolName	^ symbolCache at: symbolName ifAbsent: [ self error: 'You must initialize the symbol before using it' ]! !!Executable methodsFor: 'as yet unclassified'!name	^ Utilities executableName ! !!Executable methodsFor: 'as yet unclassified'!primitiveSmallIntegerAdd: receiver with: argument	^ (self nativeFunctionNamed: #primitiveSmallIntegerAdd) invokeReceiver: receiver with: argument.! !!ExternalBuffer methodsFor: 'as yet unclassified'!asByteArray	| array |	size ifNil: [ ^ self class throwTypeConvertionError ].	array := ByteArray new: self basicSize.	self storeInto: array.	^ array	! !!ExternalBuffer methodsFor: 'as yet unclassified'!atAllPut: constant	^ LibC6 default memSet: self constant: constant count: self size.! !!ExternalBuffer methodsFor: 'as yet unclassified'!atAllPutZero	^ self atAllPut: 0.! !!ExternalBuffer methodsFor: 'as yet unclassified'!basicSize	^ size.! !!ExternalBuffer methodsFor: 'as yet unclassified'!byteAt: index	<primitive: 190>	index isNumber		ifTrue: [self errorSubscriptBounds: index]		ifFalse: [self errorNonIntegerIndex].! !!ExternalBuffer methodsFor: 'as yet unclassified'!byteAt: index put: value	<primitive: 191>	index isNumber		ifTrue: [self errorSubscriptBounds: index]		ifFalse: [self errorNonIntegerIndex].! !!ExternalBuffer methodsFor: 'as yet unclassified'!free		handle isNull ifFalse: [ 		LibC6 default free: self.		self beNull.	]! !!ExternalBuffer methodsFor: 'as yet unclassified'!loadFrom: aByteArray	<primitive: 199>	self primitiveFailed.! !!ExternalBuffer methodsFor: 'as yet unclassified'!size	^ self basicSize.! !!ExternalBuffer methodsFor: 'as yet unclassified'!size: anInteger	size := anInteger.! !!ExternalBuffer methodsFor: 'as yet unclassified'!storeInto: aByteArray	<primitive: 218>	^ self class throwTypeConvertionError.! !!AsciiZ methodsFor: 'as yet unclassified'!asString	^ handle toString.! !!AsciiZ methodsFor: 'as yet unclassified'!asString2	| calcSize string |	size ifNil: [ ^ self class throwTypeConvertionError ].	calcSize := self strlen.	calcSize >= self size ifTrue: [ ^ self class throwTypeConvertionError ].	string := String new: calcSize.	self storeInto: string.	^ string! !!AsciiZ methodsFor: 'as yet unclassified'!loadFrom: aString		super loadFrom: aString.	self byteAt: (aString size + 1) put: 0.! !!AsciiZ methodsFor: 'as yet unclassified'!strlen	^ LibC6 default strLen: self.! !!ExternalFunction methodsFor: 'as yet unclassified'!library	^ library! !!ExternalFunction methodsFor: 'as yet unclassified'!library: aLibrary	library := aLibrary! !!ExternalFunction methodsFor: 'as yet unclassified'!name	^name! !!ExternalFunction methodsFor: 'as yet unclassified'!name: aName	name := aName! !!ExternalFunction methodsFor: 'as yet unclassified'!name: aName library: aLibrary	self name: aName.	self library: aLibrary! !!ExternalFunction methodsFor: 'as yet unclassified'!reload	library ifNil: [ ^ self throwNotKnownError ].	self handle: (library findFunction: self)! !!ExternalLibrary methodsFor: 'as yet unclassified'!bindFunction: function	| answer |	answer := self primitiveBindFunction: function.	answer ifNotNil: [ ^ answer ].	self open. "Library may be closed, open it and retry"	answer := self primitiveBindFunction: answer.	answer ifNotNil: [ ^ answer ].	^ function throwNotKnownError.		! !!ExternalLibrary methodsFor: 'as yet unclassified'!closeLibrary		(handle isNotNil and: [ handle isNull not ]) ifTrue: [ self primitiveClose ].	self handle: nil.	functionCache := nil.! !!ExternalLibrary methodsFor: 'as yet unclassified'!openLibrary		self primitiveOpen.	self initializeFunctionCache.! !!ExternalLibrary methodsFor: 'as yet unclassified'!primitiveBindFunction: function	"Primitive. Find the given symbol in the library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 203>	^ nil.! !!ExternalObject class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: self! !!ExternalObject class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalAddress! !!ExternalObject class methodsFor: 'as yet unclassified'!handleFromObject: anObject	^ self handleFromObject: anObject ifError: [ self throwTypeConvertionError ]! !!ExternalObject class methodsFor: 'as yet unclassified'!handleFromObject: anObject ifError: aBlock		(anObject isKindOf: ExternalObject) ifFalse: [ ^ aBlock value ].	^ anObject handle.	! !!ExternalObject class methodsFor: 'as yet unclassified'!initialize	Registry := WeakRegistry new.	Smalltalk addToShutDownList: self.! !!ExternalObject class methodsFor: 'as yet unclassified'!objectFromHandle: handle	^self objectFromHandle: handle ifError: [ self throwTypeConvertionError ]! !!ExternalObject class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; yourself! !!ExternalObject class methodsFor: 'as yet unclassified'!quit	Registry do: [ :each | each free ].	self allSubclassesDo: [ :ea | ea quit ]! !!ExternalObject class methodsFor: 'as yet unclassified'!shutDown: quitting	quitting ifTrue: [ self quit ].! !!ExternalObject class methodsFor: 'as yet unclassified'!throwTypeConvertionError	^ TypeConvertionError new signal! !!DynamicLibrary class methodsFor: 'as yet unclassified'!default	self = DynamicLibrary ifTrue: [ self error: 'Create a class to create its singleton' ].	default ifNil: [	"Represents the executable itself"		default := self new.		default name: self moduleName.		default open.	].	^ default.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!initialize	self = DynamicLibrary ifFalse: [ 		Smalltalk addToShutDownList: self	].! !!DynamicLibrary class methodsFor: 'as yet unclassified'!moduleName	self subClassResponsibility.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!resetLibrary	default := nil.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!shutDown: aBool	default ifNotNil: [ default close ].! !!Executable class methodsFor: 'as yet unclassified'!huemul	^ self default! !!Executable class methodsFor: 'as yet unclassified'!moduleName	^nil.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: ByteArray! !!ExternalBuffer class methodsFor: 'as yet unclassified'!fromByteArray: aByteArray	| anExternalBuffer |		anExternalBuffer := ExternalBuffer new: aByteArray size.	anExternalBuffer setFrom: aByteArray.	^ anExternalBuffer.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!handleFromObject: aByteArray ifError: aBlock		(aByteArray isKindOf: ByteArray) ifFalse: [ 		^ super handleFromObject: aByteArray ifError: aBlock	].	^ ( self fromByteArray: aByteArray ) handle.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!new: size	| anExternalBuffer |	"This space is allocated from the system not 	from Object Memory, you will have to give it back, 	as it is not garbage collected"	anExternalBuffer := LibC6 default malloc: (size +  10).	anExternalBuffer size: size.	^ anExternalBuffer! !!AsciiZ class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: String! !!AsciiZ class methodsFor: 'as yet unclassified'!fromString: aString	| anAsciiZ |		anAsciiZ := AsciiZ new: aString size + 1.	anAsciiZ loadFrom: aString.	^ anAsciiZ.! !!AsciiZ class methodsFor: 'as yet unclassified'!handleFromObject: aString ifError: aBlock		(aString isKindOf: String) ifFalse: [ 		^ super handleFromObject: aString ifError: aBlock	].	^ ( self fromString: aString ) handle.! !!AsciiZ class methodsFor: 'as yet unclassified'!new: size	| buffer asciiZ |	buffer := super new: size.	asciiZ := AsciiZ new handle: buffer handle.	asciiZ size: size.	asciiZ atAllPutZero.	buffer handle: ExternalAddress nullPointer.	^ asciiZ! !!AsciiZ class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; asString! !!ExternalFunction class methodsFor: 'as yet unclassified'!name: aName library: aLibrary	^self new name: aName library: aLibrary! !!ExternalLibrary class methodsFor: 'as yet unclassified'!huemul	Huemul ifNil: [	"Represents the executable itself"		Huemul := self new.		Huemul open.	].	^ Huemul.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!handle	self object ifNil: [ handle beNull ].	^ handle.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!initialize	super initialize.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!initializePointer	self handle forObject: self object.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!object	^ self objectPointer at: 1! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!object: anObject	self objectPointer at: 1 put: anObject.	self initializePointer.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!objectPointer	object ifNil: [ object := WeakArray new: 1 ].	^ object! !!ExternalArrayProxy methodsFor: 'as yet unclassified'!initializePointer	self handle forArray: self object.! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!fromObject: anObject		^ self new object: anObject; yourself! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!handleFromObject: anObject ifError: aBlock		^ ( self fromObject: anObject ) handle.! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		^ aBlock value! !!ExternalSymbol methodsFor: 'as yet unclassified'!address	handle isNull ifTrue: [ self bind ].	^ handle.! !!ExternalSymbol methodsFor: 'as yet unclassified'!bind	^ library bindSymbol: self.! !!ExternalSymbol methodsFor: 'as yet unclassified'!classFromType: aType	^ Smalltalk at: aType ifAbsent: [ self throwExternalSymbolError ].! !!ExternalSymbol methodsFor: 'as yet unclassified'!library	^ library! !!ExternalSymbol methodsFor: 'as yet unclassified'!library: aLibrary	library := aLibrary! !!ExternalSymbol methodsFor: 'as yet unclassified'!libraryName	^ library name.! !!ExternalSymbol methodsFor: 'as yet unclassified'!name	^name! !!ExternalSymbol methodsFor: 'as yet unclassified'!name: aName	name := aName! !!ExternalSymbol methodsFor: 'as yet unclassified'!name: aName library: aLibrary	self name: aName.	self library: aLibrary! !!ExternalSymbol methodsFor: 'as yet unclassified'!throwExternalSymbolError	^(ExternalSymbolError symbolName: name) signal.! !!ExternalSymbol methodsFor: 'as yet unclassified'!throwNotKnownError	^(ExternalSymbolError symbolName: name) signal.! !!ExecutableFunction methodsFor: 'as yet unclassified'!callingConventionString	self subclassResponsibility.! !!CDeclFunction methodsFor: 'as yet unclassified'!argTypes: anArrayOfTypes	argTypes := anArrayOfTypes.! !!CDeclFunction methodsFor: 'as yet unclassified'!callingConventionString	^ 'cdecl'! !!CDeclFunction methodsFor: 'as yet unclassified'!invoke	^self invokeWithArguments: #()! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1	^self invokeWithArguments: (Array with: arg1)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2	^self invokeWithArguments: (Array with: arg1 with: arg2)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4 with: arg5	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWithArguments: argArray	| argSize argHandleArray returnClass returnHandle |	argSize := argArray size.	argSize = argTypes size ifFalse: [ self throwExternalFunctionError ].	argHandleArray := Array new: argSize.	1 to: argSize do: [ :i |		| argType argClass argHandle arg |		argType := argTypes at: i.		argClass := self classFromType: argType.		arg := argArray at: i.		argHandle := argClass handleFromObject: arg.		argHandleArray at: i put: argHandle.	].	returnHandle := nil.	returnType = #Void ifFalse: [		returnClass := self classFromType: returnType.		returnHandle := returnClass defaultHandlerClass new.	].	handle isNull ifTrue: [ self bind ].	self primInvokeAnswering: returnHandle withArguments: argHandleArray.	returnType = #Void ifTrue: [ ^ nil ].	^ returnClass objectFromHandle: returnHandle.! !!CDeclFunction methodsFor: 'as yet unclassified'!primInvokeAnswering: aReturnValue withArguments: argArray	"Manually invoke the receiver, representing an external function."	<primitive: 204>	^self primitiveFailed! !!CDeclFunction methodsFor: 'as yet unclassified'!returnType: aType	returnType := aType.! !!CDeclFunction methodsFor: 'as yet unclassified'!returnType: aType argTypes: anArrayOfTypes	self returnType: aType.	self argTypes: anArrayOfTypes.! !!ExternalSymbol class methodsFor: 'as yet unclassified'!name: aName library: aLibrary	^self new name: aName library: aLibrary; bind! !!CDeclFunction class methodsFor: 'as yet unclassified'!name: aName library: aLibrary returnType: retType argTypes: argTypesArray	^self new name: aName library: aLibrary;		 returnType: retType argTypes: argTypesArray;		bind! !!ExternalSymbolError methodsFor: 'as yet unclassified'!isResumable	"Determine whether an exception is resumable."	^true! !!ExternalSymbolError methodsFor: 'as yet unclassified'!symbolName	^ symbolName! !!ExternalSymbolError methodsFor: 'as yet unclassified'!symbolName: argument	"Specify the function name that was beiing used."	symbolName := argument! !!ExternalSymbolError class methodsFor: 'as yet unclassified'!symbolName: argument	^self new symbolName: argument; yourself! !!FileDescriptor methodsFor: 'as yet unclassified'!close		self fileDescriptor > 2 ifTrue: [ 		LibC6 default close: self.		self fileDescriptor: -1.	]! !!FileDescriptor methodsFor: 'as yet unclassified'!fileDescriptor	^ SignedInteger objectFromHandle: handle. ! !!FileDescriptor methodsFor: 'as yet unclassified'!fileDescriptor: anInteger	handle := SignedInteger handleFromObject: anInteger. ! !!FileDescriptor methodsFor: 'as yet unclassified'!free		self close.! !!FileDescriptor methodsFor: 'as yet unclassified'!movePosition: offset"relative to actual position"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_CUR' ).	! !!FileDescriptor methodsFor: 'as yet unclassified'!position	^ self movePosition: 0.	! !!FileDescriptor methodsFor: 'as yet unclassified'!position: offset"absolute position"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_SET' ).! !!FileDescriptor methodsFor: 'as yet unclassified'!positionFromEnd: offset"relative to end of file"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_END' ).	! !!FileDescriptor methodsFor: 'as yet unclassified'!read: size	| retValue buffer |	buffer := ExternalBuffer new: size.	retValue := self readBuffer: buffer size: size.	! !!FileDescriptor methodsFor: 'as yet unclassified'!readBuffer: buffer size: size	^ LibC6 default read: self buffer: buffer size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!readString: aString	^ LibC6 default read: self string: aString size: aString size! !!FileDescriptor methodsFor: 'as yet unclassified'!readString: aString size: size	| internalSize |	internalSize := size.	aString size < size ifTrue: [ internalSize := aString size ].	^ LibC6 default read: self string: aString size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!size	| position size |	position := self position.	size := self positionFromEnd: 0.	self position: position.	^ size	! !!FileDescriptor methodsFor: 'as yet unclassified'!writeBuffer: buffer size: size	^ LibC6 default write: self buffer: buffer size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!writeString: aString	^ LibC6 default write: self string: aString size: aString size! !!FileDescriptor methodsFor: 'as yet unclassified'!writeString: aString size: size	| internalSize |	internalSize := size.	aString size < size ifTrue: [ internalSize := aString size ].	^ LibC6 default write: self string: aString size: size! !!FileDescriptor class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalValue! !!FileDescriptor class methodsFor: 'as yet unclassified'!initialize	self initializeStandardDescriptors! !!FileDescriptor class methodsFor: 'as yet unclassified'!initializeStandardDescriptors	StandardDescriptors := Dictionary new.	StandardDescriptors at: #stdout put: (self newFileDescriptor: 0).	StandardDescriptors at: #stdin put: (self newFileDescriptor: 1).	StandardDescriptors at: #stderr put: (self newFileDescriptor: 2).! !!FileDescriptor class methodsFor: 'as yet unclassified'!newFileDescriptor: anInteger	^ self new fileDescriptor: anInteger; yourself.! !!FileDescriptor class methodsFor: 'as yet unclassified'!standardDescriptors	^ StandardDescriptors! !!FileDescriptor class methodsFor: 'as yet unclassified'!stderr	^ StandardDescriptors at: #stderr.! !!FileDescriptor class methodsFor: 'as yet unclassified'!stdin	^ StandardDescriptors at: #stdin.! !!FileDescriptor class methodsFor: 'as yet unclassified'!stdout	^ StandardDescriptors at: #stdout.! !!FileStream methodsFor: 'as yet unclassified'!atEnd	"Answer true if the current position is >= the end of file position.	 1/31/96 sw: subclassResponsibility"	self subclassResponsibility! !!FileStream class methodsFor: 'as yet unclassified'!fileDoesNotExistUserHandling: fullFileName	(GtkMessageDialog question: fullFileName, ' does not exist, create it?') = #yes		ifTrue: [ ^ self new open: fullFileName forWrite: true ].! !!FileStream class methodsFor: 'as yet unclassified'!fileExistsUserHandling: fullFileName	(GtkMessageDialog question: fullFileName, ' exist, overwrite it?') = #yes		ifTrue: [ ^ self new openForOverwrite: fullFileName ].! !!FileStream class methodsFor: 'as yet unclassified'!readOnlyFileDoesNotExistUserHandling: fullFileName	GtkMessageDialog error: fullFileName, ' does not exist'! !!FileDoesNotExistException methodsFor: 'as yet unclassified'!defaultAction	"The default action taken if the exception is signaled."	^self readOnly		ifTrue: [FileStream readOnlyFileDoesNotExistUserHandling: self fileName]		ifFalse: [FileStream fileDoesNotExistUserHandling: self fileName]! !!GIRBuilder methodsFor: 'as yet unclassified'!compiledMethod	| bytecodes |	bytecodes := self bytecodes.	bytecodes ifNil: [ ^ nil ].	^ CompiledMethod new		primitive: 0;		numArgs: self numArgs;		numTemps: self numTemps;		literals: self literals;		relocationInfo: self relocationInfo;		bytecodes: bytecodes;		debugInfo: debugInfo;		source: source;		relocate.! !!GPointer methodsFor: 'as yet unclassified'!initialize	handle := self class defaultHandlerClass new.! !!GPointer class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalAddress! !!GPointer class methodsFor: 'as yet unclassified'!handle: aByteArray	^self basicNew handle: aByteArray; yourself! !!GObject class methodsFor: 'as yet unclassified'!handleFromObject: object	^ object handle.	! !!Gtk methodsFor: 'as yet unclassified'!initialize	self initializeGtkLibrary.	self startMainLoop.! !!Gtk class methodsFor: 'as yet unclassified'!main
"Starts the Gtk main loop"
Gtk default startMainLoop.! !!Gtk class methodsFor: 'as yet unclassified'!shutDown: quiting	"Quits the Gtk main loop"	Default ifNotNil: [		Default quitMainLoop.		Default close.		Default := nil.	].! !!GtkDemoStockIds methodsFor: 'as yet unclassified'!initialize	| model tree |	model := GtkListStore new: {String. String. String. String}.	GtkStockItem allStocks do: [ :ea |		ea ifNotNil: [			model append: {				ea stockId asGtkStockId.				ea stockId.				ea label.				Gtk acceleratorName: ea keyval asCharacter modifier: ea modifier}]].	tree := GtkTreeView model: model.	self createFirstColumn: tree.	tree appendColumns: {		GtkTreeViewColumn title: 'Label' text: 2.		GtkTreeViewColumn title: 'Accel' text: 3.		GtkTreeViewColumn title: 'ID' text: 0}.	tree selection when: #changed send: #onItemChanged: to: self withArgumentsFirst: {tree}.			self container: (GtkHBox spacing: 5).	self container		packStart: (GtkScrolledWindow withChild: tree);		packEnd: self createInfoFrame expand: false fill: false! !!GtkDemoStockIds methodsFor: 'as yet unclassified'!onItemChanged: aTreeView	aTreeView selectedRow in: [:row |		idLabel label: row first.		nameLabel label: '#', row second.		accelLabel label: row third.		iconImage stock: row second iconSize: #dialog]! !!InMidstOfFileinNotification methodsFor: 'as yet unclassified'!defaultAction	^ self resume: false! !!LibC methodsFor: 'as yet unclassified'!closeLibrary	cLibrary closeLibrary.	cLibrary := nil.! !!LibC methodsFor: 'as yet unclassified'!initializeCLibrary	cLibrary := ExternalLibrary new.	cLibrary name: 'libc.so.6'.	cLibrary openLibrary.! !!LibC class methodsFor: 'as yet unclassified'!shutDown: quiting	"Quits the Gtk main loop"	self default closeLibrary.	Default := nil.! !!LibC6 methodsFor: 'as yet unclassified'!close: fd	| retValue |	retValue := ( self cDeclFunctionNamed: #close ) invokeWith: fd.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #close ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!errno	^ (self libraryDataNamed: #errno) value.	! !!LibC6 methodsFor: 'as yet unclassified'!errno: errno	(self libraryDataNamed: #errno) value: errno.	! !!LibC6 methodsFor: 'as yet unclassified'!free: anExternalBuffer	( self cDeclFunctionNamed: #free ) invokeWith: anExternalBuffer.	! !!LibC6 methodsFor: 'as yet unclassified'!getCurrentDirName	| retValue |	[ retValue := ( self cDeclFunctionNamed: 'get_current_dir_name' asSymbol ) invoke ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: 'get_current_dir_name' asSymbol ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!getEnv: envVariable	^ ( self cDeclFunctionNamed: #getenv ) invokeWith: envVariable.! !!LibC6 methodsFor: 'as yet unclassified'!getpid	^ (self cDeclFunctionNamed: #getpid) invoke.	! !!LibC6 methodsFor: 'as yet unclassified'!initialize	super initialize.	self initializeUniStd.	self initializeStdLib.	self initializeString.	self initializeFCntl.	self initializeStdIO.	self initializeErrNO.! !!LibC6 methodsFor: 'as yet unclassified'!initializeErrNO	self initializeLibraryDataNamed: #errno type: #SignedInteger.! !!LibC6 methodsFor: 'as yet unclassified'!initializeFCntl	self initializeCDeclFunctionNamed: #open returnType: #FileDescriptor argTypes: #( AsciiZ SignedInteger UnsignedInteger ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeStdIO	self initializeCDeclFunctionNamed: #printf  returnType: #SignedInteger argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: #perror  returnType: #Void argTypes: #( AsciiZ  ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeStdLib	self initializeCDeclFunctionNamed: #malloc  returnType: #ExternalBuffer argTypes: #( UnsignedInteger  ).	self initializeCDeclFunctionNamed: #free  returnType: #Void argTypes: #( ExternalBuffer  ).	self initializeCDeclFunctionNamed: #getenv  returnType: #AsciiZ argTypes: #( AsciiZ ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeString	self initializeCDeclFunctionNamed: #strlen returnType: #UnsignedInteger argTypes: #( AsciiZ ).	self initializeCDeclFunctionNamed: #strcat returnType: #AsciiZ argTypes: #( AsciiZ AsciiZ ).	self initializeCDeclFunctionNamed: #strcpy returnType: #AsciiZ argTypes: #( AsciiZ AsciiZ ).	self initializeCDeclFunctionNamed: #strerror returnType: #ReadOnlyAsciiZ argTypes: #( SignedInteger ).	self initializeCDeclFunctionNamed: #memset returnType: #ExternalBuffer argTypes: #( ExternalBuffer SignedInteger  UnsignedInteger ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeUniStd	self initializeCDeclFunctionNamed: #getpid  returnType: #UnsignedInteger argTypes: #().	self initializeCDeclFunctionNamed: 'get_current_dir_name' asSymbol  returnType: #AsciiZ argTypes: #().	self initializeCDeclFunctionNamed: #close  returnType: #SignedInteger argTypes: #( FileDescriptor ).	self initializeCDeclFunctionNamed: #lseek  returnType: #UnsignedInteger argTypes: #( FileDescriptor UnsignedInteger SignedInteger ).	self initializeCDeclFunctionNamed: #read  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalBuffer UnsignedInteger ).	self initializeCDeclFunctionNamed: #write  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalBuffer UnsignedInteger )."Redefinition of read for Strings"	symbolCache at: #readString put: (CDeclFunction name: #read library: self  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalArrayProxy UnsignedInteger ) )."Redefinition of write for Strings"	symbolCache at: #writeString put: (CDeclFunction name: #write library: self  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalArrayProxy UnsignedInteger ) ).! !!LibC6 methodsFor: 'as yet unclassified'!lseek: fileDescriptor offset: offset whence: whence	| returnValue |	returnValue := (self cDeclFunctionNamed: #lseek) invokeWith: fileDescriptor with: offset with: whence.	returnValue < 0 ifTrue: [		self throwErrorForExternalFunctionNamed: #lseek.		^ nil.	].	^ returnValue.	! !!LibC6 methodsFor: 'as yet unclassified'!malloc: size	| retValue |	[ retValue := ( self cDeclFunctionNamed: #malloc ) invokeWith: size ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: #malloc withMessage: 'can not allocate memory' ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!memSet: buffer constant: c count: n	^ (self cDeclFunctionNamed: #memset) invokeWith: buffer with: c with: n.	! !!LibC6 methodsFor: 'as yet unclassified'!open: path flags: flags	^ self open: path flags: flags mode: 8r644	! !!LibC6 methodsFor: 'as yet unclassified'!open: path flags: flags mode: mode	| fileDescriptor |	fileDescriptor := (self cDeclFunctionNamed: #open) invokeWith: path with: flags with: mode.	fileDescriptor fileDescriptor < 0 ifTrue: [		self throwErrorForExternalFunctionNamed: #open.		^ nil.	].	^ fileDescriptor.	! !!LibC6 methodsFor: 'as yet unclassified'!perror: aString	( self cDeclFunctionNamed: #perror ) invokeWith: aString.	! !!LibC6 methodsFor: 'as yet unclassified'!printf: aString	^ ( self cDeclFunctionNamed: #printf ) invokeWith: aString.	! !!LibC6 methodsFor: 'as yet unclassified'!read: fd buffer: buffer size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #read ) invokeWith: fd with: buffer with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #read ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!read: fd string: aString size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #readString ) invokeWith: fd with: aString with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #readString ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!strCat: destString with: sourceString	^ ( self cDeclFunctionNamed: #strcat ) invokeWith: destString with: sourceString.	! !!LibC6 methodsFor: 'as yet unclassified'!strCpy: destString with: sourceString	^ ( self cDeclFunctionNamed: #strcpy ) invokeWith: destString with: sourceString.	! !!LibC6 methodsFor: 'as yet unclassified'!strError: errno	| retValue |	[ retValue := ( self cDeclFunctionNamed: #strerror ) invokeWith: errno ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: #strerror ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!strLen: string	^ ( self cDeclFunctionNamed: #strlen ) invokeWith: string	! !!LibC6 methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName	^ self throwErrorForExternalFunctionNamed: functionName withMessage: (self strError: self errno).	! !!LibC6 methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName withMessage: aString	| error |	error := ExternalFunctionError functionName: functionName.	error messageText: aString.	^ error signal.	! !!LibC6 methodsFor: 'as yet unclassified'!valueForLSeekDirectiveNamed: aString	^ LSeekDirectives at: aString asSymbol.	! !!LibC6 methodsFor: 'as yet unclassified'!valueForOpenFlagNamed: aString	^ OpenFlags at: aString asSymbol.	! !!LibC6 methodsFor: 'as yet unclassified'!write: fd buffer: buffer size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #write ) invokeWith: fd with: buffer with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #write ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!write: fd string: aString size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #writeString ) invokeWith: fd with: aString with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #writeString ].	^ retValue.	! !!LibC6 class methodsFor: 'as yet unclassified'!initialize	self initializeOpenFlags.	self initializeLSeekDirectives.! !!LibC6 class methodsFor: 'as yet unclassified'!initializeLSeekDirectives	| lSeekDirectives |		lSeekDirectives := Dictionary new.	lSeekDirectives at: 'SEEK_SET' put: 0.	lSeekDirectives at: 'SEEK_CUR' put: 1.	lSeekDirectives at: 'SEEK_END' put: 2.	LSeekDirectives := lSeekDirectives! !!LibC6 class methodsFor: 'as yet unclassified'!initializeOpenFlags	| flagArray openFlags |		flagArray := #( 		('O_RDONLY'		0)		('O_WRONLY'		8r1)		('O_RDWR'		8r2)		('O_CREAT'		8r100)			('O_EXCL'			8r200)			('O_NOCTTY'		8r400)			('O_TRUNC'		8r1000)			('O_APPEND'		8r2000)		('O_NONBLOCK'	8r4000)		('O_SYNC'		8r10000)		('O_ASYNC'		8r20000)	).	openFlags := Dictionary new.	flagArray do: [ :i |		openFlags at: i first asSymbol put: i second	].	OpenFlags := openFlags! !!LibC6 class methodsFor: 'as yet unclassified'!moduleName	^ 'libc.so.6'.! !!LibExample methodsFor: 'as yet unclassified'!getpid	^ GETPID invoke! !!LibExample class methodsFor: 'as yet unclassified'!getpid	^ GETPID! !!LibExample class methodsFor: 'as yet unclassified'!initialize	GETPID := CDeclFunction name: 'getpid' libraryNamed: 'libc.so.6' returnType: #UnsignedInteger argTypes: #().! !!LibReadLine methodsFor: 'as yet unclassified'!addHistory: aString	( self cDeclFunctionNamed: 'add_history' asSymbol ) invokeWith: aString.! !!LibReadLine methodsFor: 'as yet unclassified'!initialize	super initialize.	self initializeCDeclFunctionNamed: #readline  returnType: #AsciiZ argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'add_history' asSymbol returnType: #Void argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'read_history' asSymbol returnType: #SignedInteger argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'write_history' asSymbol returnType: #SignedInteger argTypes: #( AsciiZ  ).! !!LibReadLine methodsFor: 'as yet unclassified'!readHistory: aFileName	| errno |	errno := ( self cDeclFunctionNamed: 'read_history' asSymbol ) invokeWith: aFileName.	errno = 0 ifFalse: [ self throwErrorForExternalFunctionNamed: 'read_history' asSymbol errno: errno ].	^ errno.! !!LibReadLine methodsFor: 'as yet unclassified'!readline: prompt	^ ( self cDeclFunctionNamed: #readline ) invokeWith: prompt.! !!LibReadLine methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName errno: errno	| error |	error := ExternalFunctionError functionName: functionName.	error messageText: (LibC6 default strError: errno).	^ error signal.! !!LibReadLine methodsFor: 'as yet unclassified'!writeHistory: aFileName	| errno |	errno := ( self cDeclFunctionNamed: 'write_history' asSymbol ) invokeWith: aFileName.	errno = 0 ifFalse: [ self throwErrorForExternalFunctionNamed: 'write_history' asSymbol errno: errno ].	^ errno.! !!LibReadLine class methodsFor: 'as yet unclassified'!moduleName	^ 'libreadline.so.5'.! !!LibraryData methodsFor: 'as yet unclassified'!primitiveGetValue: valueHandle	<primitive: 216>	^self primitiveFailed! !!LibraryData methodsFor: 'as yet unclassified'!primitiveSetValue: valueHandle	<primitive: 217>	^self primitiveFailed! !!LibraryData methodsFor: 'as yet unclassified'!type	^ type.! !!LibraryData methodsFor: 'as yet unclassified'!type: aType	type := aType.! !!LibraryData methodsFor: 'as yet unclassified'!value	| valueClass valueHandle |	valueClass := self classFromType: type.	valueHandle := valueClass defaultHandlerClass new.	handle isNull ifTrue: [ self bind ].	self primitiveGetValue: valueHandle.	^ valueClass objectFromHandle: valueHandle.! !!LibraryData methodsFor: 'as yet unclassified'!value: aValue	| argHandle argClass |	argClass := self classFromType: type.	argHandle := argClass handleFromObject: aValue.	handle isNull ifTrue: [ self bind ].	self primitiveSetValue: argHandle! !!LibraryData class methodsFor: 'as yet unclassified'!name: aName library: aLibrary type: type	^self new name: aName library: aLibrary;		type: type;		bind! !!Metaclass methodsFor: 'as yet unclassified'!addObsoleteSubclass: aClass	"Do nothing."! !!Metaclass methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return true if it is safe to zap the method dictionary on #obsolete"	thisClass == nil		ifTrue:[^true]		ifFalse:[^thisClass canZapMethodDictionary]! !!Metaclass methodsFor: 'as yet unclassified'!isSystemDefined	"Answer false if I am a UniClass (an instance-specific lightweight class)"	^ true! !!NativeFunction methodsFor: 'as yet unclassified'!callingConventionString	^ 'native'! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver	^self invokeReceiver: receiver withArguments: #()! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1	^self invokeReceiver: receiver withArguments: (Array with: arg1)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4 with: arg5	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver withArguments: argArray	handle isNull ifTrue: [ self bind ].	^ self primInvokeReceiver: receiver withArguments: argArray.! !!NativeFunction methodsFor: 'as yet unclassified'!primInvokeReceiver: receiver withArguments: argArray	"Manually invoke the receiver, representing an native function."	<primitive: 197>	^self primitiveFailed! !!ObjectTest methodsFor: 'as yet unclassified'!testBecome	"self debug: #testBecome"	"this test should that all the variables pointing to an object are pointing now to another one, and all      object pointing to the other are pointing to the object"	| pt1 pt2 pt3 |	pt1 := 0@0.	pt2 := pt1.	pt3 := 100@100.	pt1 become: pt3.	self assert: pt2 = (100@100).	self assert: pt3 = (0@0).	self assert: pt1 = (100@100).! !!ObjectTest methodsFor: 'as yet unclassified'!testBecomeForward	"self debug: #testBecomeForward"	"this test should that all the variables pointing to an object are pointing now to another one.	Not that this inverse is not true. This kind of become is called oneWayBecome in VW"	| pt1 pt2 pt3 |	pt1 := 0@0.	pt2 := pt1.	pt3 := 100@100.	pt1 becomeForward: pt3.	self assert: pt2 = (100@100).	self assert: pt3 == pt2.	self assert: pt1 = (100@100)! !!PrimitiveType class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalValue! !!PrimitiveType class methodsFor: 'as yet unclassified'!handleFromObject: anObject	^ self handleFromObject: anObject ifError: [ self throwTypeConvertionError ]! !!PrimitiveType class methodsFor: 'as yet unclassified'!handleFromObject: object ifError: aBlock	self subclassResponsibility.! !!PrimitiveType class methodsFor: 'as yet unclassified'!objectFromHandle: handle	^ self objectFromHandle: handle ifError: [  self throwTypeConvertionError ]! !!PrimitiveType class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock	self subclassResponsibility.! !!PrimitiveType class methodsFor: 'as yet unclassified'!throwTypeConvertionError	^ TypeConvertionError new signal! !!IntegerType class methodsFor: 'as yet unclassified'!handleFromObject: anInteger ifError: aBlock	| handle |		(self checkType: anInteger) ifFalse: [ ^ aBlock value ].	handle := ExternalValue new.	self store: anInteger in: handle.	^ handle.	! !!IntegerType class methodsFor: 'as yet unclassified'!isBigEndian	^  false! !!IntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	self subclassResponsibility.! !!IntegerType class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: errorBlock	| value |		value := self loadFrom: handle.	(value > self max ) ifTrue: [ ^ errorBlock value ].	^ value.! !!Process methodsFor: 'as yet unclassified'!primitiveBeInitialProcess	<primitive: 196>	self primitiveFailed! !!ProcessorScheduler methodsFor: 'as yet unclassified'!activeProcess	^ self primActiveProcess! !!ProcessorScheduler methodsFor: 'as yet unclassified'!primActiveProcess	<primitive: 195>	self primitiveFail.! !!ProcessorScheduler methodsFor: 'as yet unclassified'!startUp	| firstProcess |"	(processList isNil or: [ processList isEmpty not ]) ifTrue: [ self initialize ]."	self initialize.	firstProcess := Process new.	firstProcess name: 'Init'.	firstProcess priority: self userSchedulingPriority.	firstProcess state: #running."	firstProcess threadData: self activeThreadData."	firstProcess primitiveBeInitialProcess.! !!ReadOnlyAsciiZ methodsFor: 'as yet unclassified'!asString	^ handle toString.! !!ReadOnlyAsciiZ class methodsFor: 'as yet unclassified'!handleFromObject: aByteArray ifError: aBlock	"Can not be used as arguments"	aBlock value.! !!ReadOnlyAsciiZ class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; asString! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!addressRelativeTo: bytecodes	| functionAddress bytecodesAddress |	functionAddress := self function address asInteger.	bytecodesAddress := (ExternalAddress forArray: bytecodes ) asInteger.	^ functionAddress - bytecodesAddress - offset - 4! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!function	^ self library functionNamed: functionName.! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!functionName	^ functionName! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!functionName: aSymbol	^ functionName := aSymbol! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!library	^ Executable default! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!patch: bytecodes	self patch: bytecodes with: (self addressRelativeTo: bytecodes).! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!patch: bytecodes with: value	bytecodes longAt: (offset + 1) put: value bigEndian: false.! !!FunctionRelocation methodsFor: 'as yet unclassified'!addressRelativeTo: bytecodes	^ self primAddressRelativeTo: bytecodes! !!FunctionRelocation methodsFor: 'as yet unclassified'!primAddressRelativeTo: bytecodes	<primitive: 155>	self primitiveFail.! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!defaultLibraryClass	^ NativeLibrary! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!library 		^ self defaultLibraryClass named: libraryName! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!libraryName	^ libraryName! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!libraryName: aSymbol	^ libraryName := aSymbol! !!ExternalFunctionRelocation methodsFor: 'as yet unclassified'!defaultLibraryClass	^ ExternalLibrary2! !!SequenceableCollection methodsFor: 'as yet unclassified'!asTraitComposition	"For convenience the composition {T1. T2 ...} is the same as T1 + T2 + ..."	^self isEmpty		ifFalse: [			self size = 1				ifTrue: [self first asTraitComposition]				ifFalse: [					self copyWithoutFirst 						inject: self first						into: [:left :right | left + right]]]		ifTrue: [			TraitComposition new]! !!Array methodsFor: 'as yet unclassified'!elementsExchangeIdentityWith: otherArray	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsExchangeIdentityWith: otherArray.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!elementsForwardIdentityTo: otherArray	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsForwardIdentityTo: otherArray.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!elementsForwardIdentityTo: otherArray copyHash: copyHash	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsForwardIdentityTo: otherArray copyHash: copyHash.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!primElementsExchangeIdentityWith: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  At the same time, all pointers to the elements of otherArray are replaced by pointers to the corresponding elements of this array.  The identityHashes remain with the pointers rather than with the objects so that objects in hashed structures should still be properly indexed after the mutation."	<primitive: 128>	otherArray class == Array ifFalse: [^ self error: 'arg must be array'].	self size = otherArray size ifFalse: [^ self error: 'arrays must be same size'].	(self anySatisfy: [:obj | obj class == SmallInteger]) ifTrue: [^ self error: 'can''t become SmallIntegers'].	(otherArray anySatisfy: [:obj | obj class == SmallInteger]) ifTrue: [^ self error: 'can''t become SmallIntegers'].	"Must have failed because not enough space in forwarding table (see ObjectMemory-prepareForwardingTableForBecoming:with:twoWay:).  Do GC and try again only once"	(Smalltalk bytesLeft: true) = Smalltalk primitiveGarbageCollect		ifTrue: [^ self primitiveFailed].	^ self elementsExchangeIdentityWith: otherArray! !!Array methodsFor: 'as yet unclassified'!primElementsForwardIdentityTo: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  The identityHashes remain with the pointers rather than with the objects so that the objects in this array should still be properly indexed in any existing hashed structures after the mutation."	<primitive: 72>	self primitiveFailed! !!Array methodsFor: 'as yet unclassified'!primElementsForwardIdentityTo: otherArray copyHash: copyHash	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  The identityHashes remain with the pointers rather than with the objects so that the objects in this array should still be properly indexed in any existing hashed structures after the mutation."	<primitive: 249>	self primitiveFailed! !!ExternalValue methodsFor: 'as yet unclassified'!beNull	"Make the receiver a NULL pointer"	self atAllPut: 0.! !!ExternalValue methodsFor: 'as yet unclassified'!isNull	^(self basicAt: 1) = 0	and: (self basicAt: 2) = 0	and: (self basicAt: 3) = 0	and: (self basicAt: 4) = 0	! !!ExternalValue class methodsFor: 'as yet unclassified'!initialize	Smalltalk addToStartUpList: self.! !!ExternalValue class methodsFor: 'as yet unclassified'!new	"External addresses are always 4 bytes long"	^super new: 4! !!ExternalValue class methodsFor: 'as yet unclassified'!new: n	"You better don't try this..."	^self shouldNotImplement! !!ExternalValue class methodsFor: 'as yet unclassified'!startUp: resuming	resuming ifTrue: [		self allInstancesDo: [ :addr |			addr beNull		]	].! !!SharedPool class methodsFor: 'as yet unclassified'!bindingOf: varName	"Answer the binding of some variable resolved in the scope of the receiver"	| aSymbol binding |	aSymbol := varName asSymbol.	"First look in classVar dictionary."	binding := self classPool bindingOf: aSymbol.	binding ifNotNil:[^binding].	"Next look in shared pools."	self sharedPools do:[:pool | 		binding := pool bindingOf: aSymbol.		binding ifNotNil:[^binding].	].	"subclassing and environment are not preserved"	^nil! !!SharedPool class methodsFor: 'as yet unclassified'!bindingsDo: aBlock	^self classPool bindingsDo: aBlock! !!SharedPool class methodsFor: 'as yet unclassified'!classBindingOf: varName	"For initialization messages grant the regular scope"	^super bindingOf: varName! !!SharedPool class methodsFor: 'as yet unclassified'!hasBindingThatBeginsWith: aString	"Answer true if the receiver has a binding that begins with aString, false otherwise"	"First look in classVar dictionary."	(self classPool hasBindingThatBeginsWith: aString) ifTrue:[^true].	"Next look in shared pools."	self sharedPools do:[:pool | 		(pool hasBindingThatBeginsWith: aString) ifTrue: [^true]].	^false! !!SharedPool class methodsFor: 'as yet unclassified'!includesKey: aName	"does this pool include aName"	^(self bindingOf: aName) notNil! !!SharedPool class methodsFor: 'as yet unclassified'!keysDo: aBlock"A hopefully temporary fix for an issue arising from miss-spelled variable names in code being compiled. The correction code (see Class>possibleVariablesFor:continuedFrom: assumes that sharedPools are Dictionaries. The proper fix would involve making sure all pools are actually subclasses of SharedPool, which they are not currently."	self bindingsDo:[:b|		aBlock value: b key]! !!Shell methodsFor: 'as yet unclassified'!display: string	| buffer |		buffer := AsciiZ fromString: string.	^ FileDescriptor stdout writeBuffer: buffer size: buffer size.! !!Shell methodsFor: 'as yet unclassified'!input: prompt	^ LibReadLine default readline: prompt! !!Shell methodsFor: 'as yet unclassified'!main	| line value failed anotherLine buffer |	LibReadLine default readHistory: self historyFileName.	[		anotherLine := false.		buffer := ''.		[ 	| prompt |			prompt := anotherLine ifTrue: [ '' ] ifFalse: [ '> ' ].			line _ self input: prompt.			line isEmpty				ifTrue: [ true ] 				ifFalse: [					(line last = $\)						ifTrue: [							anotherLine := true.							line at: line size put: Character lf.						]						ifFalse: [ anotherLine := false ].					buffer := buffer, line.					anotherLine				]		] whileTrue. 		buffer = 'quit' or: [ buffer = 'save' ]	] whileFalse: [		self addToHistory: buffer.		failed _ false.		value _ Compiler new evaluate: buffer in: nil to: nil notifying: self ifFail: [ failed _ true].		failed ifFalse: [ self display: (value printString); lf ]	].	LibReadLine default writeHistory: self historyFileName.	buffer = 'save' ifTrue: [ Smalltalk snapshotAndQuit ].	^value.! !!SignedIntegerType class methodsFor: 'as yet unclassified'!checkType: value	^ value isInteger and: [ value >= self min and: [ value <= self max ] ]! !!SignedIntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	^ handle longAt: 1 bigEndian: self isBigEndian.! !!SignedIntegerType class methodsFor: 'as yet unclassified'!store: anInteger in: handle	handle longAt: 1 put: anInteger bigEndian: self isBigEndian.! !!SignedByte class methodsFor: 'as yet unclassified'!max			^ 127! !!SignedByte class methodsFor: 'as yet unclassified'!min			^ -128! !!SignedInteger class methodsFor: 'as yet unclassified'!max			^ 2147483647! !!SignedInteger class methodsFor: 'as yet unclassified'!min			^ -2147483648! !!SignedShortInteger class methodsFor: 'as yet unclassified'!max			^ 32767! !!SignedShortInteger class methodsFor: 'as yet unclassified'!min			^ -32768! !!SourceReference methodsFor: 'as yet unclassified'!sourceFrom: aString	self hasEmptySourceReference ifTrue: [ ^ '' ].	^ aString copyFrom: sourceStart to: sourceStop! !!StandardFileStream class methodsFor: 'as yet unclassified'!retryWithGC: execBlock until: testBlock forFileNamed: fullName	"Re-implemented to only force GC if a file with the given name exists"	| blockValue foundIt |	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	"See if we have a file with the given name"	foundIt := self registry keys "hold on strongly for now" 		anySatisfy:[:file| file name sameAs: fullName].	foundIt ifFalse:[^blockValue].	Smalltalk garbageCollectMost.	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollect.	^execBlock value.! !!SystemDictionary methodsFor: 'as yet unclassified'!forgetClass: aClass logged: aBool 	"Delete the class, aClass, from the system.	Note that this doesn't do everything required to dispose of a class - to do that use Class>>removeFromSystem."	aBool ifTrue: [SystemChangeNotifier uniqueInstance classRemoved: aClass fromCategory: aClass category].			SystemOrganization removeElement: aClass name.	self removeFromStartUpList: aClass.	self removeFromShutDownList: aClass.	self removeKey: aClass name ifAbsent: [].	self flushClassNameCache! !!SystemDictionary methodsFor: 'as yet unclassified'!removeClassNamed: aName	"Invoked from fileouts:  if there is currently a class in the system named aName, then remove it.  If anything untoward happens, report it in the Transcript.  "	| oldClass |	(oldClass _ self at: aName asSymbol ifAbsent: [nil]) == nil		ifTrue:			[Transcript cr; show: 'Removal of class named ', aName, ' ignored because ', aName, ' does not exist.'.			^ self].	oldClass removeFromSystem! !!SystemDictionary methodsFor: 'as yet unclassified'!startUp	Processor startUp.	ProcessorScheduler startUp.	self processStartUpList: true.	self installLowSpaceWatcher.! !!SystemTracer methodsFor: 'as yet unclassified'!getAligned: size	^ (( size + 3 ) bitShift: -2) bitShift: 2.! !!TraitBehavior methodsFor: 'as yet unclassified'!addUser: aClassOrTrait	users add: aClassOrTrait! !!TraitBehavior methodsFor: 'as yet unclassified'!classesComposedWithMe	^users gather: [:u | u classesComposedWithMe]! !!TraitBehavior methodsFor: 'as yet unclassified'!initialize	self methodDict: Dictionary new.	self traitComposition: nil.	users _ IdentitySet new.! !!TraitBehavior methodsFor: 'as yet unclassified'!removeUser: aClassOrTrait	users remove: aClassOrTrait ifAbsent: []! !!TraitBehavior methodsFor: 'as yet unclassified'!users	^users! !!TraitComposition methodsFor: 'as yet unclassified'!assertValidUser: aBehavior	"Assert that this trait composition set for aBehavior	does not introduce a cycle."		(self allTraits includes: aBehavior) ifTrue: [		TraitCompositionException signal: 'Cycle in compositions:  The composition (in)directly includes this trait!!']! !!TraitComposition methodsFor: 'as yet unclassified'!methodDescriptionsForSelector: aSymbol	"Return a collection of TraitMethodDescriptions for aSymbol and all the 	aliases of aSymbol."	| selectors collection |	selectors _ IdentitySet with: aSymbol.	self transformations do: [:each |		selectors addAll: (each aliasesForSelector: aSymbol)].	collection _ OrderedCollection new: selectors size.	selectors do: [:each |		collection add: (self methodDescriptionForSelector: each)].	^collection! !!TraitDescription methodsFor: 'as yet unclassified'!trait	"for compatibility with TraitTransformations"	^ self! !!TraitDescription methodsFor: 'as yet unclassified'!updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil	| currentCategory effectiveCategory sel changedCategories composition |	changedCategories _ IdentitySet new.	composition := self hasTraitComposition		ifTrue: [self traitComposition]		ifFalse: [TraitComposition new].	(composition methodDescriptionsForSelector: aSymbol) do: [:each |		sel _ each selector.		(self includesLocalSelector: sel) ifFalse: [			currentCategory _ self organization categoryOfElement: sel.			effectiveCategory _ each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.			effectiveCategory isNil ifTrue: [				currentCategory ifNotNil: [changedCategories add: currentCategory].				self organization removeElement: sel.			] ifFalse: [				((currentCategory isNil or: [currentCategory == ClassOrganizer ambiguous or: [currentCategory == oldCategoryOrNil]]) and: [currentCategory ~~ effectiveCategory]) ifTrue: [					currentCategory ifNotNil: [changedCategories add: currentCategory].					self organization 						classify: sel 						under: effectiveCategory						suppressIfDefault: false]]]].	^ changedCategories! !!TraitDescription methodsFor: 'as yet unclassified'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	(self includesSelector: aSelector)		ifTrue: [^ self organization categoryOfElement: aSelector]		ifFalse: [^nil]! !!Trait methodsFor: 'as yet unclassified'!initialize	super initialize.	classTrait _ ClassTrait for: self! !!TranscriptCodeView class methodsFor: 'as yet unclassified'!initialize	Smalltalk addToStartUpList: self.! !!TranscriptCodeView class methodsFor: 'as yet unclassified'!startUp: resuming	resuming ifTrue: [		TranscriptCodeBuffer := nil.	].! !!TranscriptStream methodsFor: 'as yet unclassified'!open	TranscriptCodeEditor open.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!atEnd	position ifNil: [ ^ nil ].	^ position >= readLimit! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!close	"Close this file."	fileID ifNotNil: [		fileID close.		fileID := nil.		position := nil.	].! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!open: fileName flags: flags	[ fileID := LibC6 default open: fileName flags: flags ]		on: ExternalFunctionError		do: [ ^ nil ].	name := fileName.	readLimit := fileID size.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!open: fileName forWrite: writeMode 	| flags |	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	flags := writeMode 		ifTrue: [ LibC6 default valueForOpenFlagNamed: 'O_RDWR' ]		ifFalse: [ LibC6 default valueForOpenFlagNamed: 'O_RDONLY' ].	rwmode := writeMode.	^ self open: fileName flags: flags.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!openForOverwrite: fileName	| flags |	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	flags := ((LibC6 default valueForOpenFlagNamed: 'O_RDWR') 			bitOr: ( LibC6 default valueForOpenFlagNamed: 'O_TRUNC' )) 			bitOr: ( LibC6 default valueForOpenFlagNamed: 'O_CREAT' ).	rwmode := true.	^ self open: fileName flags: flags.! !!BufferedFileStream methodsFor: 'as yet unclassified'!close	"Close this file."	self flush.	^ super close.! !!BufferedFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	self subclassResponsibility! !!BufferedFileStream methodsFor: 'as yet unclassified'!defaultBufferSize	^ DefaultBufferSize.! !!BufferedFileStream methodsFor: 'as yet unclassified'!flush	| bufferPosition bufferSize |	fileID ifNil: [ ^ nil ].	rwmode ifFalse: [ ^ nil ].	bufferPosition := position truncateTo: (collection size).	bufferSize := collection size min: ( readLimit - bufferPosition).	fileID position: bufferPosition.	bufferSize > 0 ifTrue: [ fileID writeString: collection size: bufferSize ].	 ! !!BufferedFileStream methodsFor: 'as yet unclassified'!initializeBuffer	| bufferSize |	position := 0.	collection := self defaultBufferClass new: self defaultBufferSize.	bufferSize := collection size min: readLimit.	bufferSize > 0 ifTrue: [ fileID readString: collection size: bufferSize ]. ! !!BufferedFileStream methodsFor: 'as yet unclassified'!next	| byte |	byte := self peek.	self position: position + 1.	^ byte! !!BufferedFileStream methodsFor: 'as yet unclassified'!nextPut: char	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	position ifNil: [ self position: 0 ].	collection at: (position \\ (collection size)) + 1put: char.	self position: position + 1.	^ char! !!BufferedFileStream methodsFor: 'as yet unclassified'!open: fileName flags: flags	(super open: fileName flags: flags) ifNotNil: [ self initializeBuffer ].! !!BufferedFileStream methodsFor: 'as yet unclassified'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	position ifNil: [ self position: 0 ].	self atEnd ifTrue: [^ nil ].	^ collection at: (position \\ (collection size)) + 1.! !!BufferedFileStream methodsFor: 'as yet unclassified'!position: newPosition	| oldBufferPosition newBufferPosition bufferSize |	fileID ifNil: [ ^nil ].	newPosition < 0 ifTrue: [ ^nil ]."	((newPosition > readLimit) and: [ rwmode not ])  ifTrue: [ ^nil ]."	newPosition > readLimit ifTrue: [		rwmode ifTrue: [ readLimit := newPosition ] ifFalse: [ ^nil ]	].	oldBufferPosition := position truncateTo: (collection size).	newBufferPosition := newPosition truncateTo: (collection size).	newBufferPosition = oldBufferPosition ifFalse: [ 		self flush.		fileID position: newBufferPosition.		bufferSize := collection size min: ( readLimit - newBufferPosition).		collection := self defaultBufferClass new: self defaultBufferSize.		bufferSize > 0 ifTrue: [ fileID readString: collection size: bufferSize ].	].	position := newPosition."	rwmode ifTrue: [ readLimit := newPosition ]."	^ position.! !!BinaryFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	^ ByteArray! !!TextFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	^ String! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!concreteStream	"Who should we really direct class queries to?  "	^ UnbufferedFileStream.! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!fileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new open: fileName forWrite: true! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!forceNewFileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new openForOverwrite: fileName! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!readOnlyFileNamed: fileName 	"Open an existing file with the given name for reading."	| f |	f := self new open: fileName forWrite: false.	^ f isNil		ifFalse: [f]		ifTrue: ["File does not exist..."			((FileDoesNotExistException fileName: fileName) readOnly: true) signal].	"StandardFileStream readOnlyFileNamed: 'kjsd.txt' "! !!BufferedFileStream class methodsFor: 'as yet unclassified'!initialize	self initializeDefaultBufferSize.! !!BufferedFileStream class methodsFor: 'as yet unclassified'!initializeDefaultBufferSize	DefaultBufferSize := 4096.! !!BufferedFileStream class methodsFor: 'as yet unclassified'!new	^ TextFileStream new.! !!UnhandledError methodsFor: 'as yet unclassified'!devDefaultAction	"The current computation is terminated. The cause of the error should be logged or reported to the user. If the program is operating in an interactive debugging environment the computation should be suspended and the debugger activated."	(GtkMessageDialog question: exception messageText, ', debug it?' ) = #yes		ifTrue: [ ^Processor activeProcess debugError: exception ]."	^ Processor activeProcess terminate."! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!checkType: value	^ value isInteger and: [ value >= 0 and: [ value <= self max ] ]! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	^ handle unsignedLongAt: 1 bigEndian: self isBigEndian.! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!min	^ 0! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!store: anInteger in: handle	handle unsignedLongAt: 1 put: anInteger bigEndian: self isBigEndian.! !!UnsignedByte class methodsFor: 'as yet unclassified'!max			^ 255! !!UnsignedInteger class methodsFor: 'as yet unclassified'!max			^ 4294967295! !!UnsignedShortInteger class methodsFor: 'as yet unclassified'!max			^ 65535! !!Workspace methodsFor: 'as yet unclassified'!buildMenuBar	| menu  edit  |	menu := GtkMenuBar new.	edit := GtkMenu new.	menu		append: AppLauncher fileMenu;		append: (edit createMenuItem: '_Edit');		append: workspaceView menu;		append: AppLauncher toolsMenu;		append: AppLauncher helpMenu.					^ menu.! !!Workspace methodsFor: 'as yet unclassified'!buildToolBar	| toolBar |	^ GtkToolbar new		appendItems: workspaceView toolBar;		yourself! !!Workspace methodsFor: 'as yet unclassified'!defaultCodeViewClass	^ WorkspaceView! !!Workspace methodsFor: 'as yet unclassified'!initialize	workspaceView := self defaultCodeViewClass new.	self container: (GtkVBox new		packStart: (self buildMenuBar) expand: false;		packStart: (self buildToolBar) expand: false;		packStart: (workspaceView view);		packStart: (GtkStatusbar new) expand: false	).! !!Workspace methodsFor: 'as yet unclassified'!inspectedVar: anObject	workspaceView inspectedVar: anObject.! !!TranscriptCodeEditor methodsFor: 'as yet unclassified'!defaultCodeViewClass	^ TranscriptCodeView! !!Workspace class methodsFor: 'as yet unclassified'!defaultSize	^ 640@480.! !!Workspace class methodsFor: 'as yet unclassified'!title	^'Workspace'! !!TranscriptCodeEditor class methodsFor: 'as yet unclassified'!title	^'Transcript'! !BufferedFileStream initialize!TranscriptCodeView initialize!TraitBehavior removeSelector: #initializeUsers!Application subclass: #Shell	instanceVariableNames: 'bindings'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!ExternalValue initialize!NativeFunctionRelocation removeSelector: #addressRelativeTo:!NativeFunctionRelocation removeSelector: #function!NativeFunctionRelocation removeSelector: #functionName!NativeFunctionRelocation removeSelector: #functionName:!NativeFunctionRelocation removeSelector: #patch:!NativeFunctionRelocation removeSelector: #patch:with:!ReadOnlyAsciiZ class removeSelector: #objectFromHandle:!ProcessorScheduler removeSelector: #activeProcess2!ProcessorScheduler removeSelector: #activeThreadData!ProcessorScheduler removeSelector: #primActiveThreadData!Process removeSelector: #threadData:!PrimitiveType class removeSelector: #defaultHandlerType!PrimitiveType class removeSelector: #instantiateHandler!NativeFunction removeSelector: #address!NativeFunction removeSelector: #bind!NativeFunction removeSelector: #invoke!NativeFunction removeSelector: #invokeAnswering:!NativeFunction removeSelector: #invokeAnswering:with:!NativeFunction removeSelector: #invokeAnswering:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:withArguments:!NativeFunction removeSelector: #invokeWith:!NativeFunction removeSelector: #invokeWith:with:!NativeFunction removeSelector: #invokeWith:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:with:with:!NativeFunction removeSelector: #invokeWithArguments:!NativeFunction removeSelector: #name!NativeFunction removeSelector: #name:!NativeFunction removeSelector: #throwNotKnownError!LibraryData removeSelector: #primitiveGetValue!LibExample initialize!LibC6 initialize!LibC6 removeSelector: #initializeUnistd!LibC6 removeSelector: #openPath:flags:!LibC6 removeSelector: #write2:buffer:size:!LibC removeSelector: #close!GPointer class removeSelector: #instantiateHandler!FileStream removeSelector: #position!FileDescriptor initialize!FileDescriptor removeSelector: #movePositionTo:!FileDescriptor removeSelector: #name!FileDescriptor removeSelector: #name:!FileDescriptor removeSelector: #positionFromEns:!FileDescriptor removeSelector: #setPositionAt:!FileDescriptor removeSelector: #setPositionFromEndAt:!CDeclFunction class removeSelector: #name:libraryNamed:returnType:argTypes:!ExecutableFunction class removeSelector: #name:library:!ExecutableFunction class removeSelector: #name:libraryNamed:!CDeclFunction removeSelector: #classFromType:!CDeclFunction removeSelector: #throwExternalFunctionError!ExecutableFunction removeSelector: #address!ExecutableFunction removeSelector: #bind!ExecutableFunction removeSelector: #invoke!ExecutableFunction removeSelector: #invokeWith:!ExecutableFunction removeSelector: #invokeWith:with:!ExecutableFunction removeSelector: #invokeWith:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithArguments:!ExecutableFunction removeSelector: #invokeWithReceiver:!ExecutableFunction removeSelector: #invokeWithReceiver:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:withArguments:!ExecutableFunction removeSelector: #library!ExecutableFunction removeSelector: #library:!ExecutableFunction removeSelector: #libraryName!ExecutableFunction removeSelector: #libraryNamed:!ExecutableFunction removeSelector: #name!ExecutableFunction removeSelector: #name:!ExecutableFunction removeSelector: #name:library:!ExecutableFunction removeSelector: #name:libraryNamed:!ExecutableFunction removeSelector: #primInvokeReceiver:withArguments:!ExecutableFunction removeSelector: #primInvokeWithArguments:!ExecutableFunction removeSelector: #primInvokeWithReceiver:withArguments:!ExecutableFunction removeSelector: #throwNotKnownError!ExternalSymbol removeSelector: #callingConventionString!ExternalObjectProxy removeSelector: #register!ExternalObjectProxy removeSelector: #unregister!AsciiZ class removeSelector: #objectFromHandle:!Executable class removeSelector: #huenul!DynamicLibrary class removeSelector: #addLibrary:named:!DynamicLibrary class removeSelector: #huemul!DynamicLibrary initialize!DynamicLibrary class removeSelector: #name:!DynamicLibrary class removeSelector: #named:!ExternalObject class removeSelector: #handle:!ExternalObject initialize!ExternalObject class removeSelector: #registry!ExternalObject class removeSelector: #registry:!AsciiZ removeSelector: #setFrom:!ExternalBuffer removeSelector: #finalize!ExternalBuffer removeSelector: #selfCheck!ExternalBuffer removeSelector: #setFrom:!ExternalBuffer removeSelector: #storeInto:size:!Executable removeSelector: #initialize!Executable removeSelector: #instantiateFunctionClass:!Executable removeSelector: #name:!Executable removeSelector: #nativeFunctionNamed:!Executable removeSelector: #primitiveOpen!DynamicLibrary removeSelector: #addExternal:!DynamicLibrary removeSelector: #basicName!DynamicLibrary removeSelector: #bind:!DynamicLibrary removeSelector: #bindFunction:!DynamicLibrary removeSelector: #cDeclFunctionNamed:returnType:argTypes:!DynamicLibrary removeSelector: #primitiveBind:!DynamicLibrary removeSelector: #primitiveBindFunction:!ExternalObject removeSelector: #isNullPointer!Object subclass: #ExternalObject	instanceVariableNames: 'handle'	classVariableNames: 'Registry'	poolDictionaries: ''	category: 'FFI-Types'!ExternalFunctionError class removeSelector: #function:!ExternalFunctionError removeSelector: #function!ExternalFunctionError removeSelector: #function:!ExternalFunctionError removeSelector: #isResumable!Error subclass: #ExternalFunctionError	instanceVariableNames: 'functionName'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!Application class removeSelector: #start!Application class removeSelector: #startWithArguments:!Class removeSelector: #superclass:methodDict:format:name:organization:instVarNames:classPool:sharedPools:!ClassBuilder removeSelector: #computeFormat:instSize:forSuper:ccIndex:!ClassBuilder removeSelector: #format:variable:words:pointers:weak:!Smalltalk removeClassNamed: #SystemChangeNotifierTest!RBProgramNodeVisitor subclass: #ASTChecker	instanceVariableNames: 'scope varsChangedInSend'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!RBProgramNodeVisitor subclass: #ASTTranslator	instanceVariableNames: 'methodBuilder receiverForCascade'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #Application	instanceVariableNames: 'arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!AssembleInstruction subclass: #AssembleCMov	instanceVariableNames: ''	classVariableNames: 'Condition'	poolDictionaries: ''	category: 'Exupery'!Object subclass: #AssemblerExupery	instanceVariableNames: 'stream blockAddresses jumpOffsets bytecodes instructionEncoders plugin relocator picEntries debugCollector source'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #BlockClosure	instanceVariableNames: 'method environment'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Contexts'!PluggableGtkSimpleApplication subclass: #ClassFinder	instanceVariableNames: 'classTrait'	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!Object subclass: #ColouringRegisterAllocator	instanceVariableNames: 'source result machine interferenceGraph registerStack registerFile registerTable spiltRegisters hasSpilt coloursUsed simplifyWorklist spillWorklist moveWorklist coalescedMoves isValidating deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #DebugInfo	instanceVariableNames: 'codeSourceReferences argVarsReferences tempVarsReferences capturedVarsReferences'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!Object subclass: #EventManager	instanceVariableNames: 'actionMap'	classVariableNames: 'ActionMaps'	poolDictionaries: ''	category: 'System-Object'!Error subclass: #ExternalFunctionError	instanceVariableNames: 'functionName '	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!Object subclass: #ExternalObject	instanceVariableNames: 'handle '	classVariableNames: 'Registry '	poolDictionaries: ''	category: 'FFI-Types'!ExternalObject subclass: #DynamicLibrary	instanceVariableNames: 'name symbolCache'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!DynamicLibrary subclass: #Executable	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!ExternalObject subclass: #ExternalBuffer	instanceVariableNames: 'size'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalBuffer subclass: #AsciiZ	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!DynamicLibrary class	instanceVariableNames: 'default'!ExternalObject subclass: #ExternalObjectProxy	instanceVariableNames: 'object'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalObjectProxy subclass: #ExternalArrayProxy	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!ExternalObject subclass: #ExternalSymbol	instanceVariableNames: 'name library'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!ExternalSymbol subclass: #ExecutableFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!ExecutableFunction subclass: #CDeclFunction	instanceVariableNames: 'returnType argTypes'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Error subclass: #ExternalSymbolError	instanceVariableNames: 'symbolName'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!ExternalObject subclass: #FileDescriptor	instanceVariableNames: ''	classVariableNames: 'StandardDescriptors'	poolDictionaries: ''	category: 'FFI-Types'!Error subclass: #FileStreamException	instanceVariableNames: 'fileName'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #CannotDeleteFileException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #FileDoesNotExistException	instanceVariableNames: 'readOnly'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!FileStreamException subclass: #FileExistsException	instanceVariableNames: 'fileClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Exceptions'!AssemblyCopier subclass: #FinalCopier	instanceVariableNames: 'deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!LexicalScope subclass: #FunctionScope	instanceVariableNames: 'thisContextVar thisEnvVar tempVars capturedVars isHome hasInnerFreeVars hideTemps argVars uninitializedTemps capturedParentEnv'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #GIRBuilder	instanceVariableNames: 'ir currentBlock machine relocationInfo primitiveNode literals thisEnvVar cacheMap literalTemp source start stop debugInfo'	classVariableNames: 'InlinedSelectors SpecialConstants SpecialSelectors'	poolDictionaries: ''	category: 'Compiler-IR'!LexicalScope subclass: #InstanceScope	instanceVariableNames: 'vars'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!DynamicLibrary subclass: #LibC6	instanceVariableNames: ''	classVariableNames: 'LSeekDirectives OpenFlags'	poolDictionaries: ''	category: 'FFI-Libraries'!Object subclass: #LibExample	instanceVariableNames: ''	classVariableNames: 'GETPID'	poolDictionaries: ''	category: 'Guille-Test'!DynamicLibrary subclass: #LibReadLine	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Libraries'!ExternalSymbol subclass: #LibraryData	instanceVariableNames: 'type'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Object subclass: #LivenessAnalyser	instanceVariableNames: 'source hasUpdated isValidating deadVars'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery'!Object subclass: #MedLanguage	instanceVariableNames: 'in out start stop'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedCMov	instanceVariableNames: 'type from to'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedEnter	instanceVariableNames: 'argument'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedLeave	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLanguage subclass: #MedLiteral	instanceVariableNames: 'literal'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!MedLiteral subclass: #MedFunction	instanceVariableNames: 'block byteCodeAddress'	classVariableNames: ''	poolDictionaries: ''	category: 'Exupery-Intermediate'!ExecutableFunction subclass: #NativeFunction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Kernel'!Object subclass: #PrimitiveType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!PrimitiveType subclass: #IntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!RBProgramNode subclass: #RBReturnNode	instanceVariableNames: 'return value homeBinding frameBinding'	classVariableNames: ''	poolDictionaries: ''	category: 'AST-Nodes'!ExternalObject subclass: #ReadOnlyAsciiZ	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SemanticWarning subclass: #RedeclaredVariableWarning	instanceVariableNames: 'variableNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #RelocationInfo	instanceVariableNames: 'offset'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #ExecutableFunctionRelocation	instanceVariableNames: 'functionName'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #FunctionRelocation	instanceVariableNames: 'function'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #LiteralRelocation	instanceVariableNames: 'literals'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!ExecutableFunctionRelocation subclass: #NativeFunctionRelocation	instanceVariableNames: 'libraryName'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!NativeFunctionRelocation subclass: #ExternalFunctionRelocation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!RelocationInfo subclass: #PrimitiveRelocation	instanceVariableNames: 'number'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!Object subclass: #ScopeVar	instanceVariableNames: 'scope usage'	classVariableNames: 'UsageAutomaton'	poolDictionaries: ''	category: 'Compiler-Semantics'!ScopeVar subclass: #GlobalVar	instanceVariableNames: 'assoc'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!ScopeVar subclass: #LocalVar	instanceVariableNames: 'name index'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!LocalVar subclass: #ArgVar	instanceVariableNames: 'isArg'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!LocalVar subclass: #CapturedVar	instanceVariableNames: 'sourceTemp'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!ByteArray variableByteSubclass: #ExternalValue	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!Object subclass: #SharedPool	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Pools'!Application subclass: #Shell	instanceVariableNames: 'bindings '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!IntegerType subclass: #SignedIntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedByte	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SignedIntegerType subclass: #SignedShortInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!Object subclass: #SourceReference	instanceVariableNames: 'sourceStart sourceStop codeStop'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!RelocationInfo subclass: #SpecialSelectorRelocation	instanceVariableNames: 'specialSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!Model subclass: #StringHolder	instanceVariableNames: 'contents'	classVariableNames: ''	poolDictionaries: ''	category: 'ST80-Kernel-Remnants'!Object subclass: #SystemTracer	instanceVariableNames: 'byteStream traceQueue oopMap nextChunk nilOop count'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Tracer'!LocalVar subclass: #TempVar	instanceVariableNames: 'isArg'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Error subclass: #TraitException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Kernel'!TraitException subclass: #TraitCompositionException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Composition'!Error subclass: #TypeConvertionError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!FileStream subclass: #UnbufferedFileStream	instanceVariableNames: 'name fileID'	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!Smalltalk renameClassNamed: #BufferedFileStream2 as: #BufferedFileStream!UnbufferedFileStream subclass: #BufferedFileStream	instanceVariableNames: ''	classVariableNames: 'DefaultBufferSize'	poolDictionaries: ''	category: 'Files-Kernel'!BufferedFileStream subclass: #BinaryFileStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!BufferedFileStream subclass: #TextFileStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Files-Kernel'!IntegerType subclass: #UnsignedIntegerType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedByte	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!UnsignedIntegerType subclass: #UnsignedShortInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Types'!SemanticWarning subclass: #UnusedVariableWarning	instanceVariableNames: 'variableNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Semantics'!Object subclass: #VarReference	instanceVariableNames: 'name'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Debug'!RelocationInfo subclass: #VariableRelocation	instanceVariableNames: 'variable'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Relocation'!PluggableGtkSimpleApplication subclass: #Workspace	instanceVariableNames: 'workspaceView'	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!Workspace subclass: #TranscriptCodeEditor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Gtk-Tools'!!Object methodsFor: 'as yet unclassified'!errorSubscriptBounds: index 	"Create an error notification that an improper integer was used as an index."	self error: 'subscript is out of bounds: ' , index printString! !!Object methodsFor: 'as yet unclassified'!executeMethod: compiledMethod withArgs: argArray	"Execute compiledMethod against the receiver and args in argArray"	| selector |	<primitive: 188>	selector _ Symbol new.	self class addSelectorSilently: selector withMethod: compiledMethod.	^ [self perform: selector withArguments: argArray]		ensure: [self class basicRemoveSelector: selector]! !!Object methodsFor: 'as yet unclassified'!withArgs: argArray executeMethod: compiledMethod	"For compatibility with Aqueak"	self executeMethod: compiledMethod withArgs: argArray! !!Application methodsFor: 'as yet unclassified'!arguments	^ arguments.! !!Application methodsFor: 'as yet unclassified'!arguments: anArray	arguments := anArray.! !!Application methodsFor: 'as yet unclassified'!main	self subclassResponsibility.! !!Application methodsFor: 'as yet unclassified'!startUp	Smalltalk startUp.	^ self main.! !!Behavior methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return true if it is safe to zap the method dictionary on #obsolete"	^true! !!Behavior methodsFor: 'as yet unclassified'!isWeak	^ (format bitAnd: 4) = 1.! !!Behavior methodsFor: 'as yet unclassified'!obsolete	"Invalidate and recycle local methods,	e.g., zap the method dictionary if can be done safely."	self canZapMethodDictionary		ifTrue: [self methodDict: self emptyMethodDictionary].! !!Behavior methodsFor: 'as yet unclassified'!removeSelector: selector	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method."	| oldMethod |		oldMethod _ self methodDict at: selector ifAbsent: [^ self].	self methodDict removeKey: selector.	"Now flush Squeak's method cache, either by selector or by method"	oldMethod flushCache.	selector flushCache! !!Behavior methodsFor: 'as yet unclassified'!selectorsAndMethodsDo: aBlock	"Evaluate selectorBlock for all the message selectors in my method dictionary."	^ self methodDict keysAndValuesDo: aBlock! !!Behavior methodsFor: 'as yet unclassified'!setTraitComposition: aTraitComposition	| oldComposition |	(self hasTraitComposition not and: [aTraitComposition isEmpty]) ifTrue: [^self].	aTraitComposition assertValidUser: self.	oldComposition _ self traitComposition.	self traitComposition: aTraitComposition."	self applyChangesOfNewTraitCompositionReplacing: oldComposition."		oldComposition traits do: [:each | each removeUser: self].	aTraitComposition traits do: [:each | each addUser: self]! !!Behavior methodsFor: 'as yet unclassified'!traitCompositionString	^self hasTraitComposition		ifTrue: [self traitComposition asString]		ifFalse: ['{}']! !!Behavior methodsFor: 'as yet unclassified'!typeOfClass	"Answer a symbol uniquely describing the type of the receiver"	self isWeak ifTrue: [ ^ #weak ].	^ (format bitAnd: 3) caseOf: {		[ 0 ] -> [ #normal ].		[ 1 ] -> [ #variable ].		[ 2 ] -> [ #bytes ].		[ 3 ] -> [ #words ]	}! !!Behavior methodsFor: 'as yet unclassified'!whichSelectorsReferTo: literal	"Answer a set of selectors whose methods access the argument as a literal."	| who |	who _ IdentitySet new.	self selectorsAndMethodsDo: 		[:sel :method |		(method hasLiteral: literal)			ifTrue:				[((literal isVariableBinding) not					or: [method literals allButLast includes: literal])						ifTrue: [who add: sel]]].	^ who! !!BehaviorTest methodsFor: 'as yet unclassified'!testBehaviorSubclasses	"self run: #testBehaviorSubclasses"		| b b2 |"	b := Behavior new.	b superclass: OrderedCollection.	b methodDictionary: Dictionary new.	self shouldnt: [b subclasses ] raise: Error.	self shouldnt: [b withAllSubclasses] raise: Error.	self shouldnt: [b allSubclasses] raise: Error.	b2 := Behavior new.	b2 superclass: b.	b2 methodDictionary: Dictionary new.	self assert: (b subclasses includes: b2).	self assert: (b withAllSubclasses includes: b)."! !!BlockClosure methodsFor: 'as yet unclassified'!valueWithArguments: anArray 	"Evaluate the block with given args. Fail if the block expects other than the given number of arguments."	^ environment executeMethod: method withArgs: anArray ! !!ClassBrowser methodsFor: 'as yet unclassified'!buildClassCategoriesView	| model tree col cell |	tree := nil->nil.	SystemOrganization categories do: [ :each |		| category |		category := tree.		(each subStrings: '-') do: [ :cat |			category value ifNil: [ category value: Dictionary new].			category := category value associationAt: cat ifAbsent: [ category value at: cat put: nil. category value associationAt: cat ]		]	].	model := GtkTreeStore new: {String. String}.	[ self addSubcategoriesFrom: tree fromIter: nil inModel: model ] fork.	classCategoriesTree := GtkTreeView model: model.	col := GtkTreeViewColumn title: 'Class categories'.	cell := GtkCellRendererPixbuf new.	col		packStart: cell expand: false;		addAttribute: #stockId column: 1 on: cell.	cell := GtkCellRendererText new.	col		packStart: cell;		addAttribute: #text column: 0 on: cell.		classCategoriesTree appendColumn: col.	classCategoriesTree selection when: #changed send: #onClassCategoryChanged to: self.	classCategoriesTree enableTreeLines: true.	^ GtkScrolledWindow withChild: classCategoriesTree! !!ClassBrowser methodsFor: 'as yet unclassified'!loadClassMethodsOf: aClassClass	| iter |	classMethodsTree model clear.	aClassClass organization categories do: [ :cat |		iter := classMethodsTree model append: nil->{cat asString. true. 'grey'. 'gtk-info'}.		(aClassClass organization listAtCategoryNamed: cat) asSortedCollection do: [ :sel |			classMethodsTree model append: iter->{sel asString. false. 'grey'. 'gtk-execute'}		]	].	classMethodsTree expandAll.! !!ClassBrowser methodsFor: 'as yet unclassified'!loadInstanceMethodsOf: aClass	| iter |	instanceMethodsTree model clear.	aClass organization categories do: [ :cat |		iter := instanceMethodsTree model append: nil->{cat asString. true. 'grey'. 'gtk-info'}.		(aClass organization listAtCategoryNamed: cat) asSortedCollection do: [ :sel |			instanceMethodsTree model append: iter->{sel asString. false. 'grey'. 'gtk-execute'}		]	].	instanceMethodsTree expandAll.! !!ClassBrowser methodsFor: 'as yet unclassified'!onClassHierarchyChanged	| class iter path newIter aCategory classHierarchySelectedRow classesTreeSelectedRow |	classHierarchySelectedRow := classHierarchyTree selectedRow.	classHierarchySelectedRow ifNotNil: [		class := Smalltalk at: (classHierarchySelectedRow first asSymbol).							aCategory := class category.		( aCategory isNotNil and: [ aCategory ~= selectedClassCategory ] ) ifTrue: [			selectedClassCategory := aCategory.			iter := classCategoriesTree model firstIter.			newIter := nil.			(aCategory subStrings: '-') do: [ :cat |				newIter ifNotNil: [ iter := newIter ].				iter := self classCategoryFor: cat firstIter: iter.				newIter := classCategoriesTree model firstChildAt: iter.			].			path := classCategoriesTree model pathFromIter: iter.			classCategoriesTree expandRowsUpTo: path.			classCategoriesTree moveCursorAt: path.					classesTree model clear.			(SystemOrganization listAtCategoryNamed: aCategory) sort do: [ :ea |				classesTree model append: {ea asString. 'gtk-execute'}			]		].							self selectClass: class.	]! !!ClassBuilder methodsFor: 'as yet unclassified'!formatForType: type	^ type caseOf: {		[ #normal ] -> [ 0 ].		[ #variable ] -> [ 1 ].		[ #bytes ] -> [ 2 ].		[ #words ] -> [ 3 ].		[ #weak ] -> [ 5 "binary: 4 + 0 + 0 + 1" ]	} otherwise: [ self error: 'Unknown class type' ].! !!ClassBuilder methodsFor: 'as yet unclassified'!needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Answer whether we need a new subclass to conform to the requested changes"	"Check if we really need a new subclass"	oldClass ifNil:[^true]. "yes, it's a new class"	newSuper == oldClass superclass ifFalse:[^true]. "yes, it's a superclass change"	type = oldClass typeOfClass ifFalse:[^true]. "yes, it's a format change"	instVars = oldClass instVarNames ifFalse:[^true]. "yes, it's an iVar change"	^false! !!ClassBuilder methodsFor: 'as yet unclassified'!newSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Create a new subclass of the given superclass with the given specification."	| newClass |	(oldClass == nil or:[oldClass isMeta not]) 		ifTrue:[newClass := self privateNewSubclassOf: newSuper from: oldClass]		ifFalse:[newClass := oldClass clone].	newClass 		superclass: newSuper		methodDictionary: "Method"Dictionary new		instanceSize: (newSuper instSize + instVars size)		format: (self formatForType: type);		setInstVarNames: instVars.	oldClass ifNotNil:[		newClass organization: oldClass organization.		"Recompile the new class"		oldClass hasMethods 			ifTrue:[newClass compileAllFrom: oldClass].		oldClass hasTraitComposition ifTrue: [			newClass setTraitComposition: oldClass traitComposition copyTraitExpression ].		oldClass class hasTraitComposition ifTrue: [			newClass class setTraitComposition: oldClass class traitComposition copyTraitExpression ].				self recordClass: oldClass replacedBy: newClass.	].	(oldClass == nil or:[oldClass isObsolete not]) 		ifTrue:[newSuper addSubclass: newClass]		ifFalse:[newSuper addObsoleteSubclass: newClass].	^newClass! !!ClassBuilder methodsFor: 'as yet unclassified'!privateNewSubclassOf: newSuper from: oldClass	"Create a new meta and non-meta subclass of newSuper using oldClass as template"	"WARNING: This method does not preserve the superclass/subclass invariant!!"	| newSuperMeta oldMeta newMeta |	oldClass ifNil:[^self privateNewSubclassOf: newSuper].	newSuperMeta _ newSuper ifNil:[Class] ifNotNil:[newSuper class].	oldMeta _ oldClass class.	newMeta _ oldMeta clone.	newMeta 		superclass: newSuperMeta		methodDictionary: "Method"Dictionary new		instanceSize: oldMeta instSize		format: oldMeta format;		setInstVarNames: oldMeta instVarNames;		organization: oldMeta organization.	"Recompile the meta class"	oldMeta hasMethods 		ifTrue:[newMeta compileAllFrom: oldMeta].	"Record the meta class change"	self recordClass: oldMeta replacedBy: newMeta.	"And create a new instance"	^newMeta adoptInstance: oldClass from: oldMeta! !!ClassBuilder methodsFor: 'as yet unclassified'!reshapeClass: oldClass toSuper: newSuper	"Reshape the given class to the new super class. Recompile all the methods in the newly created class. Answer the new class."	| instVars |	instVars _ instVarMap at: oldClass name ifAbsent:[oldClass instVarNames].	^self newSubclassOf: newSuper 			type: oldClass typeOfClass 			instanceVariables: instVars 			from: oldClass! !!ClassDescription methodsFor: 'as yet unclassified'!classVersion	"Default.  Any class may return a later version to inform readers that use ReferenceStream.  8/17/96 tk"	"This method allows you to distinguish between class versions when the shape of the class 	hasn't changed (when there's no change in the instVar names).	In the conversion methods you usually can tell by the inst var names 	what old version you have. In a few cases, though, the same inst var 	names were kept but their interpretation changed (like in the layoutFrame).	By changing the class version when you keep the same instVars you can 	warn older and newer images that they have to convert."	^ 0! !!ClassDescription methodsFor: 'as yet unclassified'!obsolete	"Make the receiver obsolete."	superclass removeSubclass: self.	self organization: nil.	super obsolete.! !!ClassDescription methodsFor: 'as yet unclassified'!removeSelector: selector 	"Remove the message whose selector is given from the method 	dictionary of the receiver, if it is there. Answer nil otherwise."		| priorMethod priorProtocol | 	priorMethod _ self compiledMethodAt: selector ifAbsent: [^ nil].	priorProtocol _ self whichCategoryIncludesSelector: selector.	SystemChangeNotifier uniqueInstance		doSilently: [self organization removeElement: selector ].	super removeSelector: selector.	SystemChangeNotifier uniqueInstance 			methodRemoved: priorMethod selector: selector inProtocol: priorProtocol class: self.! !!ClassDescription methodsFor: 'as yet unclassified'!updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil	| currentCategory effectiveCategory sel changedCategories composition |	changedCategories _ IdentitySet new.	composition := self hasTraitComposition		ifTrue: [self traitComposition]		ifFalse: [TraitComposition new].	(composition methodDescriptionsForSelector: aSymbol) do: [:each |		sel _ each selector.		(self includesLocalSelector: sel) ifFalse: [			currentCategory _ self organization categoryOfElement: sel.			effectiveCategory _ each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.			effectiveCategory isNil ifTrue: [				currentCategory ifNotNil: [changedCategories add: currentCategory].				self organization removeElement: sel.			] ifFalse: [				((currentCategory isNil or: [currentCategory == ClassOrganizer ambiguous or: [currentCategory == oldCategoryOrNil]]) and: [currentCategory ~~ effectiveCategory]) ifTrue: [					currentCategory ifNotNil: [changedCategories add: currentCategory].					self organization 						classify: sel 						under: effectiveCategory						suppressIfDefault: false]]]].	^ changedCategories! !!ClassDescription methodsFor: 'as yet unclassified'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	(self includesSelector: aSelector)		ifTrue: [^ self organization categoryOfElement: aSelector]		ifFalse: [^nil]! !!Class methodsFor: 'as yet unclassified'!classPool: aDictionary	classPool _ aDictionary! !!Class methodsFor: 'as yet unclassified'!copy 	| newClass |	newClass _ self class copy new		superclass: superclass		methodDict: self methodDict copy		instanceSize: self instSize		format: format		name: name		organization: self organization copy		instVarNames: instanceVariables copy		classPool: classPool copy		sharedPools: sharedPools.	Class instSize+1 to: self class instSize do:		[:offset | newClass instVarAt: offset put: (self instVarAt: offset)].	^ newClass! !!Class methodsFor: 'as yet unclassified'!deactivate	"A remnant from the 3.3a modules work, retained . Does nothing, but may be overridden in Metaclasses."! !!Class methodsFor: 'as yet unclassified'!isSystemDefined	"Answer true if the receiver is a system-defined class, and not a UniClass (an instance-specific lightweight class)"	^ self == self officialClass! !!Class methodsFor: 'as yet unclassified'!obsolete	"Change the receiver and all of its subclasses to an obsolete class."	self == Object 		ifTrue: [^self error: 'Object is NOT obsolete'].	self setName: 'AnObsolete' , self name.	Object class instSize + 1 to: self class instSize do:		[:i | self instVarAt: i put: nil]. "Store nil over class instVars."	self classPool: nil.	self sharedPools: nil.	self class obsolete.	super obsolete.! !!Class methodsFor: 'as yet unclassified'!officialClass	"I am not a UniClass.  (See Player officialClass).  Return the class you use to make new subclasses."	^ self! !!Class methodsFor: 'as yet unclassified'!removeFromSystem	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."	self removeFromSystem: true.! !!Class methodsFor: 'as yet unclassified'!removeFromSystem: logged	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."		"keep the class name and category for triggering the system change message. If we wait to long, then we get obsolete information which is not what we want."	"tell class to deactivate and unload itself-- two separate events in the module system"	self deactivate; unload.	self superclass ifNotNil:		["If we have no superclass there's nothing to be remembered"		self superclass addObsoleteSubclass: self].	self environment forgetClass: self logged: logged.	self obsolete.! !!Class methodsFor: 'as yet unclassified'!sharedPools: aCollection	sharedPools _ aCollection! !!Class methodsFor: 'as yet unclassified'!superclass: sup methodDict: md instanceSize: is format: ft name: nm organization: org instVarNames: nilOrArray classPool: pool sharedPools: poolSet 	"Answer an instance of me, a new class, using the arguments of the 	message as the needed information.	Must only be sent to a new instance; else we would need Object flushCache."	superclass := sup.	methodDict := md.	instanceSize := is.	format := ft.	name := nm.	instanceVariables := nilOrArray.	classPool := pool.	sharedPools := poolSet.	self organization: org.! !!Class methodsFor: 'as yet unclassified'!unload	"Sent when a the class is removed.  Does nothing, but may be overridden by (class-side) subclasses."! !!Class methodsFor: 'as yet unclassified'!variableByteSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable byte-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableByteSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!variableSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable pointer variables."	^(ClassBuilder new)		superclass: self		variableSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!variableWordSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable word-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableWordSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'as yet unclassified'!weakSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have weak indexable pointer variables."	^(ClassBuilder new)		superclass: self		weakSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!AppLauncher class methodsFor: 'as yet unclassified'!openAboutHuemul	| dlg logo |	logo := GdkPixbuf fromFile: 'Huemul.jpg'.	dlg := GtkAboutDialog new.	dlg		aboutDialogName: 'Huemul Smalltalk';		version: '0.8';		license: (StandardFileStream readOnlyFileNamed: 'LICENSE') upToEnd;		website: 'http://www.guillermomolina.com.ar/huemul';		comments: 'This is Huemul Smalltalk';		authors: {'Guillermo Adrian Molina'};		logo: logo.	dlg runAndDestroy! !!AppLauncher class methodsFor: 'as yet unclassified'!openWorkspace	^ Workspace open! !!Application class methodsFor: 'as yet unclassified'!startUp	^ self new startUp.! !!Application class methodsFor: 'as yet unclassified'!startUpWithArguments: arguments	| application |	application := self new.	application arguments: arguments.	^ application startUp.! !!Behavior class methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return false since zapping the method dictionary of Behavior class or its subclasses will cause the system to fail."	^false! !!ClassBrowser class methodsFor: 'as yet unclassified'!defaultSize	^ 640@480.! !!ClassBrowser class methodsFor: 'as yet unclassified'!title	^'Class browser'! !!ClassFinder class methodsFor: 'as yet unclassified'!defaultSize	^ 200@300.! !!ClassFinder class methodsFor: 'as yet unclassified'!title	^'Class finder'! !!CompiledMethod methodsFor: 'as yet unclassified'!hasLiteral: literal	"Answer whether the receiver references the argument, literal."	literals ifNil: [ ^false ].	^ literals hasLiteral: literal.! !!CompiledMethod methodsFor: 'as yet unclassified'!sourcePointer	"Answer the integer which can be used to find the source file and position for this method.	Not sources yet"	^ 0! !!CompiledMethodWithNode class methodsFor: 'as yet unclassified'!method: aCompiledMethod node: aMethodNode	^ self new method: aCompiledMethod; node: aMethodNode.! !!Compiler methodsFor: 'as yet unclassified'!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into a method. In other words, if receiver is not nil, then the text can refer to instance variables of that receiver (the Inspector uses this). If aContext is not nil, the text can refer to temporaries in that context (the Debugger uses this). If aRequestor is not nil, then it will receive a notify:at: message before the attempt to evaluate is aborted. Finally, the compiled method is directly invoked without modifying the receiving-class."	"| methodNode method value |	  	(Preferences compileUseNewCompiler or: 			[aContext ifNotNil: [aContext method isClosureCompiled] ifNil: [false]]) ifTrue: 				[^ self evaluate2: textOrStream 					    in: aContext 					    to: receiver 					    notifying: aRequestor 					    ifFail: failBlock 					    logged: logFlag].		class := (aContext isNil 		ifTrue: [ receiver ] 		ifFalse: [ aContext receiver ])			class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode := self 		translate: sourceStream		noPattern: true 		ifFail: [ ^ failBlock value ].	method := methodNode generate.	self interactive		ifTrue: [ method := method copyWithTempNames: methodNode tempNames ].	value := receiver		executeMethod: method 		withArgs: (context isNil			ifTrue: [ #() ]			ifFalse: [ Array with: aContext ]).	logFlag 		ifTrue: [ SystemChangeNotifier uniqueInstance evaluated: sourceStream contents context: aContext ].	^ value."	| string block |	string _ textOrStream readStream upToEnd.	block := self compileDoIt: string in: aContext to: receiver notifying: aRequestor ifFail: [^ failBlock value] log: logFlag.	^ block value! !!Exception methodsFor: 'as yet unclassified'!messageText	messageText ifNil: [ ^ self class name asString ].	^messageText! !!Exception methodsFor: 'as yet unclassified'!receiver	^ self signalerContext receiver! !!ExternalFunctionError methodsFor: 'as yet unclassified'!functionName	"Answer the function name that was beiing used."	^functionName! !!ExternalFunctionError methodsFor: 'as yet unclassified'!functionName: argument	"Specify the function name that was beiing used."	functionName := argument! !!ExternalFunctionError class methodsFor: 'as yet unclassified'!functionName: argument	^self new functionName: argument; yourself! !!ExternalObject methodsFor: 'as yet unclassified'!= anObject 	(anObject isKindOf: self class)		ifTrue: [^ anObject handle = self handle]		ifFalse: [^ false]! !!ExternalObject methodsFor: 'as yet unclassified'!beNull	^ handle beNull.! !!ExternalObject methodsFor: 'as yet unclassified'!finalize		self free.	self unregister.! !!ExternalObject methodsFor: 'as yet unclassified'!free	"Should override this"! !!ExternalObject methodsFor: 'as yet unclassified'!initialize	handle := self class defaultHandlerClass new.	self register.! !!ExternalObject methodsFor: 'as yet unclassified'!isNull	^ self handle isNull.! !!ExternalObject methodsFor: 'as yet unclassified'!register	Registry add: self.! !!ExternalObject methodsFor: 'as yet unclassified'!unregister		Registry remove: self ifAbsent:[  ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!addSymbol: anExternalSymbol	^ symbolCache at: anExternalSymbol name put: anExternalSymbol.! !!DynamicLibrary methodsFor: 'as yet unclassified'!bindSymbol: anExternalSymbol	^ self primitiveBindSymbol: anExternalSymbol.! !!DynamicLibrary methodsFor: 'as yet unclassified'!cDeclFunctionNamed: functionName	^ symbolCache at: functionName ifAbsent: [ self error: 'You must initialize the function before using it' ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!close		handle isNull ifFalse: [ 		self primitiveClose		handle beNull.	].! !!DynamicLibrary methodsFor: 'as yet unclassified'!initialize	super initialize.	symbolCache := Dictionary new.! !!DynamicLibrary methodsFor: 'as yet unclassified'!initializeCDeclFunctionNamed: functionName returnType: retType argTypes: argTypesArray	^ symbolCache at: functionName put: 			(CDeclFunction name: functionName library: self  returnType: retType argTypes: argTypesArray)! !!DynamicLibrary methodsFor: 'as yet unclassified'!initializeLibraryDataNamed: symbolName type: type	^ symbolCache at: symbolName put: (LibraryData name: symbolName library: self  type: type)! !!DynamicLibrary methodsFor: 'as yet unclassified'!libraryDataNamed: symbolName	^ symbolCache at: symbolName ifAbsent: [ self error: 'You must initialize the symbol before using it' ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!name	^name! !!DynamicLibrary methodsFor: 'as yet unclassified'!name: aName	name := aName.! !!DynamicLibrary methodsFor: 'as yet unclassified'!nativeFunctionNamed: functionName	^ symbolCache at: functionName ifAbsent: [ 		symbolCache at: functionName put: (NativeFunction name: functionName library: self)	].! !!DynamicLibrary methodsFor: 'as yet unclassified'!open		handle isNull ifTrue: [ self primitiveOpen ]! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveBindSymbol: anExternalSymbol	"Primitive. Find the given symbol in the library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 203>	^ anExternalSymbol throwNotKnownError.! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveClose	"Primitive. Close the given library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 202>! !!DynamicLibrary methodsFor: 'as yet unclassified'!primitiveOpen	"Primitive. Open the given library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 198>	self primitiveFailed.! !!DynamicLibrary methodsFor: 'as yet unclassified'!printOn: aStream	aStream nextPutAll: self name.! !!DynamicLibrary methodsFor: 'as yet unclassified'!symbolNamed: symbolName	^ symbolCache at: symbolName ifAbsent: [ self error: 'You must initialize the symbol before using it' ]! !!Executable methodsFor: 'as yet unclassified'!name	^ Utilities executableName ! !!Executable methodsFor: 'as yet unclassified'!primitiveSmallIntegerAdd: receiver with: argument	^ (self nativeFunctionNamed: #primitiveSmallIntegerAdd) invokeReceiver: receiver with: argument.! !!ExternalBuffer methodsFor: 'as yet unclassified'!asByteArray	| array |	size ifNil: [ ^ self class throwTypeConvertionError ].	array := ByteArray new: self basicSize.	self storeInto: array.	^ array	! !!ExternalBuffer methodsFor: 'as yet unclassified'!atAllPut: constant	^ LibC6 default memSet: self constant: constant count: self size.! !!ExternalBuffer methodsFor: 'as yet unclassified'!atAllPutZero	^ self atAllPut: 0.! !!ExternalBuffer methodsFor: 'as yet unclassified'!basicSize	^ size.! !!ExternalBuffer methodsFor: 'as yet unclassified'!byteAt: index	<primitive: 190>	index isNumber		ifTrue: [self errorSubscriptBounds: index]		ifFalse: [self errorNonIntegerIndex].! !!ExternalBuffer methodsFor: 'as yet unclassified'!byteAt: index put: value	<primitive: 191>	index isNumber		ifTrue: [self errorSubscriptBounds: index]		ifFalse: [self errorNonIntegerIndex].! !!ExternalBuffer methodsFor: 'as yet unclassified'!free		handle isNull ifFalse: [ 		LibC6 default free: self.		self beNull.	]! !!ExternalBuffer methodsFor: 'as yet unclassified'!loadFrom: aByteArray	<primitive: 199>	self primitiveFailed.! !!ExternalBuffer methodsFor: 'as yet unclassified'!size	^ self basicSize.! !!ExternalBuffer methodsFor: 'as yet unclassified'!size: anInteger	size := anInteger.! !!ExternalBuffer methodsFor: 'as yet unclassified'!storeInto: aByteArray	<primitive: 218>	^ self class throwTypeConvertionError.! !!AsciiZ methodsFor: 'as yet unclassified'!asString	^ handle toString.! !!AsciiZ methodsFor: 'as yet unclassified'!asString2	| calcSize string |	size ifNil: [ ^ self class throwTypeConvertionError ].	calcSize := self strlen.	calcSize >= self size ifTrue: [ ^ self class throwTypeConvertionError ].	string := String new: calcSize.	self storeInto: string.	^ string! !!AsciiZ methodsFor: 'as yet unclassified'!loadFrom: aString		super loadFrom: aString.	self byteAt: (aString size + 1) put: 0.! !!AsciiZ methodsFor: 'as yet unclassified'!strlen	^ LibC6 default strLen: self.! !!ExternalFunction methodsFor: 'as yet unclassified'!library	^ library! !!ExternalFunction methodsFor: 'as yet unclassified'!library: aLibrary	library := aLibrary! !!ExternalFunction methodsFor: 'as yet unclassified'!name	^name! !!ExternalFunction methodsFor: 'as yet unclassified'!name: aName	name := aName! !!ExternalFunction methodsFor: 'as yet unclassified'!name: aName library: aLibrary	self name: aName.	self library: aLibrary! !!ExternalFunction methodsFor: 'as yet unclassified'!reload	library ifNil: [ ^ self throwNotKnownError ].	self handle: (library findFunction: self)! !!ExternalLibrary methodsFor: 'as yet unclassified'!bindFunction: function	| answer |	answer := self primitiveBindFunction: function.	answer ifNotNil: [ ^ answer ].	self open. "Library may be closed, open it and retry"	answer := self primitiveBindFunction: answer.	answer ifNotNil: [ ^ answer ].	^ function throwNotKnownError.		! !!ExternalLibrary methodsFor: 'as yet unclassified'!closeLibrary		(handle isNotNil and: [ handle isNull not ]) ifTrue: [ self primitiveClose ].	self handle: nil.	functionCache := nil.! !!ExternalLibrary methodsFor: 'as yet unclassified'!openLibrary		self primitiveOpen.	self initializeFunctionCache.! !!ExternalLibrary methodsFor: 'as yet unclassified'!primitiveBindFunction: function	"Primitive. Find the given symbol in the library.	The primitive will fail if the library is not available	or if anything is wrong with the receiver."	<primitive: 203>	^ nil.! !!ExternalObject class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: self! !!ExternalObject class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalAddress! !!ExternalObject class methodsFor: 'as yet unclassified'!handleFromObject: anObject	^ self handleFromObject: anObject ifError: [ self throwTypeConvertionError ]! !!ExternalObject class methodsFor: 'as yet unclassified'!handleFromObject: anObject ifError: aBlock		(anObject isKindOf: ExternalObject) ifFalse: [ ^ aBlock value ].	^ anObject handle.	! !!ExternalObject class methodsFor: 'as yet unclassified'!initialize	Registry := WeakRegistry new.	Smalltalk addToShutDownList: self.! !!ExternalObject class methodsFor: 'as yet unclassified'!objectFromHandle: handle	^self objectFromHandle: handle ifError: [ self throwTypeConvertionError ]! !!ExternalObject class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; yourself! !!ExternalObject class methodsFor: 'as yet unclassified'!quit	Registry do: [ :each | each free ].	self allSubclassesDo: [ :ea | ea quit ]! !!ExternalObject class methodsFor: 'as yet unclassified'!shutDown: quitting	quitting ifTrue: [ self quit ].! !!ExternalObject class methodsFor: 'as yet unclassified'!throwTypeConvertionError	^ TypeConvertionError new signal! !!DynamicLibrary class methodsFor: 'as yet unclassified'!default	self = DynamicLibrary ifTrue: [ self error: 'Create a class to create its singleton' ].	default ifNil: [	"Represents the executable itself"		default := self new.		default name: self moduleName.		default open.	].	^ default.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!initialize	self = DynamicLibrary ifFalse: [ 		Smalltalk addToShutDownList: self	].! !!DynamicLibrary class methodsFor: 'as yet unclassified'!moduleName	self subClassResponsibility.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!resetLibrary	default := nil.! !!DynamicLibrary class methodsFor: 'as yet unclassified'!shutDown: aBool	default ifNotNil: [ default close ].! !!Executable class methodsFor: 'as yet unclassified'!huemul	^ self default! !!Executable class methodsFor: 'as yet unclassified'!moduleName	^nil.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: ByteArray! !!ExternalBuffer class methodsFor: 'as yet unclassified'!fromByteArray: aByteArray	| anExternalBuffer |		anExternalBuffer := ExternalBuffer new: aByteArray size.	anExternalBuffer setFrom: aByteArray.	^ anExternalBuffer.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!handleFromObject: aByteArray ifError: aBlock		(aByteArray isKindOf: ByteArray) ifFalse: [ 		^ super handleFromObject: aByteArray ifError: aBlock	].	^ ( self fromByteArray: aByteArray ) handle.! !!ExternalBuffer class methodsFor: 'as yet unclassified'!new: size	| anExternalBuffer |	"This space is allocated from the system not 	from Object Memory, you will have to give it back, 	as it is not garbage collected"	anExternalBuffer := LibC6 default malloc: (size +  10).	anExternalBuffer size: size.	^ anExternalBuffer! !!AsciiZ class methodsFor: 'as yet unclassified'!checkType: anObject 		^ anObject isKindOf: String! !!AsciiZ class methodsFor: 'as yet unclassified'!fromString: aString	| anAsciiZ |		anAsciiZ := AsciiZ new: aString size + 1.	anAsciiZ loadFrom: aString.	^ anAsciiZ.! !!AsciiZ class methodsFor: 'as yet unclassified'!handleFromObject: aString ifError: aBlock		(aString isKindOf: String) ifFalse: [ 		^ super handleFromObject: aString ifError: aBlock	].	^ ( self fromString: aString ) handle.! !!AsciiZ class methodsFor: 'as yet unclassified'!new: size	| buffer asciiZ |	buffer := super new: size.	asciiZ := AsciiZ new handle: buffer handle.	asciiZ size: size.	asciiZ atAllPutZero.	buffer handle: ExternalAddress nullPointer.	^ asciiZ! !!AsciiZ class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; asString! !!ExternalFunction class methodsFor: 'as yet unclassified'!name: aName library: aLibrary	^self new name: aName library: aLibrary! !!ExternalLibrary class methodsFor: 'as yet unclassified'!huemul	Huemul ifNil: [	"Represents the executable itself"		Huemul := self new.		Huemul open.	].	^ Huemul.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!handle	self object ifNil: [ handle beNull ].	^ handle.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!initialize	super initialize.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!initializePointer	self handle forObject: self object.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!object	^ self objectPointer at: 1! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!object: anObject	self objectPointer at: 1 put: anObject.	self initializePointer.! !!ExternalObjectProxy methodsFor: 'as yet unclassified'!objectPointer	object ifNil: [ object := WeakArray new: 1 ].	^ object! !!ExternalArrayProxy methodsFor: 'as yet unclassified'!initializePointer	self handle forArray: self object.! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!fromObject: anObject		^ self new object: anObject; yourself! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!handleFromObject: anObject ifError: aBlock		^ ( self fromObject: anObject ) handle.! !!ExternalObjectProxy class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		^ aBlock value! !!ExternalSymbol methodsFor: 'as yet unclassified'!address	handle isNull ifTrue: [ self bind ].	^ handle.! !!ExternalSymbol methodsFor: 'as yet unclassified'!bind	^ library bindSymbol: self.! !!ExternalSymbol methodsFor: 'as yet unclassified'!classFromType: aType	^ Smalltalk at: aType ifAbsent: [ self throwExternalSymbolError ].! !!ExternalSymbol methodsFor: 'as yet unclassified'!library	^ library! !!ExternalSymbol methodsFor: 'as yet unclassified'!library: aLibrary	library := aLibrary! !!ExternalSymbol methodsFor: 'as yet unclassified'!libraryName	^ library name.! !!ExternalSymbol methodsFor: 'as yet unclassified'!name	^name! !!ExternalSymbol methodsFor: 'as yet unclassified'!name: aName	name := aName! !!ExternalSymbol methodsFor: 'as yet unclassified'!name: aName library: aLibrary	self name: aName.	self library: aLibrary! !!ExternalSymbol methodsFor: 'as yet unclassified'!throwExternalSymbolError	^(ExternalSymbolError symbolName: name) signal.! !!ExternalSymbol methodsFor: 'as yet unclassified'!throwNotKnownError	^(ExternalSymbolError symbolName: name) signal.! !!ExecutableFunction methodsFor: 'as yet unclassified'!callingConventionString	self subclassResponsibility.! !!CDeclFunction methodsFor: 'as yet unclassified'!argTypes: anArrayOfTypes	argTypes := anArrayOfTypes.! !!CDeclFunction methodsFor: 'as yet unclassified'!callingConventionString	^ 'cdecl'! !!CDeclFunction methodsFor: 'as yet unclassified'!invoke	^self invokeWithArguments: #()! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1	^self invokeWithArguments: (Array with: arg1)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2	^self invokeWithArguments: (Array with: arg1 with: arg2)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4 with: arg5	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWith: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	^self invokeWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6)! !!CDeclFunction methodsFor: 'as yet unclassified'!invokeWithArguments: argArray	| argSize argHandleArray returnClass returnHandle |	argSize := argArray size.	argSize = argTypes size ifFalse: [ self throwExternalFunctionError ].	argHandleArray := Array new: argSize.	1 to: argSize do: [ :i |		| argType argClass argHandle arg |		argType := argTypes at: i.		argClass := self classFromType: argType.		arg := argArray at: i.		argHandle := argClass handleFromObject: arg.		argHandleArray at: i put: argHandle.	].	returnHandle := nil.	returnType = #Void ifFalse: [		returnClass := self classFromType: returnType.		returnHandle := returnClass defaultHandlerClass new.	].	handle isNull ifTrue: [ self bind ].	self primInvokeAnswering: returnHandle withArguments: argHandleArray.	returnType = #Void ifTrue: [ ^ nil ].	^ returnClass objectFromHandle: returnHandle.! !!CDeclFunction methodsFor: 'as yet unclassified'!primInvokeAnswering: aReturnValue withArguments: argArray	"Manually invoke the receiver, representing an external function."	<primitive: 204>	^self primitiveFailed! !!CDeclFunction methodsFor: 'as yet unclassified'!returnType: aType	returnType := aType.! !!CDeclFunction methodsFor: 'as yet unclassified'!returnType: aType argTypes: anArrayOfTypes	self returnType: aType.	self argTypes: anArrayOfTypes.! !!ExternalSymbol class methodsFor: 'as yet unclassified'!name: aName library: aLibrary	^self new name: aName library: aLibrary; bind! !!CDeclFunction class methodsFor: 'as yet unclassified'!name: aName library: aLibrary returnType: retType argTypes: argTypesArray	^self new name: aName library: aLibrary;		 returnType: retType argTypes: argTypesArray;		bind! !!ExternalSymbolError methodsFor: 'as yet unclassified'!isResumable	"Determine whether an exception is resumable."	^true! !!ExternalSymbolError methodsFor: 'as yet unclassified'!symbolName	^ symbolName! !!ExternalSymbolError methodsFor: 'as yet unclassified'!symbolName: argument	"Specify the function name that was beiing used."	symbolName := argument! !!ExternalSymbolError class methodsFor: 'as yet unclassified'!symbolName: argument	^self new symbolName: argument; yourself! !!FileDescriptor methodsFor: 'as yet unclassified'!close		self fileDescriptor > 2 ifTrue: [ 		LibC6 default close: self.		self fileDescriptor: -1.	]! !!FileDescriptor methodsFor: 'as yet unclassified'!fileDescriptor	^ SignedInteger objectFromHandle: handle. ! !!FileDescriptor methodsFor: 'as yet unclassified'!fileDescriptor: anInteger	handle := SignedInteger handleFromObject: anInteger. ! !!FileDescriptor methodsFor: 'as yet unclassified'!free		self close.! !!FileDescriptor methodsFor: 'as yet unclassified'!movePosition: offset"relative to actual position"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_CUR' ).	! !!FileDescriptor methodsFor: 'as yet unclassified'!position	^ self movePosition: 0.	! !!FileDescriptor methodsFor: 'as yet unclassified'!position: offset"absolute position"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_SET' ).! !!FileDescriptor methodsFor: 'as yet unclassified'!positionFromEnd: offset"relative to end of file"	^ LibC6 default lseek: self offset: offset whence: (LibC6 default valueForLSeekDirectiveNamed: 'SEEK_END' ).	! !!FileDescriptor methodsFor: 'as yet unclassified'!read: size	| retValue buffer |	buffer := ExternalBuffer new: size.	retValue := self readBuffer: buffer size: size.	! !!FileDescriptor methodsFor: 'as yet unclassified'!readBuffer: buffer size: size	^ LibC6 default read: self buffer: buffer size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!readString: aString	^ LibC6 default read: self string: aString size: aString size! !!FileDescriptor methodsFor: 'as yet unclassified'!readString: aString size: size	| internalSize |	internalSize := size.	aString size < size ifTrue: [ internalSize := aString size ].	^ LibC6 default read: self string: aString size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!size	| position size |	position := self position.	size := self positionFromEnd: 0.	self position: position.	^ size	! !!FileDescriptor methodsFor: 'as yet unclassified'!writeBuffer: buffer size: size	^ LibC6 default write: self buffer: buffer size: size! !!FileDescriptor methodsFor: 'as yet unclassified'!writeString: aString	^ LibC6 default write: self string: aString size: aString size! !!FileDescriptor methodsFor: 'as yet unclassified'!writeString: aString size: size	| internalSize |	internalSize := size.	aString size < size ifTrue: [ internalSize := aString size ].	^ LibC6 default write: self string: aString size: size! !!FileDescriptor class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalValue! !!FileDescriptor class methodsFor: 'as yet unclassified'!initialize	self initializeStandardDescriptors! !!FileDescriptor class methodsFor: 'as yet unclassified'!initializeStandardDescriptors	StandardDescriptors := Dictionary new.	StandardDescriptors at: #stdout put: (self newFileDescriptor: 0).	StandardDescriptors at: #stdin put: (self newFileDescriptor: 1).	StandardDescriptors at: #stderr put: (self newFileDescriptor: 2).! !!FileDescriptor class methodsFor: 'as yet unclassified'!newFileDescriptor: anInteger	^ self new fileDescriptor: anInteger; yourself.! !!FileDescriptor class methodsFor: 'as yet unclassified'!standardDescriptors	^ StandardDescriptors! !!FileDescriptor class methodsFor: 'as yet unclassified'!stderr	^ StandardDescriptors at: #stderr.! !!FileDescriptor class methodsFor: 'as yet unclassified'!stdin	^ StandardDescriptors at: #stdin.! !!FileDescriptor class methodsFor: 'as yet unclassified'!stdout	^ StandardDescriptors at: #stdout.! !!FileStream methodsFor: 'as yet unclassified'!atEnd	"Answer true if the current position is >= the end of file position.	 1/31/96 sw: subclassResponsibility"	self subclassResponsibility! !!FileStream class methodsFor: 'as yet unclassified'!fileDoesNotExistUserHandling: fullFileName	(GtkMessageDialog question: fullFileName, ' does not exist, create it?') = #yes		ifTrue: [ ^ self new open: fullFileName forWrite: true ].! !!FileStream class methodsFor: 'as yet unclassified'!fileExistsUserHandling: fullFileName	(GtkMessageDialog question: fullFileName, ' exist, overwrite it?') = #yes		ifTrue: [ ^ self new openForOverwrite: fullFileName ].! !!FileStream class methodsFor: 'as yet unclassified'!readOnlyFileDoesNotExistUserHandling: fullFileName	GtkMessageDialog error: fullFileName, ' does not exist'! !!FileDoesNotExistException methodsFor: 'as yet unclassified'!defaultAction	"The default action taken if the exception is signaled."	^self readOnly		ifTrue: [FileStream readOnlyFileDoesNotExistUserHandling: self fileName]		ifFalse: [FileStream fileDoesNotExistUserHandling: self fileName]! !!GIRBuilder methodsFor: 'as yet unclassified'!compiledMethod	| bytecodes |	bytecodes := self bytecodes.	bytecodes ifNil: [ ^ nil ].	^ CompiledMethod new		primitive: 0;		numArgs: self numArgs;		numTemps: self numTemps;		literals: self literals;		relocationInfo: self relocationInfo;		bytecodes: bytecodes;		debugInfo: debugInfo;		source: source;		relocate.! !!GPointer methodsFor: 'as yet unclassified'!initialize	handle := self class defaultHandlerClass new.! !!GPointer class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalAddress! !!GPointer class methodsFor: 'as yet unclassified'!handle: aByteArray	^self basicNew handle: aByteArray; yourself! !!GObject class methodsFor: 'as yet unclassified'!handleFromObject: object	^ object handle.	! !!Gtk methodsFor: 'as yet unclassified'!initialize	self initializeGtkLibrary.	self startMainLoop.! !!Gtk methodsFor: 'as yet unclassified'!isMainLoopRunning
mainLoopProcess kernelDisplay.
^mainLoopProcess notNil and: [mainLoopProcess isTerminated not]! !!Gtk class methodsFor: 'as yet unclassified'!main
"Starts the Gtk main loop"
Gtk default startMainLoop.! !!Gtk class methodsFor: 'as yet unclassified'!shutDown: quiting	"Quits the Gtk main loop"	Default ifNotNil: [		Default quitMainLoop.		Default close.		Default := nil.	].! !!GtkDemoStockIds methodsFor: 'as yet unclassified'!initialize	| model tree |	model := GtkListStore new: {String. String. String. String}.	GtkStockItem allStocks do: [ :ea |		ea ifNotNil: [			model append: {				ea stockId asGtkStockId.				ea stockId.				ea label.				Gtk acceleratorName: ea keyval asCharacter modifier: ea modifier}]].	tree := GtkTreeView model: model.	self createFirstColumn: tree.	tree appendColumns: {		GtkTreeViewColumn title: 'Label' text: 2.		GtkTreeViewColumn title: 'Accel' text: 3.		GtkTreeViewColumn title: 'ID' text: 0}.	tree selection when: #changed send: #onItemChanged: to: self withArgumentsFirst: {tree}.			self container: (GtkHBox spacing: 5).	self container		packStart: (GtkScrolledWindow withChild: tree);		packEnd: self createInfoFrame expand: false fill: false! !!GtkDemoStockIds methodsFor: 'as yet unclassified'!onItemChanged: aTreeView	aTreeView selectedRow in: [:row |		idLabel label: row first.		nameLabel label: '#', row second.		accelLabel label: row third.		iconImage stock: row second iconSize: #dialog]! !!InMidstOfFileinNotification methodsFor: 'as yet unclassified'!defaultAction	^ self resume: false! !!LibC methodsFor: 'as yet unclassified'!closeLibrary	cLibrary closeLibrary.	cLibrary := nil.! !!LibC methodsFor: 'as yet unclassified'!initializeCLibrary	cLibrary := ExternalLibrary new.	cLibrary name: 'libc.so.6'.	cLibrary openLibrary.! !!LibC class methodsFor: 'as yet unclassified'!shutDown: quiting	"Quits the Gtk main loop"	self default closeLibrary.	Default := nil.! !!LibC6 methodsFor: 'as yet unclassified'!close: fd	| retValue |	retValue := ( self cDeclFunctionNamed: #close ) invokeWith: fd.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #close ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!errno	^ (self libraryDataNamed: #errno) value.	! !!LibC6 methodsFor: 'as yet unclassified'!errno: errno	(self libraryDataNamed: #errno) value: errno.	! !!LibC6 methodsFor: 'as yet unclassified'!free: anExternalBuffer	( self cDeclFunctionNamed: #free ) invokeWith: anExternalBuffer.	! !!LibC6 methodsFor: 'as yet unclassified'!getCurrentDirName	| retValue |	[ retValue := ( self cDeclFunctionNamed: 'get_current_dir_name' asSymbol ) invoke ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: 'get_current_dir_name' asSymbol ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!getEnv: envVariable	^ ( self cDeclFunctionNamed: #getenv ) invokeWith: envVariable.! !!LibC6 methodsFor: 'as yet unclassified'!getpid	^ (self cDeclFunctionNamed: #getpid) invoke.	! !!LibC6 methodsFor: 'as yet unclassified'!initialize	super initialize.	self initializeUniStd.	self initializeStdLib.	self initializeString.	self initializeFCntl.	self initializeStdIO.	self initializeErrNO.! !!LibC6 methodsFor: 'as yet unclassified'!initializeErrNO	self initializeLibraryDataNamed: #errno type: #SignedInteger.! !!LibC6 methodsFor: 'as yet unclassified'!initializeFCntl	self initializeCDeclFunctionNamed: #open returnType: #FileDescriptor argTypes: #( AsciiZ SignedInteger UnsignedInteger ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeStdIO	self initializeCDeclFunctionNamed: #printf  returnType: #SignedInteger argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: #perror  returnType: #Void argTypes: #( AsciiZ  ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeStdLib	self initializeCDeclFunctionNamed: #malloc  returnType: #ExternalBuffer argTypes: #( UnsignedInteger  ).	self initializeCDeclFunctionNamed: #free  returnType: #Void argTypes: #( ExternalBuffer  ).	self initializeCDeclFunctionNamed: #getenv  returnType: #AsciiZ argTypes: #( AsciiZ ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeString	self initializeCDeclFunctionNamed: #strlen returnType: #UnsignedInteger argTypes: #( AsciiZ ).	self initializeCDeclFunctionNamed: #strcat returnType: #AsciiZ argTypes: #( AsciiZ AsciiZ ).	self initializeCDeclFunctionNamed: #strcpy returnType: #AsciiZ argTypes: #( AsciiZ AsciiZ ).	self initializeCDeclFunctionNamed: #strerror returnType: #ReadOnlyAsciiZ argTypes: #( SignedInteger ).	self initializeCDeclFunctionNamed: #memset returnType: #ExternalBuffer argTypes: #( ExternalBuffer SignedInteger  UnsignedInteger ).! !!LibC6 methodsFor: 'as yet unclassified'!initializeUniStd	self initializeCDeclFunctionNamed: #getpid  returnType: #UnsignedInteger argTypes: #().	self initializeCDeclFunctionNamed: 'get_current_dir_name' asSymbol  returnType: #AsciiZ argTypes: #().	self initializeCDeclFunctionNamed: #close  returnType: #SignedInteger argTypes: #( FileDescriptor ).	self initializeCDeclFunctionNamed: #lseek  returnType: #UnsignedInteger argTypes: #( FileDescriptor UnsignedInteger SignedInteger ).	self initializeCDeclFunctionNamed: #read  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalBuffer UnsignedInteger ).	self initializeCDeclFunctionNamed: #write  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalBuffer UnsignedInteger )."Redefinition of read for Strings"	symbolCache at: #readString put: (CDeclFunction name: #read library: self  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalArrayProxy UnsignedInteger ) )."Redefinition of write for Strings"	symbolCache at: #writeString put: (CDeclFunction name: #write library: self  returnType: #SignedInteger argTypes: #( FileDescriptor ExternalArrayProxy UnsignedInteger ) ).! !!LibC6 methodsFor: 'as yet unclassified'!lseek: fileDescriptor offset: offset whence: whence	| returnValue |	returnValue := (self cDeclFunctionNamed: #lseek) invokeWith: fileDescriptor with: offset with: whence.	returnValue < 0 ifTrue: [		self throwErrorForExternalFunctionNamed: #lseek.		^ nil.	].	^ returnValue.	! !!LibC6 methodsFor: 'as yet unclassified'!malloc: size	| retValue |	[ retValue := ( self cDeclFunctionNamed: #malloc ) invokeWith: size ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: #malloc withMessage: 'can not allocate memory' ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!memSet: buffer constant: c count: n	^ (self cDeclFunctionNamed: #memset) invokeWith: buffer with: c with: n.	! !!LibC6 methodsFor: 'as yet unclassified'!open: path flags: flags	^ self open: path flags: flags mode: 8r644	! !!LibC6 methodsFor: 'as yet unclassified'!open: path flags: flags mode: mode	| fileDescriptor |	fileDescriptor := (self cDeclFunctionNamed: #open) invokeWith: path with: flags with: mode.	fileDescriptor fileDescriptor < 0 ifTrue: [		self throwErrorForExternalFunctionNamed: #open.		^ nil.	].	^ fileDescriptor.	! !!LibC6 methodsFor: 'as yet unclassified'!perror: aString	( self cDeclFunctionNamed: #perror ) invokeWith: aString.	! !!LibC6 methodsFor: 'as yet unclassified'!printf: aString	^ ( self cDeclFunctionNamed: #printf ) invokeWith: aString.	! !!LibC6 methodsFor: 'as yet unclassified'!read: fd buffer: buffer size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #read ) invokeWith: fd with: buffer with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #read ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!read: fd string: aString size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #readString ) invokeWith: fd with: aString with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #readString ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!strCat: destString with: sourceString	^ ( self cDeclFunctionNamed: #strcat ) invokeWith: destString with: sourceString.	! !!LibC6 methodsFor: 'as yet unclassified'!strCpy: destString with: sourceString	^ ( self cDeclFunctionNamed: #strcpy ) invokeWith: destString with: sourceString.	! !!LibC6 methodsFor: 'as yet unclassified'!strError: errno	| retValue |	[ retValue := ( self cDeclFunctionNamed: #strerror ) invokeWith: errno ] 		on: TypeConvertionError		do: [ ^ self throwErrorForExternalFunctionNamed: #strerror ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!strLen: string	^ ( self cDeclFunctionNamed: #strlen ) invokeWith: string	! !!LibC6 methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName	^ self throwErrorForExternalFunctionNamed: functionName withMessage: (self strError: self errno).	! !!LibC6 methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName withMessage: aString	| error |	error := ExternalFunctionError functionName: functionName.	error messageText: aString.	^ error signal.	! !!LibC6 methodsFor: 'as yet unclassified'!valueForLSeekDirectiveNamed: aString	^ LSeekDirectives at: aString asSymbol.	! !!LibC6 methodsFor: 'as yet unclassified'!valueForOpenFlagNamed: aString	^ OpenFlags at: aString asSymbol.	! !!LibC6 methodsFor: 'as yet unclassified'!write: fd buffer: buffer size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #write ) invokeWith: fd with: buffer with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #write ].	^ retValue.	! !!LibC6 methodsFor: 'as yet unclassified'!write: fd string: aString size: size	| retValue |	retValue := ( self cDeclFunctionNamed: #writeString ) invokeWith: fd with: aString with: size.	retValue < 0 ifTrue: [ self throwErrorForExternalFunctionNamed: #writeString ].	^ retValue.	! !!LibC6 class methodsFor: 'as yet unclassified'!initialize	self initializeOpenFlags.	self initializeLSeekDirectives.! !!LibC6 class methodsFor: 'as yet unclassified'!initializeLSeekDirectives	| lSeekDirectives |		lSeekDirectives := Dictionary new.	lSeekDirectives at: 'SEEK_SET' put: 0.	lSeekDirectives at: 'SEEK_CUR' put: 1.	lSeekDirectives at: 'SEEK_END' put: 2.	LSeekDirectives := lSeekDirectives! !!LibC6 class methodsFor: 'as yet unclassified'!initializeOpenFlags	| flagArray openFlags |		flagArray := #( 		('O_RDONLY'		0)		('O_WRONLY'		8r1)		('O_RDWR'		8r2)		('O_CREAT'		8r100)			('O_EXCL'			8r200)			('O_NOCTTY'		8r400)			('O_TRUNC'		8r1000)			('O_APPEND'		8r2000)		('O_NONBLOCK'	8r4000)		('O_SYNC'		8r10000)		('O_ASYNC'		8r20000)	).	openFlags := Dictionary new.	flagArray do: [ :i |		openFlags at: i first asSymbol put: i second	].	OpenFlags := openFlags! !!LibC6 class methodsFor: 'as yet unclassified'!moduleName	^ 'libc.so.6'.! !!LibExample methodsFor: 'as yet unclassified'!getpid	^ GETPID invoke! !!LibExample class methodsFor: 'as yet unclassified'!getpid	^ GETPID! !!LibExample class methodsFor: 'as yet unclassified'!initialize	GETPID := CDeclFunction name: 'getpid' libraryNamed: 'libc.so.6' returnType: #UnsignedInteger argTypes: #().! !!LibReadLine methodsFor: 'as yet unclassified'!addHistory: aString	( self cDeclFunctionNamed: 'add_history' asSymbol ) invokeWith: aString.! !!LibReadLine methodsFor: 'as yet unclassified'!initialize	super initialize.	self initializeCDeclFunctionNamed: #readline  returnType: #AsciiZ argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'add_history' asSymbol returnType: #Void argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'read_history' asSymbol returnType: #SignedInteger argTypes: #( AsciiZ  ).	self initializeCDeclFunctionNamed: 'write_history' asSymbol returnType: #SignedInteger argTypes: #( AsciiZ  ).! !!LibReadLine methodsFor: 'as yet unclassified'!readHistory: aFileName	| errno |	errno := ( self cDeclFunctionNamed: 'read_history' asSymbol ) invokeWith: aFileName.	errno = 0 ifFalse: [ self throwErrorForExternalFunctionNamed: 'read_history' asSymbol errno: errno ].	^ errno.! !!LibReadLine methodsFor: 'as yet unclassified'!readline: prompt	^ ( self cDeclFunctionNamed: #readline ) invokeWith: prompt.! !!LibReadLine methodsFor: 'as yet unclassified'!throwErrorForExternalFunctionNamed: functionName errno: errno	| error |	error := ExternalFunctionError functionName: functionName.	error messageText: (LibC6 default strError: errno).	^ error signal.! !!LibReadLine methodsFor: 'as yet unclassified'!writeHistory: aFileName	| errno |	errno := ( self cDeclFunctionNamed: 'write_history' asSymbol ) invokeWith: aFileName.	errno = 0 ifFalse: [ self throwErrorForExternalFunctionNamed: 'write_history' asSymbol errno: errno ].	^ errno.! !!LibReadLine class methodsFor: 'as yet unclassified'!moduleName	^ 'libreadline.so.5'.! !!LibraryData methodsFor: 'as yet unclassified'!primitiveGetValue: valueHandle	<primitive: 216>	^self primitiveFailed! !!LibraryData methodsFor: 'as yet unclassified'!primitiveSetValue: valueHandle	<primitive: 217>	^self primitiveFailed! !!LibraryData methodsFor: 'as yet unclassified'!type	^ type.! !!LibraryData methodsFor: 'as yet unclassified'!type: aType	type := aType.! !!LibraryData methodsFor: 'as yet unclassified'!value	| valueClass valueHandle |	valueClass := self classFromType: type.	valueHandle := valueClass defaultHandlerClass new.	handle isNull ifTrue: [ self bind ].	self primitiveGetValue: valueHandle.	^ valueClass objectFromHandle: valueHandle.! !!LibraryData methodsFor: 'as yet unclassified'!value: aValue	| argHandle argClass |	argClass := self classFromType: type.	argHandle := argClass handleFromObject: aValue.	handle isNull ifTrue: [ self bind ].	self primitiveSetValue: argHandle! !!LibraryData class methodsFor: 'as yet unclassified'!name: aName library: aLibrary type: type	^self new name: aName library: aLibrary;		type: type;		bind! !!Metaclass methodsFor: 'as yet unclassified'!addObsoleteSubclass: aClass	"Do nothing."! !!Metaclass methodsFor: 'as yet unclassified'!canZapMethodDictionary	"Return true if it is safe to zap the method dictionary on #obsolete"	thisClass == nil		ifTrue:[^true]		ifFalse:[^thisClass canZapMethodDictionary]! !!Metaclass methodsFor: 'as yet unclassified'!isSystemDefined	"Answer false if I am a UniClass (an instance-specific lightweight class)"	^ true! !!NativeFunction methodsFor: 'as yet unclassified'!callingConventionString	^ 'native'! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver	^self invokeReceiver: receiver withArguments: #()! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1	^self invokeReceiver: receiver withArguments: (Array with: arg1)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4 with: arg5	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	^self invokeReceiver: receiver withArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6)! !!NativeFunction methodsFor: 'as yet unclassified'!invokeReceiver: receiver withArguments: argArray	handle isNull ifTrue: [ self bind ].	^ self primInvokeReceiver: receiver withArguments: argArray.! !!NativeFunction methodsFor: 'as yet unclassified'!primInvokeReceiver: receiver withArguments: argArray	"Manually invoke the receiver, representing an native function."	<primitive: 197>	^self primitiveFailed! !!ObjectTest methodsFor: 'as yet unclassified'!testBecome	"self debug: #testBecome"	"this test should that all the variables pointing to an object are pointing now to another one, and all      object pointing to the other are pointing to the object"	| pt1 pt2 pt3 |	pt1 := 0@0.	pt2 := pt1.	pt3 := 100@100.	pt1 become: pt3.	self assert: pt2 = (100@100).	self assert: pt3 = (0@0).	self assert: pt1 = (100@100).! !!ObjectTest methodsFor: 'as yet unclassified'!testBecomeForward	"self debug: #testBecomeForward"	"this test should that all the variables pointing to an object are pointing now to another one.	Not that this inverse is not true. This kind of become is called oneWayBecome in VW"	| pt1 pt2 pt3 |	pt1 := 0@0.	pt2 := pt1.	pt3 := 100@100.	pt1 becomeForward: pt3.	self assert: pt2 = (100@100).	self assert: pt3 == pt2.	self assert: pt1 = (100@100)! !!PrimitiveType class methodsFor: 'as yet unclassified'!defaultHandlerClass	^ ExternalValue! !!PrimitiveType class methodsFor: 'as yet unclassified'!handleFromObject: anObject	^ self handleFromObject: anObject ifError: [ self throwTypeConvertionError ]! !!PrimitiveType class methodsFor: 'as yet unclassified'!handleFromObject: object ifError: aBlock	self subclassResponsibility.! !!PrimitiveType class methodsFor: 'as yet unclassified'!objectFromHandle: handle	^ self objectFromHandle: handle ifError: [  self throwTypeConvertionError ]! !!PrimitiveType class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock	self subclassResponsibility.! !!PrimitiveType class methodsFor: 'as yet unclassified'!throwTypeConvertionError	^ TypeConvertionError new signal! !!IntegerType class methodsFor: 'as yet unclassified'!handleFromObject: anInteger ifError: aBlock	| handle |		(self checkType: anInteger) ifFalse: [ ^ aBlock value ].	handle := ExternalValue new.	self store: anInteger in: handle.	^ handle.	! !!IntegerType class methodsFor: 'as yet unclassified'!isBigEndian	^  false! !!IntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	self subclassResponsibility.! !!IntegerType class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: errorBlock	| value |		value := self loadFrom: handle.	(value > self max ) ifTrue: [ ^ errorBlock value ].	^ value.! !!Process methodsFor: 'as yet unclassified'!primitiveBeInitialProcess	<primitive: 196>	self primitiveFailed! !!ProcessorScheduler methodsFor: 'as yet unclassified'!activeProcess	^ self primActiveProcess! !!ProcessorScheduler methodsFor: 'as yet unclassified'!primActiveProcess	<primitive: 195>	self primitiveFail.! !!ProcessorScheduler methodsFor: 'as yet unclassified'!startUp	| firstProcess |"	(processList isNil or: [ processList isEmpty not ]) ifTrue: [ self initialize ]."	self initialize.	firstProcess := Process new.	firstProcess name: 'Init'.	firstProcess priority: self userSchedulingPriority.	firstProcess state: #running."	firstProcess threadData: self activeThreadData."	firstProcess primitiveBeInitialProcess.! !!ReadOnlyAsciiZ methodsFor: 'as yet unclassified'!asString	^ handle toString.! !!ReadOnlyAsciiZ class methodsFor: 'as yet unclassified'!handleFromObject: aByteArray ifError: aBlock	"Can not be used as arguments"	aBlock value.! !!ReadOnlyAsciiZ class methodsFor: 'as yet unclassified'!objectFromHandle: handle ifError: aBlock		handle isNull ifTrue: [ ^ aBlock value ].	^self basicNew handle: handle; asString! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!addressRelativeTo: bytecodes	| functionAddress bytecodesAddress |	functionAddress := self function address asInteger.	bytecodesAddress := (ExternalAddress forArray: bytecodes ) asInteger.	^ functionAddress - bytecodesAddress - offset - 4! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!function	^ self library functionNamed: functionName.! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!functionName	^ functionName! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!functionName: aSymbol	^ functionName := aSymbol! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!library	^ Executable default! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!patch: bytecodes	self patch: bytecodes with: (self addressRelativeTo: bytecodes).! !!ExecutableFunctionRelocation methodsFor: 'as yet unclassified'!patch: bytecodes with: value	bytecodes longAt: (offset + 1) put: value bigEndian: false.! !!FunctionRelocation methodsFor: 'as yet unclassified'!addressRelativeTo: bytecodes	^ self primAddressRelativeTo: bytecodes! !!FunctionRelocation methodsFor: 'as yet unclassified'!primAddressRelativeTo: bytecodes	<primitive: 155>	self primitiveFail.! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!defaultLibraryClass	^ NativeLibrary! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!library 		^ self defaultLibraryClass named: libraryName! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!libraryName	^ libraryName! !!NativeFunctionRelocation methodsFor: 'as yet unclassified'!libraryName: aSymbol	^ libraryName := aSymbol! !!ExternalFunctionRelocation methodsFor: 'as yet unclassified'!defaultLibraryClass	^ ExternalLibrary2! !!SequenceableCollection methodsFor: 'as yet unclassified'!asTraitComposition	"For convenience the composition {T1. T2 ...} is the same as T1 + T2 + ..."	^self isEmpty		ifFalse: [			self size = 1				ifTrue: [self first asTraitComposition]				ifFalse: [					self copyWithoutFirst 						inject: self first						into: [:left :right | left + right]]]		ifTrue: [			TraitComposition new]! !!Array methodsFor: 'as yet unclassified'!elementsExchangeIdentityWith: otherArray	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsExchangeIdentityWith: otherArray.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!elementsForwardIdentityTo: otherArray	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsForwardIdentityTo: otherArray.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!elementsForwardIdentityTo: otherArray copyHash: copyHash	| suspendedProcessList |	suspendedProcessList := Processor suspendAllButActive.	self primElementsForwardIdentityTo: otherArray copyHash: copyHash.	suspendedProcessList do: [ :each | each resume ].! !!Array methodsFor: 'as yet unclassified'!primElementsExchangeIdentityWith: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  At the same time, all pointers to the elements of otherArray are replaced by pointers to the corresponding elements of this array.  The identityHashes remain with the pointers rather than with the objects so that objects in hashed structures should still be properly indexed after the mutation."	<primitive: 128>	otherArray class == Array ifFalse: [^ self error: 'arg must be array'].	self size = otherArray size ifFalse: [^ self error: 'arrays must be same size'].	(self anySatisfy: [:obj | obj class == SmallInteger]) ifTrue: [^ self error: 'can''t become SmallIntegers'].	(otherArray anySatisfy: [:obj | obj class == SmallInteger]) ifTrue: [^ self error: 'can''t become SmallIntegers'].	"Must have failed because not enough space in forwarding table (see ObjectMemory-prepareForwardingTableForBecoming:with:twoWay:).  Do GC and try again only once"	(Smalltalk bytesLeft: true) = Smalltalk primitiveGarbageCollect		ifTrue: [^ self primitiveFailed].	^ self elementsExchangeIdentityWith: otherArray! !!Array methodsFor: 'as yet unclassified'!primElementsForwardIdentityTo: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  The identityHashes remain with the pointers rather than with the objects so that the objects in this array should still be properly indexed in any existing hashed structures after the mutation."	<primitive: 72>	self primitiveFailed! !!Array methodsFor: 'as yet unclassified'!primElementsForwardIdentityTo: otherArray copyHash: copyHash	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  The identityHashes remain with the pointers rather than with the objects so that the objects in this array should still be properly indexed in any existing hashed structures after the mutation."	<primitive: 249>	self primitiveFailed! !!ExternalValue methodsFor: 'as yet unclassified'!beNull	"Make the receiver a NULL pointer"	self atAllPut: 0.! !!ExternalValue methodsFor: 'as yet unclassified'!isNull	^(self basicAt: 1) = 0	and: (self basicAt: 2) = 0	and: (self basicAt: 3) = 0	and: (self basicAt: 4) = 0	! !!ExternalValue class methodsFor: 'as yet unclassified'!initialize	Smalltalk addToStartUpList: self.! !!ExternalValue class methodsFor: 'as yet unclassified'!new	"External addresses are always 4 bytes long"	^super new: 4! !!ExternalValue class methodsFor: 'as yet unclassified'!new: n	"You better don't try this..."	^self shouldNotImplement! !!ExternalValue class methodsFor: 'as yet unclassified'!startUp: resuming	resuming ifTrue: [		self allInstancesDo: [ :addr |			addr beNull		]	].! !!SharedPool class methodsFor: 'as yet unclassified'!bindingOf: varName	"Answer the binding of some variable resolved in the scope of the receiver"	| aSymbol binding |	aSymbol := varName asSymbol.	"First look in classVar dictionary."	binding := self classPool bindingOf: aSymbol.	binding ifNotNil:[^binding].	"Next look in shared pools."	self sharedPools do:[:pool | 		binding := pool bindingOf: aSymbol.		binding ifNotNil:[^binding].	].	"subclassing and environment are not preserved"	^nil! !!SharedPool class methodsFor: 'as yet unclassified'!bindingsDo: aBlock	^self classPool bindingsDo: aBlock! !!SharedPool class methodsFor: 'as yet unclassified'!classBindingOf: varName	"For initialization messages grant the regular scope"	^super bindingOf: varName! !!SharedPool class methodsFor: 'as yet unclassified'!hasBindingThatBeginsWith: aString	"Answer true if the receiver has a binding that begins with aString, false otherwise"	"First look in classVar dictionary."	(self classPool hasBindingThatBeginsWith: aString) ifTrue:[^true].	"Next look in shared pools."	self sharedPools do:[:pool | 		(pool hasBindingThatBeginsWith: aString) ifTrue: [^true]].	^false! !!SharedPool class methodsFor: 'as yet unclassified'!includesKey: aName	"does this pool include aName"	^(self bindingOf: aName) notNil! !!SharedPool class methodsFor: 'as yet unclassified'!keysDo: aBlock"A hopefully temporary fix for an issue arising from miss-spelled variable names in code being compiled. The correction code (see Class>possibleVariablesFor:continuedFrom: assumes that sharedPools are Dictionaries. The proper fix would involve making sure all pools are actually subclasses of SharedPool, which they are not currently."	self bindingsDo:[:b|		aBlock value: b key]! !!Shell methodsFor: 'as yet unclassified'!display: string	| buffer |		buffer := AsciiZ fromString: string.	^ FileDescriptor stdout writeBuffer: buffer size: buffer size.! !!Shell methodsFor: 'as yet unclassified'!input: prompt	^ LibReadLine default readline: prompt! !!Shell methodsFor: 'as yet unclassified'!main	| line value failed anotherLine buffer |	LibReadLine default readHistory: self historyFileName.	[		anotherLine := false.		buffer := ''.		[ 	| prompt |			prompt := anotherLine ifTrue: [ '' ] ifFalse: [ '> ' ].			line _ self input: prompt.			line isEmpty				ifTrue: [ true ] 				ifFalse: [					(line last = $\)						ifTrue: [							anotherLine := true.							line at: line size put: Character lf.						]						ifFalse: [ anotherLine := false ].					buffer := buffer, line.					anotherLine				]		] whileTrue. 		buffer = 'quit' or: [ buffer = 'save' ]	] whileFalse: [		self addToHistory: buffer.		failed _ false.		value _ Compiler new evaluate: buffer in: nil to: nil notifying: self ifFail: [ failed _ true].		failed ifFalse: [ self display: (value printString); lf ]	].	LibReadLine default writeHistory: self historyFileName.	buffer = 'save' ifTrue: [ Smalltalk snapshotAndQuit ].	^value.! !!SignedIntegerType class methodsFor: 'as yet unclassified'!checkType: value	^ value isInteger and: [ value >= self min and: [ value <= self max ] ]! !!SignedIntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	^ handle longAt: 1 bigEndian: self isBigEndian.! !!SignedIntegerType class methodsFor: 'as yet unclassified'!store: anInteger in: handle	handle longAt: 1 put: anInteger bigEndian: self isBigEndian.! !!SignedByte class methodsFor: 'as yet unclassified'!max			^ 127! !!SignedByte class methodsFor: 'as yet unclassified'!min			^ -128! !!SignedInteger class methodsFor: 'as yet unclassified'!max			^ 2147483647! !!SignedInteger class methodsFor: 'as yet unclassified'!min			^ -2147483648! !!SignedShortInteger class methodsFor: 'as yet unclassified'!max			^ 32767! !!SignedShortInteger class methodsFor: 'as yet unclassified'!min			^ -32768! !!SourceReference methodsFor: 'as yet unclassified'!sourceFrom: aString	self hasEmptySourceReference ifTrue: [ ^ '' ].	^ aString copyFrom: sourceStart to: sourceStop! !!StandardFileStream class methodsFor: 'as yet unclassified'!retryWithGC: execBlock until: testBlock forFileNamed: fullName	"Re-implemented to only force GC if a file with the given name exists"	| blockValue foundIt |	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	"See if we have a file with the given name"	foundIt := self registry keys "hold on strongly for now" 		anySatisfy:[:file| file name sameAs: fullName].	foundIt ifFalse:[^blockValue].	Smalltalk garbageCollectMost.	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollect.	^execBlock value.! !!SystemDictionary methodsFor: 'as yet unclassified'!forgetClass: aClass logged: aBool 	"Delete the class, aClass, from the system.	Note that this doesn't do everything required to dispose of a class - to do that use Class>>removeFromSystem."	aBool ifTrue: [SystemChangeNotifier uniqueInstance classRemoved: aClass fromCategory: aClass category].			SystemOrganization removeElement: aClass name.	self removeFromStartUpList: aClass.	self removeFromShutDownList: aClass.	self removeKey: aClass name ifAbsent: [].	self flushClassNameCache! !!SystemDictionary methodsFor: 'as yet unclassified'!removeClassNamed: aName	"Invoked from fileouts:  if there is currently a class in the system named aName, then remove it.  If anything untoward happens, report it in the Transcript.  "	| oldClass |	(oldClass _ self at: aName asSymbol ifAbsent: [nil]) == nil		ifTrue:			[Transcript cr; show: 'Removal of class named ', aName, ' ignored because ', aName, ' does not exist.'.			^ self].	oldClass removeFromSystem! !!SystemDictionary methodsFor: 'as yet unclassified'!startUp	Processor startUp.	ProcessorScheduler startUp.	self processStartUpList: true.	self installLowSpaceWatcher.! !!SystemTracer methodsFor: 'as yet unclassified'!getAligned: size	^ (( size + 3 ) bitShift: -2) bitShift: 2.! !!TraitBehavior methodsFor: 'as yet unclassified'!addUser: aClassOrTrait	users add: aClassOrTrait! !!TraitBehavior methodsFor: 'as yet unclassified'!classesComposedWithMe	^users gather: [:u | u classesComposedWithMe]! !!TraitBehavior methodsFor: 'as yet unclassified'!initialize	self methodDict: Dictionary new.	self traitComposition: nil.	users _ IdentitySet new.! !!TraitBehavior methodsFor: 'as yet unclassified'!removeUser: aClassOrTrait	users remove: aClassOrTrait ifAbsent: []! !!TraitBehavior methodsFor: 'as yet unclassified'!users	^users! !!TraitComposition methodsFor: 'as yet unclassified'!assertValidUser: aBehavior	"Assert that this trait composition set for aBehavior	does not introduce a cycle."		(self allTraits includes: aBehavior) ifTrue: [		TraitCompositionException signal: 'Cycle in compositions:  The composition (in)directly includes this trait!!']! !!TraitComposition methodsFor: 'as yet unclassified'!methodDescriptionsForSelector: aSymbol	"Return a collection of TraitMethodDescriptions for aSymbol and all the 	aliases of aSymbol."	| selectors collection |	selectors _ IdentitySet with: aSymbol.	self transformations do: [:each |		selectors addAll: (each aliasesForSelector: aSymbol)].	collection _ OrderedCollection new: selectors size.	selectors do: [:each |		collection add: (self methodDescriptionForSelector: each)].	^collection! !!TraitDescription methodsFor: 'as yet unclassified'!trait	"for compatibility with TraitTransformations"	^ self! !!TraitDescription methodsFor: 'as yet unclassified'!updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil	| currentCategory effectiveCategory sel changedCategories composition |	changedCategories _ IdentitySet new.	composition := self hasTraitComposition		ifTrue: [self traitComposition]		ifFalse: [TraitComposition new].	(composition methodDescriptionsForSelector: aSymbol) do: [:each |		sel _ each selector.		(self includesLocalSelector: sel) ifFalse: [			currentCategory _ self organization categoryOfElement: sel.			effectiveCategory _ each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.			effectiveCategory isNil ifTrue: [				currentCategory ifNotNil: [changedCategories add: currentCategory].				self organization removeElement: sel.			] ifFalse: [				((currentCategory isNil or: [currentCategory == ClassOrganizer ambiguous or: [currentCategory == oldCategoryOrNil]]) and: [currentCategory ~~ effectiveCategory]) ifTrue: [					currentCategory ifNotNil: [changedCategories add: currentCategory].					self organization 						classify: sel 						under: effectiveCategory						suppressIfDefault: false]]]].	^ changedCategories! !!TraitDescription methodsFor: 'as yet unclassified'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	(self includesSelector: aSelector)		ifTrue: [^ self organization categoryOfElement: aSelector]		ifFalse: [^nil]! !!Trait methodsFor: 'as yet unclassified'!initialize	super initialize.	classTrait _ ClassTrait for: self! !!TranscriptCodeView class methodsFor: 'as yet unclassified'!initialize	Smalltalk addToStartUpList: self.! !!TranscriptCodeView class methodsFor: 'as yet unclassified'!startUp: resuming	resuming ifTrue: [		TranscriptCodeBuffer := nil.	].! !!TranscriptStream methodsFor: 'as yet unclassified'!open	TranscriptCodeEditor open.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!atEnd	position ifNil: [ ^ nil ].	^ position >= readLimit! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!close	"Close this file."	fileID ifNotNil: [		fileID close.		fileID := nil.		position := nil.	].! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!open: fileName flags: flags	[ fileID := LibC6 default open: fileName flags: flags ]		on: ExternalFunctionError		do: [ ^ nil ].	name := fileName.	readLimit := fileID size.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!open: fileName forWrite: writeMode 	| flags |	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	flags := writeMode 		ifTrue: [ LibC6 default valueForOpenFlagNamed: 'O_RDWR' ]		ifFalse: [ LibC6 default valueForOpenFlagNamed: 'O_RDONLY' ].	rwmode := writeMode.	^ self open: fileName flags: flags.! !!UnbufferedFileStream methodsFor: 'as yet unclassified'!openForOverwrite: fileName	| flags |	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	flags := ((LibC6 default valueForOpenFlagNamed: 'O_RDWR') 			bitOr: ( LibC6 default valueForOpenFlagNamed: 'O_TRUNC' )) 			bitOr: ( LibC6 default valueForOpenFlagNamed: 'O_CREAT' ).	rwmode := true.	^ self open: fileName flags: flags.! !!BufferedFileStream methodsFor: 'as yet unclassified'!close	"Close this file."	self flush.	^ super close.! !!BufferedFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	self subclassResponsibility! !!BufferedFileStream methodsFor: 'as yet unclassified'!defaultBufferSize	^ DefaultBufferSize.! !!BufferedFileStream methodsFor: 'as yet unclassified'!flush	| bufferPosition bufferSize |	fileID ifNil: [ ^ nil ].	rwmode ifFalse: [ ^ nil ].	bufferPosition := position truncateTo: (collection size).	bufferSize := collection size min: ( readLimit - bufferPosition).	fileID position: bufferPosition.	bufferSize > 0 ifTrue: [ fileID writeString: collection size: bufferSize ].	 ! !!BufferedFileStream methodsFor: 'as yet unclassified'!initializeBuffer	| bufferSize |	position := 0.	collection := self defaultBufferClass new: self defaultBufferSize.	bufferSize := collection size min: readLimit.	bufferSize > 0 ifTrue: [ fileID readString: collection size: bufferSize ]. ! !!BufferedFileStream methodsFor: 'as yet unclassified'!next	| byte |	byte := self peek.	self position: position + 1.	^ byte! !!BufferedFileStream methodsFor: 'as yet unclassified'!nextPut: char	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	position ifNil: [ self position: 0 ].	collection at: (position \\ (collection size)) + 1put: char.	self position: position + 1.	^ char! !!BufferedFileStream methodsFor: 'as yet unclassified'!open: fileName flags: flags	(super open: fileName flags: flags) ifNotNil: [ self initializeBuffer ].! !!BufferedFileStream methodsFor: 'as yet unclassified'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	position ifNil: [ self position: 0 ].	self atEnd ifTrue: [^ nil ].	^ collection at: (position \\ (collection size)) + 1.! !!BufferedFileStream methodsFor: 'as yet unclassified'!position: newPosition	| oldBufferPosition newBufferPosition bufferSize |	fileID ifNil: [ ^nil ].	newPosition < 0 ifTrue: [ ^nil ]."	((newPosition > readLimit) and: [ rwmode not ])  ifTrue: [ ^nil ]."	newPosition > readLimit ifTrue: [		rwmode ifTrue: [ readLimit := newPosition ] ifFalse: [ ^nil ]	].	oldBufferPosition := position truncateTo: (collection size).	newBufferPosition := newPosition truncateTo: (collection size).	newBufferPosition = oldBufferPosition ifFalse: [ 		self flush.		fileID position: newBufferPosition.		bufferSize := collection size min: ( readLimit - newBufferPosition).		collection := self defaultBufferClass new: self defaultBufferSize.		bufferSize > 0 ifTrue: [ fileID readString: collection size: bufferSize ].	].	position := newPosition."	rwmode ifTrue: [ readLimit := newPosition ]."	^ position.! !!BinaryFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	^ ByteArray! !!TextFileStream methodsFor: 'as yet unclassified'!defaultBufferClass	^ String! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!concreteStream	"Who should we really direct class queries to?  "	^ UnbufferedFileStream.! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!fileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new open: fileName forWrite: true! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!forceNewFileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new openForOverwrite: fileName! !!UnbufferedFileStream class methodsFor: 'as yet unclassified'!readOnlyFileNamed: fileName 	"Open an existing file with the given name for reading."	| f |	f := self new open: fileName forWrite: false.	^ f isNil		ifFalse: [f]		ifTrue: ["File does not exist..."			((FileDoesNotExistException fileName: fileName) readOnly: true) signal].	"StandardFileStream readOnlyFileNamed: 'kjsd.txt' "! !!BufferedFileStream class methodsFor: 'as yet unclassified'!initialize	self initializeDefaultBufferSize.! !!BufferedFileStream class methodsFor: 'as yet unclassified'!initializeDefaultBufferSize	DefaultBufferSize := 4096.! !!BufferedFileStream class methodsFor: 'as yet unclassified'!new	^ TextFileStream new.! !!UnhandledError methodsFor: 'as yet unclassified'!devDefaultAction	"The current computation is terminated. The cause of the error should be logged or reported to the user. If the program is operating in an interactive debugging environment the computation should be suspended and the debugger activated."	(GtkMessageDialog question: exception messageText, ', debug it?' ) = #yes		ifTrue: [ ^Processor activeProcess debugError: exception ]."	^ Processor activeProcess terminate."! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!checkType: value	^ value isInteger and: [ value >= 0 and: [ value <= self max ] ]! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!loadFrom: handle	^ handle unsignedLongAt: 1 bigEndian: self isBigEndian.! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!min	^ 0! !!UnsignedIntegerType class methodsFor: 'as yet unclassified'!store: anInteger in: handle	handle unsignedLongAt: 1 put: anInteger bigEndian: self isBigEndian.! !!UnsignedByte class methodsFor: 'as yet unclassified'!max			^ 255! !!UnsignedInteger class methodsFor: 'as yet unclassified'!max			^ 4294967295! !!UnsignedShortInteger class methodsFor: 'as yet unclassified'!max			^ 65535! !!Workspace methodsFor: 'as yet unclassified'!buildMenuBar	| menu  edit  |	menu := GtkMenuBar new.	edit := GtkMenu new.	menu		append: AppLauncher fileMenu;		append: (edit createMenuItem: '_Edit');		append: workspaceView menu;		append: AppLauncher toolsMenu;		append: AppLauncher helpMenu.					^ menu.! !!Workspace methodsFor: 'as yet unclassified'!buildToolBar	| toolBar |	^ GtkToolbar new		appendItems: workspaceView toolBar;		yourself! !!Workspace methodsFor: 'as yet unclassified'!defaultCodeViewClass	^ WorkspaceView! !!Workspace methodsFor: 'as yet unclassified'!initialize	workspaceView := self defaultCodeViewClass new.	self container: (GtkVBox new		packStart: (self buildMenuBar) expand: false;		packStart: (self buildToolBar) expand: false;		packStart: (workspaceView view);		packStart: (GtkStatusbar new) expand: false	).! !!Workspace methodsFor: 'as yet unclassified'!inspectedVar: anObject	workspaceView inspectedVar: anObject.! !!TranscriptCodeEditor methodsFor: 'as yet unclassified'!defaultCodeViewClass	^ TranscriptCodeView! !!Workspace class methodsFor: 'as yet unclassified'!defaultSize	^ 640@480.! !!Workspace class methodsFor: 'as yet unclassified'!title	^'Workspace'! !!TranscriptCodeEditor class methodsFor: 'as yet unclassified'!title	^'Transcript'! !BufferedFileStream initialize!TranscriptCodeView initialize!TraitBehavior removeSelector: #initializeUsers!Application subclass: #Shell	instanceVariableNames: 'bindings'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Application'!ExternalValue initialize!NativeFunctionRelocation removeSelector: #addressRelativeTo:!NativeFunctionRelocation removeSelector: #function!NativeFunctionRelocation removeSelector: #functionName!NativeFunctionRelocation removeSelector: #functionName:!NativeFunctionRelocation removeSelector: #patch:!NativeFunctionRelocation removeSelector: #patch:with:!ReadOnlyAsciiZ class removeSelector: #objectFromHandle:!ProcessorScheduler removeSelector: #activeProcess2!ProcessorScheduler removeSelector: #activeThreadData!ProcessorScheduler removeSelector: #primActiveThreadData!Process removeSelector: #threadData:!PrimitiveType class removeSelector: #defaultHandlerType!PrimitiveType class removeSelector: #instantiateHandler!NativeFunction removeSelector: #address!NativeFunction removeSelector: #bind!NativeFunction removeSelector: #invoke!NativeFunction removeSelector: #invokeAnswering:!NativeFunction removeSelector: #invokeAnswering:with:!NativeFunction removeSelector: #invokeAnswering:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:with:with:with:with:with:with:!NativeFunction removeSelector: #invokeAnswering:withArguments:!NativeFunction removeSelector: #invokeWith:!NativeFunction removeSelector: #invokeWith:with:!NativeFunction removeSelector: #invokeWith:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:with:!NativeFunction removeSelector: #invokeWith:with:with:with:with:with:!NativeFunction removeSelector: #invokeWithArguments:!NativeFunction removeSelector: #name!NativeFunction removeSelector: #name:!NativeFunction removeSelector: #throwNotKnownError!LibraryData removeSelector: #primitiveGetValue!LibExample initialize!LibC6 initialize!LibC6 removeSelector: #initializeUnistd!LibC6 removeSelector: #openPath:flags:!LibC6 removeSelector: #write2:buffer:size:!LibC removeSelector: #close!GPointer class removeSelector: #instantiateHandler!FileStream removeSelector: #position!FileDescriptor initialize!FileDescriptor removeSelector: #movePositionTo:!FileDescriptor removeSelector: #name!FileDescriptor removeSelector: #name:!FileDescriptor removeSelector: #positionFromEns:!FileDescriptor removeSelector: #setPositionAt:!FileDescriptor removeSelector: #setPositionFromEndAt:!CDeclFunction class removeSelector: #name:libraryNamed:returnType:argTypes:!ExecutableFunction class removeSelector: #name:library:!ExecutableFunction class removeSelector: #name:libraryNamed:!CDeclFunction removeSelector: #classFromType:!CDeclFunction removeSelector: #throwExternalFunctionError!ExecutableFunction removeSelector: #address!ExecutableFunction removeSelector: #bind!ExecutableFunction removeSelector: #invoke!ExecutableFunction removeSelector: #invokeWith:!ExecutableFunction removeSelector: #invokeWith:with:!ExecutableFunction removeSelector: #invokeWith:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:with:!ExecutableFunction removeSelector: #invokeWith:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithArguments:!ExecutableFunction removeSelector: #invokeWithReceiver:!ExecutableFunction removeSelector: #invokeWithReceiver:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:with:with:with:with:with:with:!ExecutableFunction removeSelector: #invokeWithReceiver:withArguments:!ExecutableFunction removeSelector: #library!ExecutableFunction removeSelector: #library:!ExecutableFunction removeSelector: #libraryName!ExecutableFunction removeSelector: #libraryNamed:!ExecutableFunction removeSelector: #name!ExecutableFunction removeSelector: #name:!ExecutableFunction removeSelector: #name:library:!ExecutableFunction removeSelector: #name:libraryNamed:!ExecutableFunction removeSelector: #primInvokeReceiver:withArguments:!ExecutableFunction removeSelector: #primInvokeWithArguments:!ExecutableFunction removeSelector: #primInvokeWithReceiver:withArguments:!ExecutableFunction removeSelector: #throwNotKnownError!ExternalSymbol removeSelector: #callingConventionString!ExternalObjectProxy removeSelector: #register!ExternalObjectProxy removeSelector: #unregister!AsciiZ class removeSelector: #objectFromHandle:!Executable class removeSelector: #huenul!DynamicLibrary class removeSelector: #addLibrary:named:!DynamicLibrary class removeSelector: #huemul!DynamicLibrary initialize!DynamicLibrary class removeSelector: #name:!DynamicLibrary class removeSelector: #named:!ExternalObject class removeSelector: #handle:!ExternalObject initialize!ExternalObject class removeSelector: #registry!ExternalObject class removeSelector: #registry:!AsciiZ removeSelector: #setFrom:!ExternalBuffer removeSelector: #finalize!ExternalBuffer removeSelector: #selfCheck!ExternalBuffer removeSelector: #setFrom:!ExternalBuffer removeSelector: #storeInto:size:!Executable removeSelector: #initialize!Executable removeSelector: #instantiateFunctionClass:!Executable removeSelector: #name:!Executable removeSelector: #nativeFunctionNamed:!Executable removeSelector: #primitiveOpen!DynamicLibrary removeSelector: #addExternal:!DynamicLibrary removeSelector: #basicName!DynamicLibrary removeSelector: #bind:!DynamicLibrary removeSelector: #bindFunction:!DynamicLibrary removeSelector: #cDeclFunctionNamed:returnType:argTypes:!DynamicLibrary removeSelector: #primitiveBind:!DynamicLibrary removeSelector: #primitiveBindFunction:!ExternalObject removeSelector: #isNullPointer!Object subclass: #ExternalObject	instanceVariableNames: 'handle'	classVariableNames: 'Registry'	poolDictionaries: ''	category: 'FFI-Types'!ExternalFunctionError class removeSelector: #function:!ExternalFunctionError removeSelector: #function!ExternalFunctionError removeSelector: #function:!ExternalFunctionError removeSelector: #isResumable!Error subclass: #ExternalFunctionError	instanceVariableNames: 'functionName'	classVariableNames: ''	poolDictionaries: ''	category: 'FFI-Errors'!Application class removeSelector: #start!Application class removeSelector: #startWithArguments:!Class removeSelector: #superclass:methodDict:format:name:organization:instVarNames:classPool:sharedPools:!ClassBuilder removeSelector: #computeFormat:instSize:forSuper:ccIndex:!ClassBuilder removeSelector: #format:variable:words:pointers:weak:!Smalltalk removeClassNamed: #SystemChangeNotifierTest!